<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ES6 语法</title>
    <meta name="description" content="ES6 语法 - Hongwei Zhao's Blog">
    <meta name="author" content="Hongwei Zhao">
    
    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Noto+Sans+SC:wght@300;400;500;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    
    <!-- Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <!-- Code Highlighting -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css" id="hljs-theme-dark">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css" id="hljs-theme-light" disabled>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    
    <!-- KaTeX for Math -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>
    
    <style>
        :root {
            /* Light Theme */
            --primary-color: #2980b9;
            --primary-hover: #1a5276;
            --link-color: #c0392b;
            --text-color: #333;
            --text-light: #666;
            --text-muted: #999;
            --bg-color: #fff;
            --bg-secondary: #f8f9fa;
            --bg-code: #f5f5f5;
            --border-color: #e5e7eb;
            --shadow: 0 1px 3px rgba(0,0,0,0.1);
            --shadow-lg: 0 4px 15px rgba(0,0,0,0.1);
        }

        [data-theme="dark"] {
            --primary-color: #5dade2;
            --primary-hover: #85c1e9;
            --link-color: #e74c3c;
            --text-color: #e5e7eb;
            --text-light: #9ca3af;
            --text-muted: #6b7280;
            --bg-color: #1a1a2e;
            --bg-secondary: #16213e;
            --bg-code: #0f0f23;
            --border-color: #374151;
            --shadow: 0 1px 3px rgba(0,0,0,0.3);
            --shadow-lg: 0 4px 15px rgba(0,0,0,0.4);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            scroll-behavior: smooth;
        }

        body {
            font-family: 'Inter', 'Noto Sans SC', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            font-size: 16px;
            line-height: 1.8;
            color: var(--text-color);
            background: var(--bg-color);
            transition: background-color 0.3s, color 0.3s;
        }

        a {
            color: var(--primary-color);
            text-decoration: none;
            transition: color 0.2s;
        }

        a:hover {
            color: var(--primary-hover);
            text-decoration: underline;
        }

        /* Layout */
        .page-wrapper {
            display: flex;
            max-width: 1400px;
            margin: 0 auto;
            padding: 2rem;
            gap: 3rem;
        }

        /* Sidebar TOC */
        .toc-sidebar {
            width: 260px;
            flex-shrink: 0;
            position: sticky;
            top: 2rem;
            height: fit-content;
            max-height: calc(100vh - 4rem);
            overflow-y: auto;
        }

        .toc-container {
            background: var(--bg-secondary);
            border-radius: 12px;
            padding: 1.5rem;
            border: 1px solid var(--border-color);
        }

        .toc-container h3 {
            font-size: 0.85rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-muted);
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .toc-container ul {
            list-style: none;
        }

        .toc-container li {
            margin-bottom: 0.5rem;
        }

        .toc-container a {
            font-size: 0.9rem;
            color: var(--text-light);
            display: block;
            padding: 0.25rem 0;
            border-left: 2px solid transparent;
            padding-left: 0.75rem;
            transition: all 0.2s;
        }

        .toc-container a:hover,
        .toc-container a.active {
            color: var(--primary-color);
            border-left-color: var(--primary-color);
            text-decoration: none;
        }

        .toc-container ul ul {
            margin-left: 1rem;
        }

        /* Main Content */
        .main-content {
            flex: 1;
            min-width: 0;
            max-width: 800px;
        }

        /* Header */
        .post-header {
            margin-bottom: 2rem;
            padding-bottom: 1.5rem;
            border-bottom: 1px solid var(--border-color);
        }

        .back-link {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.9rem;
            color: var(--text-light);
            margin-bottom: 1.5rem;
        }

        .back-link:hover {
            color: var(--primary-color);
            text-decoration: none;
        }

        .post-header h1 {
            font-size: 2.25rem;
            font-weight: 700;
            line-height: 1.3;
            margin-bottom: 1rem;
            color: var(--text-color);
        }

        .post-meta {
            display: flex;
            flex-wrap: wrap;
            gap: 1.5rem;
            font-size: 0.9rem;
            color: var(--text-light);
        }

        .post-meta span {
            display: flex;
            align-items: center;
            gap: 0.4rem;
        }

        .post-meta i {
            color: var(--text-muted);
        }

        .tags {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-top: 1rem;
        }

        .tag {
            display: inline-block;
            font-size: 0.8rem;
            background: var(--bg-secondary);
            color: var(--text-light);
            padding: 0.25rem 0.75rem;
            border-radius: 20px;
            border: 1px solid var(--border-color);
            transition: all 0.2s;
        }

        .tag:hover {
            background: var(--primary-color);
            color: white;
            border-color: var(--primary-color);
        }

        /* Article Content */
        .post-content {
            font-size: 1rem;
            line-height: 1.9;
        }

        .post-content h1,
        .post-content h2,
        .post-content h3,
        .post-content h4,
        .post-content h5,
        .post-content h6 {
            margin-top: 2rem;
            margin-bottom: 1rem;
            font-weight: 600;
            line-height: 1.4;
            color: var(--text-color);
        }

        .post-content h1 { font-size: 1.875rem; }
        .post-content h2 { 
            font-size: 1.5rem; 
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--border-color);
        }
        .post-content h3 { font-size: 1.25rem; }
        .post-content h4 { font-size: 1.125rem; }

        .post-content p {
            margin-bottom: 1.25rem;
        }

        .post-content ul,
        .post-content ol {
            margin: 1.25rem 0;
            padding-left: 1.5rem;
        }

        .post-content li {
            margin-bottom: 0.5rem;
        }

        .post-content blockquote {
            margin: 1.5rem 0;
            padding: 1rem 1.5rem;
            background: var(--bg-secondary);
            border-left: 4px solid var(--primary-color);
            border-radius: 0 8px 8px 0;
            color: var(--text-light);
            font-style: italic;
        }

        .post-content blockquote p:last-child {
            margin-bottom: 0;
        }

        /* Code */
        .post-content code {
            font-family: 'JetBrains Mono', 'Fira Code', Consolas, monospace;
            font-size: 0.9em;
            background: var(--bg-code);
            padding: 0.2em 0.4em;
            border-radius: 4px;
            color: var(--link-color);
        }

        .post-content pre {
            margin: 1.5rem 0;
            padding: 1.25rem;
            background: var(--bg-code);
            border-radius: 10px;
            overflow-x: auto;
            border: 1px solid var(--border-color);
        }

        .post-content pre code {
            background: none;
            padding: 0;
            color: inherit;
            font-size: 0.875rem;
            line-height: 1.6;
        }

        /* Images */
        .post-content img {
            max-width: 100%;
            height: auto;
            border-radius: 10px;
            margin: 1.5rem 0;
            box-shadow: var(--shadow-lg);
        }

        /* Tables */
        .post-content table {
            width: 100%;
            margin: 1.5rem 0;
            border-collapse: collapse;
            font-size: 0.95rem;
        }

        .post-content th,
        .post-content td {
            padding: 0.75rem 1rem;
            border: 1px solid var(--border-color);
            text-align: left;
        }

        .post-content th {
            background: var(--bg-secondary);
            font-weight: 600;
        }

        .post-content tr:nth-child(even) {
            background: var(--bg-secondary);
        }

        /* Math */
        .math-display {
            margin: 1.5rem 0;
            overflow-x: auto;
            padding: 1rem;
            background: var(--bg-secondary);
            border-radius: 8px;
        }

        /* Anchor links */
        .anchor-link {
            opacity: 0;
            margin-left: 0.5rem;
            color: var(--text-muted);
            font-weight: 400;
            transition: opacity 0.2s;
        }

        .post-content h2:hover .anchor-link,
        .post-content h3:hover .anchor-link,
        .post-content h4:hover .anchor-link {
            opacity: 1;
        }

        /* Theme Toggle */
        .theme-toggle {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: var(--primary-color);
            color: white;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.25rem;
            box-shadow: var(--shadow-lg);
            transition: transform 0.2s, background 0.2s;
            z-index: 1000;
        }

        .theme-toggle:hover {
            transform: scale(1.1);
            background: var(--primary-hover);
        }

        /* Comments Section */
        .comments-section {
            margin-top: 3rem;
            padding-top: 2rem;
            border-top: 1px solid var(--border-color);
        }

        .comments-section h3 {
            font-size: 1.25rem;
            margin-bottom: 1.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        /* Footer */
        .post-footer {
            margin-top: 3rem;
            padding-top: 1.5rem;
            border-top: 1px solid var(--border-color);
            text-align: center;
            font-size: 0.9rem;
            color: var(--text-muted);
        }

        /* Responsive */
        @media (max-width: 1024px) {
            .toc-sidebar {
                display: none;
            }
            
            .page-wrapper {
                padding: 1.5rem;
            }
        }

        @media (max-width: 768px) {
            .post-header h1 {
                font-size: 1.75rem;
            }
            
            .post-meta {
                flex-direction: column;
                gap: 0.5rem;
            }
            
            .theme-toggle {
                bottom: 1rem;
                right: 1rem;
                width: 44px;
                height: 44px;
            }
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-secondary);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--text-muted);
        }
    </style>
</head>
<body>
    <div class="page-wrapper">
        <!-- TOC Sidebar -->
        <aside class="toc-sidebar">
            <div class="toc-container">
                <h3><i class="fas fa-list"></i> 目录</h3>
                <div class="toc">
<ul>
<li><a href="#什么是-ecmascript">什么是 ECMAScript</a></li>
<li><a href="#es6新特性">ES6新特性</a><ul>
<li><a href="#1letvar">1.let/var</a></li>
<li><a href="#2const">2.const</a></li>
<li><a href="#3对象增强写法">3.对象增强写法</a></li>
<li><a href="#4解构表达式">4.解构表达式</a><ul>
<li><a href="#数组解构">数组解构</a></li>
<li><a href="#对象解构">对象解构</a></li>
</ul>
</li>
<li><a href="#5字符串扩展">5.字符串扩展</a><ul>
<li><a href="#新的api">新的API</a></li>
</ul>
</li>
<li><a href="#6函数优化">6.函数优化</a><ul>
<li><a href="#函数参数默认值">函数参数默认值</a></li>
<li><a href="#不定参数">不定参数</a></li>
<li><a href="#箭头函数">箭头函数</a></li>
</ul>
</li>
<li><a href="#7对象优化">7.对象优化</a><ul>
<li><a href="#新增的api">新增的API</a></li>
<li><a href="#声明对象简写">声明对象简写</a></li>
<li><a href="#对象的函数属性简写">对象的函数属性简写</a></li>
<li><a href="#对象拓展运算符">对象拓展运算符</a></li>
</ul>
</li>
<li><a href="#8map">8.map</a></li>
<li><a href="#9reduce">9.reduce</a></li>
<li><a href="#10this-使用">10.this 使用</a></li>
</ul>
</li>
</ul>
</div>

            </div>
        </aside>

        <!-- Main Content -->
        <main class="main-content">
            <article>
                <header class="post-header">
                    <a href="../../index.html" class="back-link">
                        <i class="fas fa-arrow-left"></i> 返回博客列表
                    </a>
                    <h1>ES6 语法</h1>
                    <div class="post-meta">
                        <span><i class="fas fa-calendar-alt"></i> 2026-01-28</span>
                        <span><i class="fas fa-folder"></i> ProgramNotes</span>
                        <span><i class="fas fa-user"></i> Hongwei Zhao</span>
                    </div>
                    <div class="tags">
                        
                    </div>
                </header>

                <div class="post-content">
                    <h1 id="es6-语法">ES6 语法<a class="anchor-link" href="#es6-语法" title="Permanent link">&para;</a></h1>
<p>ECMAScript 6.0（以下简称 ES6，ECMAScript 是一种由 Ecma 国际(前身为欧洲计算机制造商 协会,英文名称是 European Computer Manufacturers Association)通过 ECMA-262 标准化的脚本 程序设计语言）是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布了，并且 从 ECMAScript 6 开始，开始采用年号来做版本。即 ECMAScript 2015， 就是 ECMAScript6。 它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。 每年一个新版本。</p>
<p><img alt="image-20230213080150144" src="https://markdownimg-hw.oss-cn-beijing.aliyuncs.com/image202302130802384.png" /></p>
<h2 id="什么是-ecmascript">什么是 ECMAScript<a class="anchor-link" href="#什么是-ecmascript" title="Permanent link">&para;</a></h2>
<p>来看下前端的发展历程：</p>
<ol>
<li>web1.0 时代： 最初的网页以 HTML 为主，是纯静态的网页。网页是只读的，信息流只能从服务的到客户端 单向流通。开发人员也只关心页面的样式和内容即可。</li>
</ol>
<ul>
<li>1995 年，网景工程师 Brendan Eich 花了 10 天时间设计了 JavaScript 语言。</li>
</ul>
<ol start="2">
<li>web2.0 时代：</li>
</ol>
<ul>
<li>
<p>1996 年，微软发布了 JScript，其实是 JavaScript 的逆向工程实现。</p>
</li>
<li>
<p>1996 年 11 月，JavaScript 的创造者 Netscape 公司，决定将 JavaScript 提交给标准化组 织 ECMA，希望这种语言能够成为国际标准。</p>
</li>
<li>
<p>1997 年，ECMA 发布 262 号标准文件（ECMA-262）的第一版，规定了浏览器脚本语言的 标准， 并将这种语言称为 ECMAScript， 这个版本就是 1.0 版。 JavaScript 和 JScript 都是 <code>ECMAScript</code>的标准实现者，随后各大浏览器厂商纷纷实现了<code>ECMAScript</code>标准。</p>
</li>
</ul>
<p>所以，ECMAScript 是浏览器脚本语言的<strong>规范</strong>，而各种我们熟知的 js 语言，如 JavaScript 则是规范的具体实现。</p>
<h2 id="es6新特性">ES6新特性<a class="anchor-link" href="#es6新特性" title="Permanent link">&para;</a></h2>
<h3 id="1letvar">1.let/var<a class="anchor-link" href="#1letvar" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>let</th>
<th>var</th>
</tr>
</thead>
<tbody>
<tr>
<td>let 声明的变量有严格局部作用域</td>
<td>var 声明的变量往往会越域</td>
</tr>
<tr>
<td>let 只能声明一次</td>
<td>var 可以声明多次</td>
</tr>
<tr>
<td>let 不存在变量提升</td>
<td>var 会变量提升</td>
</tr>
</tbody>
</table>
<pre><code class="language-html">// var 声明的变量往往会越域
// let 声明的变量有严格局部作用域 {
var a = 1;
let b = 2;
} 
console.log(a); // 1
console.log(b); // ReferenceError: b is not defined

// var 可以声明多次 
// let 只能声明一次
var m = 1
var m = 2
let n = 3
// let n = 4
console.log(m) // 2
console.log(n)// Identifier 'n' has already been declared

// var 会变量提升 
// let 不存在变量提升 
console.log(x); // undefined
var x = 10;
console.log(y); //ReferenceError: y is not defined
let y = 20;
</code></pre>
<p>JS 中使用 var 来声明一个变量时, 变量的作用域主要是和函数的定义有关</p>
<pre><code class="language-html">&lt;button&gt;按钮1&lt;/button&gt;
&lt;button&gt;按钮2&lt;/button&gt;
&lt;button&gt;按钮3&lt;/button&gt;

&lt;script&gt;
  // 1.没有块级作用域引起的问题: for的块级
  // 为什么闭包可以解决问题: 函数是一个作用域.
  var btns = document.getElementsByTagName('button')
  for (var i = 0; i &lt; btns.length; i++) {
    btns[i].addEventListener('click', function () {
      console.log('第' + i + '个按钮被点击')
    })
  }

  // 1.情况一: ES5中没有使用闭包(错误的方式)
  i = 2
  {
    // i = 0
    btns[i].addEventListener('click', function () {
      console.log('第' + i + '个按钮被点击')
    })
  }

  {
    i = 1
    btns[i].addEventListener('click', function () {
      console.log('第' + i + '个按钮被点击')
    })
  }

  {
    // i = 2
    btns[i].addEventListener('click', function () {
      console.log('第' + i + '个按钮被点击')
    })
  }

  // 2.情况二: ES5中使用闭包
  var btns = document.getElementsByTagName('button')
  for (var i = 0; i &lt; btns.length; i++) {
    ;(function (i) {
      // 0
      btns[i].addEventListener('click', function () {
        console.log('第' + i + '个按钮被点击')
      })
    })(i)
  }

  i = 100000000(
    (function (i) {
      // i = 0
      btns[i].addEventListener('click', function () {
        console.log('第' + i + '个按钮被点击')
      })
    })(0)
  )(
    (function (i) {
      // i = 1
      btns[i].addEventListener('click', function () {
        console.log('第' + i + '个按钮被点击')
      })
    })(1)
  )(
    (function (i) {
      // i = 2
      btns[i].addEventListener('click', function () {
        console.log('第' + i + '个按钮被点击')
      })
    })(2)
  )

  // ES6中的let
  const btns = document.getElementsByTagName('button')
  for (let i = 0; i &lt; btns.length; i++) {
    btns[i].addEventListener('click', function () {
      console.log('第' + i + '个按钮被点击')
    })
  }
  i = 10000000
  {
    i = 0
    btns[i].addEventListener('click', function () {
      console.log('第' + i + '个按钮被点击')
    })
  }

  {
    i = 1
    btns[i].addEventListener('click', function () {
      console.log('第' + i + '个按钮被点击')
    })
  }

  {
    i = 2
    btns[i].addEventListener('click', function () {
      console.log('第' + i + '个按钮被点击')
    })
  }
&lt;/script&gt;
</code></pre>
<h3 id="2const">2.const<a class="anchor-link" href="#2const" title="Permanent link">&para;</a></h3>
<p>建议: 在 ES6 开发中,优先使用 const, 只有需要改变某一个标识符的时候才使用 let.</p>
<blockquote>
<ul>
<li>声明之后不允许改变</li>
<li>一但声明必须初始化，否则会报错</li>
</ul>
</blockquote>
<pre><code class="language-html">&lt;script&gt;
  // 1.注意一: 一旦给const修饰的标识符被赋值之后, 不能修改
  // const name = 'why';
  // name = 'abc';  //错误  不可修改

  // 2.注意二: 在使用const定义标识符,必须进行赋值
  // const name;  //错误

  // 3.注意三: 常量的含义是指向的对象不能修改, 但是可以改变对象内部的属性.
  const obj = {
    name: 'why',
    age: 18,
    height: 1.88,
  }
  // obj = {}
  console.log(obj)

  obj.name = 'kobe'
  obj.age = 40
  obj.height = 1.87

  console.log(obj)
&lt;/script&gt;
</code></pre>
<h3 id="3对象增强写法">3.对象增强写法<a class="anchor-link" href="#3对象增强写法" title="Permanent link">&para;</a></h3>
<pre><code class="language-html">&lt;script&gt;
  // const obj = new Object()

  //1.普通写法
  // const obj = {
  //   name: 'why',
  //   age: 18,
  //   run: function () {
  //     console.log('在奔跑');
  //   },
  //   eat: function () {
  //     console.log('在次东西');
  //   }
  // }
  //增强写法
  // 1.属性的增强写法
  const name = 'why'
  const age = 18
  const height = 1.88

  // ES5的写法
  // const obj = {
  //   name: name,
  //   age: age,
  //   height: height
  // }
  // ES6的写法
  // const obj = {
  //   name,
  //   age,
  //   height,
  // }
  //
  // console.log(obj);

  // 2.函数的增强写法
  // ES5的写法
  // const obj = {
  //   run: function () {
  //
  //   },
  //   eat: function () {
  //
  //   }
  // }
  //ES6的写法
  const obj = {
    run() {},
    eat() {},
  }
&lt;/script&gt;
</code></pre>
<h3 id="4解构表达式">4.解构表达式<a class="anchor-link" href="#4解构表达式" title="Permanent link">&para;</a></h3>
<h4 id="数组解构">数组解构<a class="anchor-link" href="#数组解构" title="Permanent link">&para;</a></h4>
<pre><code class="language-html">let arr = [1,2,3];
//以前我们想获取其中的值，只能通过角标。ES6 可以这样：
const [x,y,z] = arr;// x，y，z 将与 arr 中的每个位置对应来取值 // 然后打印
console.log(x,y,z);
</code></pre>
<h4 id="对象解构">对象解构<a class="anchor-link" href="#对象解构" title="Permanent link">&para;</a></h4>
<pre><code class="language-html">const person = {
name: &quot;jack&quot;,
age: 21,
language: [ 'java ', 'js ', 'css ']
}
// 解构表达式获取值，将 person 里面每一个属性和左边对应赋值
const { name, age, language } = person;
// 等价于下面
// const name = person.name;
// const age = person.age;
// const language = person.language;
// 可以分别打印
console.log(name);
console.log(age);
console.log(language);

//扩展：如果想要将 name 的值赋值给其他变量，可以如下,nn 是新的变量名
const { name: nn, age, language } = person;
console.log(nn);
console.log(age);
console.log(language);
</code></pre>
<h3 id="5字符串扩展">5.字符串扩展<a class="anchor-link" href="#5字符串扩展" title="Permanent link">&para;</a></h3>
<h4 id="新的api">新的API<a class="anchor-link" href="#新的api" title="Permanent link">&para;</a></h4>
<p>ES6 为字符串扩展了几个新的 API：<br />
- <code>includes()</code> ：返回布尔值，表示是否找到了参数字符串。<br />
- <code>startsWith()</code> ：返回布尔值，表示参数字符串是否在原字符串的头部。<br />
- <code>endsWith()</code> ：返回布尔值，表示参数字符串是否在原字符串的尾部。</p>
<pre><code>let str = &quot;hello.vue&quot;;
console.log(str.startsWith(&quot;hello&quot;));//true
console.log(str.endsWith(&quot;.vue&quot;));//true
console.log(str.includes(&quot;e&quot;));//true
console.log(str.includes(&quot;hello&quot;));//true
</code></pre>
<h3 id="6函数优化">6.函数优化<a class="anchor-link" href="#6函数优化" title="Permanent link">&para;</a></h3>
<h4 id="函数参数默认值">函数参数默认值<a class="anchor-link" href="#函数参数默认值" title="Permanent link">&para;</a></h4>
<pre><code>//在 ES6 以前，我们无法给一个函数参数设置默认值，只能采用变通写法：
function add(a, b) {
// 判断 b 是否为空，为空就给默认值 1
b = b || 1;
return a + b;
}
// 传一个参数
console.log(add(10));


//现在可以这么写：直接给参数写上默认值，没传就会自动使用默认值
function add2(a , b = 1) {
return a + b;
}
// 传一个参数
console.log(add2(10));
</code></pre>
<h4 id="不定参数">不定参数<a class="anchor-link" href="#不定参数" title="Permanent link">&para;</a></h4>
<p>不定参数用来表示不确定参数个数，形如，...变量名， 由...加上一个具名参数标识符组成。 具名参数只能放在参数列表的最后，并且有且只有一个不定参数</p>
<pre><code>function fun(...values) {
console.log(values.length)
}
fun(1, 2)      //2
fun(1, 2, 3, 4)  //4
</code></pre>
<h4 id="箭头函数">箭头函数<a class="anchor-link" href="#箭头函数" title="Permanent link">&para;</a></h4>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot; /&gt;
    &lt;title&gt;Title&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;script&gt;
        // 1.参数问题:
        // 1.1.放入两个参数
        var sum = (num1, num2) =&gt; num1 + num2;
      // 等同于
      var sum = function(num1, num2) {
        return num1 + num2;
      };

        // 1.2.放入一个参数
        var f = v =&gt; v;

      // 等同于
      var f = function (v) {
        return v;
      };

        //1.3 空参数
        var f = () =&gt; 5;
      // 等同于
      var f = function () { return 5 };

      //1.4 函数体中多条语句，使用return语句返回并使用大括号将函数体包围起来
        var sum = (num1, num2) =&gt; {
        num1+=1;
        return num1 + num2; }

        //1.5 函数结构体也可以不返回
        //一 单行不返回使用void关键字标识
      let fn = () =&gt; void doesNotReturn();
      // 二 多行语句不使用return
      var sum = (num1, num2) =&gt; {
      num1+=1;
      num1 + num2; }

      //1.6 如果箭头函数直接返回一个对象，由于大括号被解释为代码块，必须在对象外面加上括号，否则会报错。

      // 报错
      let getTempItem = id =&gt; { id: id, name: &quot;Temp&quot; };

      // 不报错
      let getTempItem = id =&gt; ({ id: id, name: &quot;Temp&quot; });

        // 2.函数中
        // 2.1.函数代码块中有多行代码时
        const test = () =&gt; {
          // 1.打印Hello World
          console.log('Hello World');

          // 2.打印Hello Vuejs
          console.log('Hello Vuejs');
        }

        // 2.2.函数代码块中只有一行代码
        // const mul = (num1, num2) =&gt; {
        //   return num1 + num2
        // }
        const mul = (num1, num2) =&gt; num1 * num2
        console.log(mul(20, 30));

        // const demo = () =&gt; {
        //   console.log('Hello Demo');
        // }
        const demo = () =&gt; console.log('Hello Demo')
        console.log(demo());
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="7对象优化">7.对象优化<a class="anchor-link" href="#7对象优化" title="Permanent link">&para;</a></h3>
<h4 id="新增的api">新增的API<a class="anchor-link" href="#新增的api" title="Permanent link">&para;</a></h4>
<p>ES6 给 Object 拓展了许多新的方法，如：</p>
<ul>
<li><code>keys(obj)</code>：获取对象的所有 key 形成的数组</li>
<li><code>values(obj)</code>：获取对象的所有 value 形成的数组</li>
<li><code>entries(obj)</code>：获取对象的所有 key 和 value 形成的二维数组。格式：<code>[[k1,v1], [k2,v2],...]</code></li>
<li><code>assign(dest, ...src)</code>：将多个 src 对象的值 拷贝到 dest 中。  (第一层为深拷贝，第二层为浅 拷贝)</li>
</ul>
<pre><code>const person = {
name: &quot;jack&quot;,
age: 21,
language: [ 'java ', 'js ', 'css ']
}

console.log(Object.keys(person));//[&quot;name&quot;, &quot;age&quot;, &quot;language&quot;]
console.log(Object.values(person));//[&quot;jack&quot;, 21, Array(3)]
console.log(Object.entries(person));//[Array(2), Array(2), Array(2)]

const target = { a: 1 };
const source1 = { b: 2 };
const source2 = { c: 3 };
//Object.assign 方法的第一个参数是目标对象，后面的参数都是源对象。
Object.assign(target, source1, source2);
console.log(target)//{a: 1, b: 2, c: 3}
</code></pre>
<h4 id="声明对象简写">声明对象简写<a class="anchor-link" href="#声明对象简写" title="Permanent link">&para;</a></h4>
<pre><code>const age = 23
const name = &quot;张三&quot;

// 传统
const person1 = { age: age, name: name }
console.log(person1)

// ES6：属性名和属性值变量名一样，可以省略
const person2 = { age, name }
console.log(person2) //{age: 23, name: &quot;张三&quot;}
</code></pre>
<h4 id="对象的函数属性简写">对象的函数属性简写<a class="anchor-link" href="#对象的函数属性简写" title="Permanent link">&para;</a></h4>
<pre><code>let person = {
  name: &quot;jack&quot;,
  // 以前：
  eat: function (food) {
    console.log(this.name + &quot;在吃&quot; + food);
  },
  // 箭头函数版：这里拿不到this
  eat2: food =&gt; console.log(person.name + &quot;在吃&quot; + food),
  // 简写版：
  eat3(food) {
        console.log(this.name + &quot;在吃&quot; + food);
  }
}
person.eat(&quot;apple&quot;);
</code></pre>
<h4 id="对象拓展运算符">对象拓展运算符<a class="anchor-link" href="#对象拓展运算符" title="Permanent link">&para;</a></h4>
<p>拓展运算符 ( ... ) 用于取出参数对象所有可遍历属性然后拷贝到当前对象。</p>
<pre><code>// 1、拷贝对象 (深拷贝)
let person1 = { name: &quot;Amy&quot;, age: 15 }
let someone = { ...person1 }
console.log(someone)  //{name: &quot;Amy&quot;, age: 15}

// 2、合并对象
let age = { age: 15 }
let name = { name: &quot;Amy&quot; }
let person2 = { ...age, ...name } //如果两个对象的字段名重复，后面对象字段值会覆盖前面对象的字段值
console.log(person2)  //{age: 15, name: &quot;Amy&quot;}
</code></pre>
<h3 id="8map">8.map<a class="anchor-link" href="#8map" title="Permanent link">&para;</a></h3>
<p><code>map()</code>：接收一个函数，将原数组中的所有元素用这个函数处理后放入新数组返回。</p>
<pre><code>let arr = [ '1 ', '20', '-5 ', '3 '];
console.log(arr)

arr = arr.map(s =&gt; parseInt(s));
console.log(arr)
</code></pre>
<h3 id="9reduce">9.reduce<a class="anchor-link" href="#9reduce" title="Permanent link">&para;</a></h3>
<p>语法：<code>arr.reduce(callback,[initialValue])</code></p>
<p>reduce 为数组中的每一个元素依次执行回调函数，不包括数组中被删除或从未被赋值的元素，接受四个参数：初始值 (或者上一次回调函数的返回值) ，当前元素值，当前索引，调 用 reduce 的数组。</p>
<p>callback  (执行数组中每个值的函数，包含四个参数)</p>
<p>1 、previousValue  (上一次调用回调返回的值，或者是提供的初始值 (initialValue) )</p>
<p>2 、currentValue  (数组中当前被处理的元素)</p>
<p>3 、index  (当前元素在数组中的索引)</p>
<p>4 、array  (调用 reduce 的数组)</p>
<p>initialValue  (作为第一次调用 callback 的第一个参数。)</p>
<pre><code class="language-html">const arr = [1,20,-5,3];
//没有初始值：
console.log(arr.reduce((a,b)=&gt;a+b));//19
console.log(arr.reduce((a,b)=&gt;a*b));//-300
//指定初始值：
console.log(arr.reduce((a,b)=&gt;a+b,1));//20
console.log(arr.reduce((a,b)=&gt;a*b,0));//-0
</code></pre>
<h3 id="10this-使用">10.this 使用<a class="anchor-link" href="#10this-使用" title="Permanent link">&para;</a></h3>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot; /&gt;
    &lt;title&gt;Title&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;script&gt;
      // 什么时候使用箭头
      // setTimeout(function () {
      //   console.log(this);
      // }, 1000)
      //
      // setTimeout(() =&gt; {
      //   console.log(this);
      // }, 1000)

      // 问题: 箭头函数中的this是如何查找的了?
      // 答案: 向外层作用域中, 一层层查找this, 直到有this的定义.
      // const obj = {
      //   aaa() {
      //     setTimeout(function () {
      //       console.log(this); // window
      //     })
      //
      //     setTimeout(() =&gt; {
      //       console.log(this); // obj对象
      //     })
      //   }
      // }
      //
      // obj.aaa()

      const obj = {
        aaa() {
          setTimeout(function () {
            setTimeout(function () {
              console.log(this) // window
            })

            setTimeout(() =&gt; {
              console.log(this) // window
            })
          })

          setTimeout(() =&gt; {
            setTimeout(function () {
              console.log(this) // window
            })

            setTimeout(() =&gt; {
              console.log(this) // obj
            })
          })
        },
      }

      obj.aaa()
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
                </div>

                <!-- Comments Section (Giscus) -->
                <section class="comments-section">
                    <h3><i class="fas fa-comments"></i> 评论</h3>
                    <script src="https://giscus.app/client.js"
                        data-repo="Geeks-Z/Geeks-Z.github.io"
                        data-repo-id=""
                        data-category="Announcements"
                        data-category-id=""
                        data-mapping="pathname"
                        data-strict="0"
                        data-reactions-enabled="1"
                        data-emit-metadata="0"
                        data-input-position="bottom"
                        data-theme="preferred_color_scheme"
                        data-lang="zh-CN"
                        crossorigin="anonymous"
                        async>
                    </script>
                </section>
            </article>

            <footer class="post-footer">
                <p>© 2025 Hongwei Zhao. Built with ❤️</p>
            </footer>
        </main>
    </div>

    <!-- Theme Toggle Button -->
    <button class="theme-toggle" id="themeToggle" aria-label="切换主题">
        <i class="fas fa-moon"></i>
    </button>

    <script>
        // Theme Toggle
        const themeToggle = document.getElementById('themeToggle');
        const html = document.documentElement;
        const icon = themeToggle.querySelector('i');
        const hljsDark = document.getElementById('hljs-theme-dark');
        const hljsLight = document.getElementById('hljs-theme-light');
        
        // Check saved theme or system preference
        const savedTheme = localStorage.getItem('theme');
        const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
        
        if (savedTheme === 'dark' || (!savedTheme && prefersDark)) {
            html.setAttribute('data-theme', 'dark');
            icon.className = 'fas fa-sun';
            hljsDark.disabled = false;
            hljsLight.disabled = true;
        }
        
        themeToggle.addEventListener('click', () => {
            const isDark = html.getAttribute('data-theme') === 'dark';
            if (isDark) {
                html.removeAttribute('data-theme');
                icon.className = 'fas fa-moon';
                localStorage.setItem('theme', 'light');
                hljsDark.disabled = true;
                hljsLight.disabled = false;
            } else {
                html.setAttribute('data-theme', 'dark');
                icon.className = 'fas fa-sun';
                localStorage.setItem('theme', 'dark');
                hljsDark.disabled = false;
                hljsLight.disabled = true;
            }
            
            // Update Giscus theme
            const giscusFrame = document.querySelector('iframe.giscus-frame');
            if (giscusFrame) {
                giscusFrame.contentWindow.postMessage({
                    giscus: {
                        setConfig: {
                            theme: isDark ? 'light' : 'dark'
                        }
                    }
                }, 'https://giscus.app');
            }
        });
        
        // Highlight.js
        document.addEventListener('DOMContentLoaded', () => {
            hljs.highlightAll();
        });
        
        // KaTeX auto-render
        document.addEventListener('DOMContentLoaded', () => {
            if (typeof renderMathInElement !== 'undefined') {
                renderMathInElement(document.body, {
                    delimiters: [
                        {left: '$$', right: '$$', display: true},
                        {left: '$', right: '$', display: false},
                        {left: '\\[', right: '\\]', display: true},
                        {left: '\\(', right: '\\)', display: false}
                    ],
                    throwOnError: false
                });
            }
        });
        
        // TOC active state
        const tocLinks = document.querySelectorAll('.toc-container a');
        const headings = document.querySelectorAll('.post-content h2, .post-content h3, .post-content h4');
        
        function updateTocActive() {
            let current = '';
            headings.forEach(heading => {
                const rect = heading.getBoundingClientRect();
                if (rect.top <= 100) {
                    current = heading.getAttribute('id');
                }
            });
            
            tocLinks.forEach(link => {
                link.classList.remove('active');
                if (link.getAttribute('href') === '#' + current) {
                    link.classList.add('active');
                }
            });
        }
        
        window.addEventListener('scroll', updateTocActive);
        updateTocActive();
    </script>
</body>
</html>
