<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Untitled</title>
    <meta name="description" content="Untitled - Hongwei Zhao's Blog">
    <meta name="author" content="Hongwei Zhao">
    
    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Noto+Sans+SC:wght@300;400;500;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    
    <!-- Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <!-- Code Highlighting -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css" id="hljs-theme-dark">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css" id="hljs-theme-light" disabled>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    
    <!-- KaTeX for Math -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>
    
    <style>
        :root {
            /* Light Theme */
            --primary-color: #2980b9;
            --primary-hover: #1a5276;
            --link-color: #c0392b;
            --text-color: #333;
            --text-light: #666;
            --text-muted: #999;
            --bg-color: #fff;
            --bg-secondary: #f8f9fa;
            --bg-code: #f5f5f5;
            --border-color: #e5e7eb;
            --shadow: 0 1px 3px rgba(0,0,0,0.1);
            --shadow-lg: 0 4px 15px rgba(0,0,0,0.1);
        }

        [data-theme="dark"] {
            --primary-color: #5dade2;
            --primary-hover: #85c1e9;
            --link-color: #e74c3c;
            --text-color: #e5e7eb;
            --text-light: #9ca3af;
            --text-muted: #6b7280;
            --bg-color: #1a1a2e;
            --bg-secondary: #16213e;
            --bg-code: #0f0f23;
            --border-color: #374151;
            --shadow: 0 1px 3px rgba(0,0,0,0.3);
            --shadow-lg: 0 4px 15px rgba(0,0,0,0.4);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            scroll-behavior: smooth;
        }

        body {
            font-family: 'Inter', 'Noto Sans SC', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            font-size: 16px;
            line-height: 1.8;
            color: var(--text-color);
            background: var(--bg-color);
            transition: background-color 0.3s, color 0.3s;
        }

        a {
            color: var(--primary-color);
            text-decoration: none;
            transition: color 0.2s;
        }

        a:hover {
            color: var(--primary-hover);
            text-decoration: underline;
        }

        /* Layout */
        .page-wrapper {
            display: flex;
            max-width: 1400px;
            margin: 0 auto;
            padding: 2rem;
            gap: 3rem;
        }

        /* Sidebar TOC */
        .toc-sidebar {
            width: 260px;
            flex-shrink: 0;
            position: sticky;
            top: 2rem;
            height: fit-content;
            max-height: calc(100vh - 4rem);
            overflow-y: auto;
        }

        .toc-container {
            background: var(--bg-secondary);
            border-radius: 12px;
            padding: 1.5rem;
            border: 1px solid var(--border-color);
        }

        .toc-container h3 {
            font-size: 0.85rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-muted);
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .toc-container ul {
            list-style: none;
        }

        .toc-container li {
            margin-bottom: 0.5rem;
        }

        .toc-container a {
            font-size: 0.9rem;
            color: var(--text-light);
            display: block;
            padding: 0.25rem 0;
            border-left: 2px solid transparent;
            padding-left: 0.75rem;
            transition: all 0.2s;
        }

        .toc-container a:hover,
        .toc-container a.active {
            color: var(--primary-color);
            border-left-color: var(--primary-color);
            text-decoration: none;
        }

        .toc-container ul ul {
            margin-left: 1rem;
        }

        /* Main Content */
        .main-content {
            flex: 1;
            min-width: 0;
            max-width: 800px;
        }

        /* Header */
        .post-header {
            margin-bottom: 2rem;
            padding-bottom: 1.5rem;
            border-bottom: 1px solid var(--border-color);
        }

        .back-link {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.9rem;
            color: var(--text-light);
            margin-bottom: 1.5rem;
        }

        .back-link:hover {
            color: var(--primary-color);
            text-decoration: none;
        }

        .post-header h1 {
            font-size: 2.25rem;
            font-weight: 700;
            line-height: 1.3;
            margin-bottom: 1rem;
            color: var(--text-color);
        }

        .post-meta {
            display: flex;
            flex-wrap: wrap;
            gap: 1.5rem;
            font-size: 0.9rem;
            color: var(--text-light);
        }

        .post-meta span {
            display: flex;
            align-items: center;
            gap: 0.4rem;
        }

        .post-meta i {
            color: var(--text-muted);
        }

        .tags {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-top: 1rem;
        }

        .tag {
            display: inline-block;
            font-size: 0.8rem;
            background: var(--bg-secondary);
            color: var(--text-light);
            padding: 0.25rem 0.75rem;
            border-radius: 20px;
            border: 1px solid var(--border-color);
            transition: all 0.2s;
        }

        .tag:hover {
            background: var(--primary-color);
            color: white;
            border-color: var(--primary-color);
        }

        /* Article Content */
        .post-content {
            font-size: 1rem;
            line-height: 1.9;
        }

        .post-content h1,
        .post-content h2,
        .post-content h3,
        .post-content h4,
        .post-content h5,
        .post-content h6 {
            margin-top: 2rem;
            margin-bottom: 1rem;
            font-weight: 600;
            line-height: 1.4;
            color: var(--text-color);
        }

        .post-content h1 { font-size: 1.875rem; }
        .post-content h2 { 
            font-size: 1.5rem; 
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--border-color);
        }
        .post-content h3 { font-size: 1.25rem; }
        .post-content h4 { font-size: 1.125rem; }

        .post-content p {
            margin-bottom: 1.25rem;
        }

        .post-content ul,
        .post-content ol {
            margin: 1.25rem 0;
            padding-left: 1.5rem;
        }

        .post-content li {
            margin-bottom: 0.5rem;
        }

        .post-content blockquote {
            margin: 1.5rem 0;
            padding: 1rem 1.5rem;
            background: var(--bg-secondary);
            border-left: 4px solid var(--primary-color);
            border-radius: 0 8px 8px 0;
            color: var(--text-light);
            font-style: italic;
        }

        .post-content blockquote p:last-child {
            margin-bottom: 0;
        }

        /* Code */
        .post-content code {
            font-family: 'JetBrains Mono', 'Fira Code', Consolas, monospace;
            font-size: 0.9em;
            background: var(--bg-code);
            padding: 0.2em 0.4em;
            border-radius: 4px;
            color: var(--link-color);
        }

        .post-content pre {
            margin: 1.5rem 0;
            padding: 1.25rem;
            background: var(--bg-code);
            border-radius: 10px;
            overflow-x: auto;
            border: 1px solid var(--border-color);
        }

        .post-content pre code {
            background: none;
            padding: 0;
            color: inherit;
            font-size: 0.875rem;
            line-height: 1.6;
        }

        /* Images */
        .post-content img {
            max-width: 100%;
            height: auto;
            border-radius: 10px;
            margin: 1.5rem 0;
            box-shadow: var(--shadow-lg);
        }

        /* Tables */
        .post-content table {
            width: 100%;
            margin: 1.5rem 0;
            border-collapse: collapse;
            font-size: 0.95rem;
        }

        .post-content th,
        .post-content td {
            padding: 0.75rem 1rem;
            border: 1px solid var(--border-color);
            text-align: left;
        }

        .post-content th {
            background: var(--bg-secondary);
            font-weight: 600;
        }

        .post-content tr:nth-child(even) {
            background: var(--bg-secondary);
        }

        /* Math */
        .math-display {
            margin: 1.5rem 0;
            overflow-x: auto;
            padding: 1rem;
            background: var(--bg-secondary);
            border-radius: 8px;
        }

        /* Anchor links */
        .anchor-link {
            opacity: 0;
            margin-left: 0.5rem;
            color: var(--text-muted);
            font-weight: 400;
            transition: opacity 0.2s;
        }

        .post-content h2:hover .anchor-link,
        .post-content h3:hover .anchor-link,
        .post-content h4:hover .anchor-link {
            opacity: 1;
        }

        /* Theme Toggle */
        .theme-toggle {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: var(--primary-color);
            color: white;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.25rem;
            box-shadow: var(--shadow-lg);
            transition: transform 0.2s, background 0.2s;
            z-index: 1000;
        }

        .theme-toggle:hover {
            transform: scale(1.1);
            background: var(--primary-hover);
        }

        /* Comments Section */
        .comments-section {
            margin-top: 3rem;
            padding-top: 2rem;
            border-top: 1px solid var(--border-color);
        }

        .comments-section h3 {
            font-size: 1.25rem;
            margin-bottom: 1.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        /* Footer */
        .post-footer {
            margin-top: 3rem;
            padding-top: 1.5rem;
            border-top: 1px solid var(--border-color);
            text-align: center;
            font-size: 0.9rem;
            color: var(--text-muted);
        }

        /* Responsive */
        @media (max-width: 1024px) {
            .toc-sidebar {
                display: none;
            }
            
            .page-wrapper {
                padding: 1.5rem;
            }
        }

        @media (max-width: 768px) {
            .post-header h1 {
                font-size: 1.75rem;
            }
            
            .post-meta {
                flex-direction: column;
                gap: 0.5rem;
            }
            
            .theme-toggle {
                bottom: 1rem;
                right: 1rem;
                width: 44px;
                height: 44px;
            }
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-secondary);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--text-muted);
        }
    </style>
</head>
<body>
    <div class="page-wrapper">
        <!-- TOC Sidebar -->
        <aside class="toc-sidebar">
            <div class="toc-container">
                <h3><i class="fas fa-list"></i> 目录</h3>
                <div class="toc">
<ul>
<li><a href="#svd回顾">SVD回顾</a></li>
<li><a href="#monarch矩阵">Monarch矩阵</a><ul>
<li><a href="#置换矩阵">置换矩阵</a></li>
<li><a href="#分块对角">分块对角</a></li>
<li><a href="#效率简析">效率简析</a></li>
</ul>
</li>
<li><a href="#monarch分解">Monarch分解</a><ul>
<li><a href="#高维数组">高维数组</a></li>
<li><a href="#新恒等式">新恒等式</a></li>
<li><a href="#参考实现">参考实现</a></li>
</ul>
</li>
<li><a href="#monarch推广">Monarch推广</a><ul>
<li><a href="#非平方阶">非平方阶</a></li>
<li><a href="#只要形式">只要形式</a></li>
</ul>
</li>
<li><a href="#应用例子">应用例子</a></li>
<li><a href="#蝶之帝王">蝶之帝王</a></li>
<li><a href="#文章小结">文章小结</a></li>
</ul>
</div>

            </div>
        </aside>

        <!-- Main Content -->
        <main class="main-content">
            <article>
                <header class="post-header">
                    <a href="../../../index.html" class="back-link">
                        <i class="fas fa-arrow-left"></i> 返回博客列表
                    </a>
                    <h1>Untitled</h1>
                    <div class="post-meta">
                        <span><i class="fas fa-calendar-alt"></i> 2026-01-28</span>
                        <span><i class="fas fa-folder"></i> 数学笔记/04.矩阵</span>
                        <span><i class="fas fa-user"></i> Hongwei Zhao</span>
                    </div>
                    <div class="tags">
                        
                    </div>
                </header>

                <div class="post-content">
                    <blockquote>
<p>文章来源：<a href="https://zhuanlan.zhihu.com/p/714259385">Monarch矩阵-计算高效的稀疏型矩阵分解</a> <br><br />
最佳排版请看原博客：<a href="https://kexue.fm/archives/10249">Monarch矩阵：计算高效的稀疏型矩阵分解 - 科学空间|Scientific Spaces</a></p>
</blockquote>
<p>在矩阵压缩这个问题上，我们通常有两个策略可以选择，分别是<strong>低秩化</strong>和<strong>稀疏化</strong>。低秩化通过寻找矩阵的低秩近似来减少矩阵尺寸，而稀疏化则是通过减少矩阵中的非零元素来降低矩阵的复杂性。如果说SVD是奔着矩阵的低秩近似去的，那么相应地寻找矩阵稀疏近似的算法又是什么呢？</p>
<p>接下来我们要学习的是论文<a href="https://arxiv.org/abs/2204.00595">《Monarch: Expressive Structured Matrices for Efficient and Accurate Training》</a>，它为上述问题给出了一个答案——“Monarch矩阵”，这是一簇能够分解为若干置换矩阵与稀疏矩阵乘积的矩阵，同时具备计算高效且表达能力强的特点，论文还讨论了如何求一般矩阵的Monarch近似，以及利用Monarch矩阵参数化LLM来提高LLM速度等内容。</p>
<p>值得指出的是，该论文的作者也正是著名的Flash Attention的作者Tri Dao，其工作几乎都在致力于改进LLM的性能，这篇Monarch也是<a href="https://tridao.me/">个人主页</a>上特意展示的几篇论文之一，单从这一点看就非常值得学习一番。</p>
<h2 id="svd回顾">SVD回顾<a class="anchor-link" href="#svd回顾" title="Permanent link">&para;</a></h2>
<p>首先我们来简单回顾一下SVD（奇异值分解）。对于矩阵<span class="math-inline">n\times m</span> 小的矩阵<span class="math-inline">A</span>，SVD将它分解为</p>
<p><div class="math-display">A = U\Sigma V \</div></p>
<p>其中<span class="math-inline">U,V</span> 别是形状为<span class="math-inline">n\times n</span>、<span class="math-inline">m\times m</span> 正交矩阵，<span class="math-inline">\Sigma</span> 是<span class="math-inline">n\times m</span> 对角矩阵，对角线元素非负且从大到小排列。当我们只保留<span class="math-inline">\Sigma</span> 前<span class="math-inline">r</span> 对角线元素时，就得到了<span class="math-inline">A</span> 一个秩不超过<span class="math-inline">r</span> 近似分解：</p>
<p><div class="math-display">A \approx U_{[:,:r]}\Sigma_{[:r,:r]} V_{[:r,:]} \</div></p>
<p>这里下标就按照Python的切片来执行，所以<span class="math-inline">U_{[:,:r]}</span> 形状为<span class="math-inline">n\times r</span>、 <span class="math-inline">\Sigma_{[:r,:r]}</span> 形状为<span class="math-inline">r\times r</span> 及<span class="math-inline">V_{[:r,:]}</span> 形状为<span class="math-inline">r\times m</span>，这意味着<span class="math-inline">U_{[:,:r]}\Sigma_{[:r,:r]} V_{[:r,:]}</span> 秩至多为<span class="math-inline">r</span>。</p>
<p>特别地，由SVD得到的如上低秩近似，正好是如下优化问题的精确解：</p>
<p><div class="math-display">U_{[:,:r]}\Sigma_{[:r,:r]} V_{[:r,:]} = \mathop{\text{argmin}}_{rank(B)\leq r} \Vert A - B\Vert_F^2 \</div></p>
<p>其中<span class="math-inline">\Vert\cdot\Vert_F^2</span> 矩阵的<a href="https://en.wikipedia.org/wiki/Matrix_norm#Frobenius_norm">Frobenius范数</a>的平方，即矩阵每个元素的平方和。也就是说，在Frobenius范数下，矩阵<span class="math-inline">A</span> 最优<span class="math-inline">r</span> 近似就是<span class="math-inline">U_{[:,:r]}\Sigma_{[:r,:r]} V_{[:r,:]}</span>，该结论被称为“<a href="https://en.wikipedia.org/wiki/Low-rank_approximation">Eckart-Young-Mirsky定理</a>”。也正是因为这个结论，我们在文章开头才说“SVD是奔着矩阵的低秩近似去的”。</p>
<p>SVD可以展开讨论的内容非常多，甚至写成一本书也不为过，这里就不再继续深入了。最后说一下，SVD的计算复杂度是<span class="math-inline">\mathcal{O}(nm\cdot\min(m,n))</span>，因为我们至少要对<span class="math-inline">A^{\top} A</span> <span class="math-inline">A A^{\top}</span> 一做特征值分解。如果我们确定做SVD是为了寻找<span class="math-inline">r</span> 近似，那么复杂度可以有所降低，这便是Truncated SVD。</p>
<h2 id="monarch矩阵">Monarch矩阵<a class="anchor-link" href="#monarch矩阵" title="Permanent link">&para;</a></h2>
<p>低秩分解应用非常广，但它未必总是符合我们的需求，比如可逆方阵的低秩近似必然不可逆，这意味着低秩近似不适合需要求逆的场景。此时另一个选择是稀疏近似，稀疏矩阵通常能够保证秩不退化。</p>
<p>注意稀疏和低秩并无必然联系，比如单位阵就是很稀疏的矩阵，但它可逆（满秩）。寻找矩阵的稀疏近似并不难，比如将绝对值最大的<span class="math-inline">k</span> 元素外的所有元素都置零就是一个很朴素的稀疏近似，但问题是它通常不实用，所以难在寻找实用的稀疏近似。所谓“实用”，指的是保留足够表达能力或近似程度的同时，实现一定程度的稀疏化，并且这种稀疏化具有适当的结构，有助于矩阵运算（比如乘法、求逆）的提速。</p>
<p>Monarch矩阵正是为此而生，假设<span class="math-inline">n=m^2</span> 一个平方数，那么Monarch矩阵是全体<span class="math-inline">n</span> 矩阵的一个子集，我们记为<span class="math-inline">\mathcal{M}^{(n)}</span>，它定义为如下形式的矩阵的集合：</p>
<p><div class="math-display">M = PLPR \</div></p>
<p>其中<span class="math-inline">P</span> <span class="math-inline">n\times n</span> 置换矩阵（正交矩阵），<span class="math-inline">L,R</span> 分块对角矩阵。下面我们来逐一介绍它们。</p>
<h3 id="置换矩阵">置换矩阵<a class="anchor-link" href="#置换矩阵" title="Permanent link">&para;</a></h3>
<p>置换矩阵<span class="math-inline">P</span> 现的效果是将向量<span class="math-inline">[x_1,x_2,\cdots,x_n]</span> 换成新的向量</p>
<p><div class="math-display">[x_1, x_{1+m}, \cdots , x_{1+(m−1)m}, x_2, x_{2+m}, \cdots , x_{2+(m−1)m}, \cdots , x_m, x_{2m}, \cdots , x_n] \</div></p>
<p>当然这样写大家可能依然觉得迷糊，然事实上用代码实现非常简单：</p>
<pre><code class="language-python">Px = x.reshape(m, m).transpose().reshape(n)
</code></pre>
<p>如下图所示：</p>
<div align=center><img src="https://markdownimg-hw.oss-cn-beijing.aliyuncs.com/20241106145524.png" style="zoom: 60%;" /></div>

<p>之前做CV的读者可能会觉得这个操作有点熟悉，它其实就是<a href="https://arxiv.org/abs/1707.01083">ShuffleNet</a>中的“Shuffle”操作，这样对向量先reshape然后transpose最后再reshape回来的组合运算，起到一种“伪Shuffle”的效果，它也可以视为<span class="math-inline">m</span> 制的“<a href="https://en.wikipedia.org/wiki/Bit-reversal_permutation">位反转排序</a>”。很明显，这样的操作做两次，所得向量将复原为原始向量，所以我们有<span class="math-inline">P^2=I</span>，所以<span class="math-inline">P^{-1}=P^{\top}=P</span>。</p>
<h3 id="分块对角">分块对角<a class="anchor-link" href="#分块对角" title="Permanent link">&para;</a></h3>
<p>说完<span class="math-inline">P</span>，我们再来说<span class="math-inline">L,R</span>，它们也是<span class="math-inline">n\times n</span> 小的矩阵，不过它们还是<span class="math-inline">m\times m</span> 分块对角矩阵，每个块是<span class="math-inline">m\times m</span> 小，如下图所示： </p>
<div align=center><img src="https://markdownimg-hw.oss-cn-beijing.aliyuncs.com/20241107124914.png" style="zoom: 60%;" /></div>

<p>当<span class="math-inline">n</span> 够大时，<span class="math-inline">L,R</span> 零的数量占主导，所以<span class="math-inline">L,R</span> 是稀疏矩阵，即Monarch矩阵是具备稀疏特性的矩阵分解形式。由于<span class="math-inline">P</span> 固定的，所以<span class="math-inline">PLPR</span> 的可变元素就来源于<span class="math-inline">L,R</span> 非零元素，因此，矩阵<span class="math-inline">M</span> 然是<span class="math-inline">n\times n</span> 矩阵，但它实际自由参数不超过<span class="math-inline">2m^3=2n^{1.5}</span> 。从<span class="math-inline">1.5</span> 个数字我们就可以窥见Monarch矩阵的意图了，它希望将原本需要平方复杂度的运算，通过Monarch矩阵近似降低到1.5次方复杂度。</p>
<h3 id="效率简析">效率简析<a class="anchor-link" href="#效率简析" title="Permanent link">&para;</a></h3>
<p>那么Monarch矩阵能否达到这个目的呢？换句话说Monarch矩阵能否达到前面说的“实用”标准？表达能力方面我们后面再谈，我们先看计算高效方面。</p>
<p>比如“矩阵-向量”乘法，标准的复杂度是<span class="math-inline">\mathcal{O}(n^2)</span>，但如果是Monarch矩阵的话我们有<span class="math-inline">Mx = P(L(P(Rx)))</span>，由于乘<span class="math-inline">P</span> 是简单的reshape和transpose，所以它几乎不占计算量，主要计算量来源于<span class="math-inline">L</span> <span class="math-inline">R</span> 一个向量相乘。由于<span class="math-inline">L,R</span> 分块对角矩阵的特点，我们可以将向量为<span class="math-inline">m</span> ，继而转化为<span class="math-inline">m</span> <span class="math-inline">m\times m</span> 矩阵与<span class="math-inline">m</span> 向量相乘，总复杂度是<span class="math-inline">2m\times\mathcal{O}(m^2)=\mathcal{O}(2n^{1.5})</span>，比<span class="math-inline">\mathcal{O}(n^2)</span> 低。</p>
<p>再比如求逆，我们考虑<span class="math-inline">M^{-1}x</span>，<span class="math-inline">n</span> 矩阵求逆的标准复杂度是<span class="math-inline">\mathcal{O}(n^3)</span>，但对于Monarch矩阵我们有<span class="math-inline">M^{-1} x =R^{-1}PL^{-1}P x</span>，主要计算量来源于<span class="math-inline">L^{-1}</span>、<span class="math-inline">R^{-1}</span> 及对应的“矩阵-向量”乘法，由于<span class="math-inline">L,R</span> 是分块对角阵，我们只需要分别对每个对角线上的块矩阵求逆，也就是共有<span class="math-inline">2m</span> <span class="math-inline">m\times m</span> 矩阵求逆，复杂度是<span class="math-inline">2m\times\mathcal{O}(m^3)=\mathcal{O}(2n^2)</span>，同样低于标准的<span class="math-inline">\mathcal{O}(n^3)</span>。要单独写出<span class="math-inline">M^{-1}</span> 是可以的，但需要利用到后面的恒等式(8)。</p>
<p>所以结论就是，由于<span class="math-inline">P</span> 法几乎不占计算量以及<span class="math-inline">L,R</span> 分块对角矩阵的特点，<span class="math-inline">n</span> Monarch矩阵相关运算，基本上可以转化为<span class="math-inline">2m</span> <span class="math-inline">m\times m</span> 阵的独立运算，从而降低总的计算复杂度。所以至少计算高效这一点，Monarch矩阵是没有问题的，并且由于<span class="math-inline">L,R</span> 非零元素本身已经方形结构，实现上也很方便，可以充分利用GPU进行计算，不会带来不必要的浪费。</p>
<h2 id="monarch分解">Monarch分解<a class="anchor-link" href="#monarch分解" title="Permanent link">&para;</a></h2>
<p>确认Monarch矩阵的有效性后，接下来应用方面的一个关键问题就是：给定任意的<span class="math-inline">n=m^2</span> 矩阵<span class="math-inline">A</span>，如何求它的Monarch近似呢？跟SVD类似，我们定义如下优化问题</p>
<p><div class="math-display">\mathop{\text{argmin}}_{M\in\mathcal{M}^{(n)}} \Vert A - M\Vert_F^2 \</div></p>
<p>非常幸运的是，这个问题有一个复杂度不超过<span class="math-inline">\mathcal{O}(n^{2.5})</span> 求解算法，这比SVD的<span class="math-inline">\mathcal{O}(n^3)</span> 要更高效一些。</p>
<h3 id="高维数组">高维数组<a class="anchor-link" href="#高维数组" title="Permanent link">&para;</a></h3>
<p>理解这个算法的关键一步，是将Monarch相关的矩阵、向量都转化为更高维数组的形式。具体来说，Monarch矩阵<span class="math-inline">M</span> 来是一个二维数组，每个元素记为<span class="math-inline">M_{i,j}</span>，表示该元素位于第<span class="math-inline">i</span> 、第<span class="math-inline">j</span> ，现在我们要按照分块矩阵的特点，将它等价地表示为四维数组，每个元素记为<span class="math-inline">M_{i,j,k,l}</span>，表示第<span class="math-inline">i</span> 行、第<span class="math-inline">j</span> 行、第<span class="math-inline">k</span> 列、第<span class="math-inline">l</span> 列的元素，如下图所示： </p>
<div align=center><img src="https://markdownimg-hw.oss-cn-beijing.aliyuncs.com/20241106145556.png" style="zoom: 60%;" /></div>

<p>虽然说起来挺费劲的，但事实上代码就一行</p>
<pre><code class="language-python">M.reshape(m, m, m, m)
</code></pre>
<p>同理，<span class="math-inline">n</span> （列）向量<span class="math-inline">x</span> 被转为<span class="math-inline">m\times m</span> 二维数据，代码也是一行<code>x.reshape(m, m)</code>。剩下的<span class="math-inline">L,R</span> 然是表示为<span class="math-inline">m\times m\times m</span> 三维数组，如<span class="math-inline">L_{i,j,k}</span> 示第<span class="math-inline">i</span> 、第<span class="math-inline">j</span> 行、第<span class="math-inline">k</span> 列的元素，这本来也是<span class="math-inline">L,R</span> 高效的储存方式，但为了统一处理，我们也可以用<a href="https://en.wikipedia.org/wiki/Kronecker_delta">Kronecker delta符号</a>将它们升到四维，比如<span class="math-inline">L_{i,j,k,l} = \delta_{i,k}L_{i,j,l}</span>、<span class="math-inline">R_{i,j,k,l} = \delta_{i,k}R_{i,j,l}</span>。</p>
<h3 id="新恒等式">新恒等式<a class="anchor-link" href="#新恒等式" title="Permanent link">&para;</a></h3>
<p>接下来，我们将推出<span class="math-inline">M</span> <span class="math-inline">L,R</span> 一个新关系式。首先，可以证明在二维表示中，矩阵<span class="math-inline">P</span> 向量<span class="math-inline">x</span> 乘法变得更简单了，结果就是<span class="math-inline">x</span> 转置，即<span class="math-inline">(Px)<em>{i,j} = x</em>{j,i}</span>，所以我们有<span class="math-inline">(PR)<em>{i,j,k,l} = R</em>{j,i,k,l} = \delta_{j,k}R_{j,i,l}</span>；接着，两个矩阵的乘法，在四维表示之下求和指标也有两个，所以</p>
<p><div class="math-display">(L P R)<em>{\alpha,\beta,k,l} = \sum</em>{i,j} L_{\alpha,\beta,i,j}(PR)<em>{i,j,k,l} = \sum</em>{i,j} \delta_{\alpha, i} L_{\alpha,\beta,j}\delta_{j,k}R_{j,i,l} = L_{\alpha,\beta,k}R_{k,\alpha,l} \</div></p>
<p>最后就是<span class="math-inline">(P L P R)<em>{\alpha,\beta,k,l}=L</em>{\beta,\alpha,k}R_{k,\beta,l}</span>，将<span class="math-inline">\alpha,\beta</span> 回<span class="math-inline">i,j</span> 到<span class="math-inline">(P L P R)<em>{i,j,k,l}=L</em>{j,i,k}R_{k,j,l}</span>，又因为<span class="math-inline">M=PLPR</span>，所以有</p>
<p><div class="math-display">M_{i,j,k,l} = L_{j,i,k}R_{k,j,l} \tag{8}</div></p>
<p>从这个等式可以看出，当我们固定一对<span class="math-inline">(j,k)</span> ，左边是一个子矩阵，右边是两个向量的外积，这意味着如果我们要给矩阵<span class="math-inline">A</span> Monarch近似，只需要将<span class="math-inline">A</span> 照同样方式转为四维数组，并固定一对<span class="math-inline">(j,k)</span>，那么问题就变成了找对应子矩阵的“秩-1近似”！换句话说，有了这个恒等式之后，给矩阵<span class="math-inline">A</span> Monarch近似可以转化为给<span class="math-inline">m^2</span> 子矩阵找“秩-1近似”，这可以用SVD完成，每个复杂度不超过<span class="math-inline">\mathcal{O}(m^3)</span>，所以总复杂度不超过<span class="math-inline">m^2\times\mathcal{O}(m^3) = \mathcal{O}(n^{2.5})</span>。</p>
<h3 id="参考实现">参考实现<a class="anchor-link" href="#参考实现" title="Permanent link">&para;</a></h3>
<p>笔者简单用Numpy写的参考实现如下：</p>
<pre><code class="language-python">import numpy as np

def monarch_factorize(A):
    M = A.reshape(m, m, m, m).transpose(1, 2, 0, 3)
    U, S, V = np.linalg.svd(M)
    L = (U[:, :, :, 0] * S[:, :, :1]**0.5).transpose(0, 2, 1)
    R = (V[:, :, 0] * S[..., :1]**0.5).transpose(1, 0, 2)
    return L, R

def convert_3D_to_2D(LR):
    X = np.zeros((m, m, m, m))
    for i in range(m):
        X[i, i] += LR[i]
    return X.transpose(0, 2, 1, 3).reshape(n, n)

m = 8
n = m**2
A = np.where(np.random.rand(n, n) &gt; 0.8, np.random.randn(n, n), 0)

L, R = monarch_factorize(A)
L = convert_3D_to_2D(L)
R = convert_3D_to_2D(R)
PL = L.reshape(m, m, n).transpose(1, 0, 2).reshape(n, n)
PR = R.reshape(m, m, n).transpose(1, 0, 2).reshape(n, n)

U, S, V = np.linalg.svd(A)

print('Monarch error:', np.square(A - PL.dot(PR)).mean())
print('Low-Rank error:', np.square(A - (U[:, :m] * S[:m]).dot(V[:m])).mean())
</code></pre>
<p>笔者简单对比了一下SVD求出的秩-<span class="math-inline">m</span> 似（此时低秩近似跟Monarch近似参数量相当），发现如果是完全稠密的矩阵，那么秩-<span class="math-inline">m</span> 似的平方误差往往优于Monarch近似（但不多），这也是意料之中，因为从Monarch近似的算法就可以看出它本质上也是个定制版的SVD。不过，如果待逼近矩阵是稀疏矩阵时，那么Monarch近似的误差往往更优，并且越稀疏越优。</p>
<h2 id="monarch推广">Monarch推广<a class="anchor-link" href="#monarch推广" title="Permanent link">&para;</a></h2>
<p>到目前为止，我们约定所讨论的矩阵都是<span class="math-inline">n</span> 方阵，并且<span class="math-inline">n=m^2</span> 一个平方数。如果说方阵这个条件尚能接受，那么<span class="math-inline">n=m^2</span> 个条件终究还是太多限制了，因此有必要至少将Monarch矩阵的概念推广到非平方数<span class="math-inline">n</span>。</p>
<h3 id="非平方阶">非平方阶<a class="anchor-link" href="#非平方阶" title="Permanent link">&para;</a></h3>
<p>为此，我们先引入一些记号。假设<span class="math-inline">b</span> <span class="math-inline">n</span> 一个因数，<span class="math-inline">\mathcal{BD}^{(b,n)}</span> 示全体<span class="math-inline">\frac{n}{b}\times \frac{n}{b}</span> 小的分块对角矩阵，其中每个块大小是<span class="math-inline">b\times b</span> 子矩阵，很明显它是前面<span class="math-inline">L,R</span> 一般化，按照这个记号我们可以写出<span class="math-inline">L,R\in\mathcal{BD}^{(\sqrt{n},n)}</span>。此外，我们还要一般化置换矩阵<span class="math-inline">P</span>，前面我们说了<span class="math-inline">P</span> 实现是<code>Px = x.reshape(m, m).transpose().reshape(n)</code>，现在我们一般化为<code>Px = x.reshape(n // b, b).transpose().reshape(n)</code>，记为<span class="math-inline">P_{(\frac{n}{b},b)}</span>。</p>
<p>有了这些记号，我们可以定义一般的Monarch矩阵（原论文的附录）：</p>
<p><div class="math-display">\mathcal{M}^{(b,n)} = \Bigg{M = P_{(b,\frac{n}{b})} L P_{(\frac{n}{b},b)} R\,\Bigg|\, L\in\mathcal{BD}^{(\frac{n}{b},n)}, R\in\mathcal{BD}^{(b,n)} \Bigg} \</div></p>
<p>示意图如下：</p>
<div align=center><img src="https://markdownimg-hw.oss-cn-beijing.aliyuncs.com/20241106145613.png" style="zoom: 60%;" /></div>

<p>前面所定义的Monarch矩阵，在这里可以简单记为<span class="math-inline">\mathcal{M}^{(n)} = \mathcal{M}^{(\sqrt{n},n)}</span>。不难计算，<span class="math-inline">L</span> 非零元素至多有<span class="math-inline">\frac{n^2}{b}</span> ，<span class="math-inline">R</span> 非零元素至多有<span class="math-inline">nb</span> ，加起来是<span class="math-inline">\frac{n^2}{b} + nb</span>，它在<span class="math-inline">b=\sqrt{n}</span> 得最小值，所以<span class="math-inline">b=\sqrt{n}</span> 于最稀疏的一个例子。</p>
<h3 id="只要形式">只要形式<a class="anchor-link" href="#只要形式" title="Permanent link">&para;</a></h3>
<p>可能读者会困惑，为什么要区分<span class="math-inline">L\in\mathcal{BD}^{(\frac{n}{b},n)}, R\in\mathcal{BD}^{(b,n)}</span>，统一用一个不行吗？事实上，这样设计是为了保持高维表示下式(8)依然成立，从而可以推出类似的分解算法（请读者补充一下），以及可以从理论上保证它的表达能力。</p>
<p>如果我们不在意这些理论细节，只希望构造一个带有稀疏特性的矩阵参数化方式，那么就可以更灵活地对Monarch矩阵进行推广了，比如</p>
<p><div class="math-display">M = \left(\prod_{i=1}^k P_i B_i\right)P_0 \</div></p>
<p>其中<span class="math-inline">B_1,B_2,\cdots,B_k \in \mathcal{BD}^{(b,n)}</span>，<span class="math-inline">P_0,P_1,\cdots,P_k</span> 是置换矩阵，最后多乘一个<span class="math-inline">P_0</span> 出于对称性的考虑，并不是必须的，如果你觉得有必要，还可以给每个<span class="math-inline">B_i</span> 择不同的<span class="math-inline">b</span>，即<span class="math-inline">B_i\in \mathcal{BD}^{(b_i,n)}</span>。</p>
<p>甚至，你可以结合低秩分解的形式，推广到非方阵的块矩阵，如下图： </p>
<div align=center><img src="https://markdownimg-hw.oss-cn-beijing.aliyuncs.com/20241106145626.png" style="zoom: 60%;" /></div>

<p>基于这个类比，我们还可以进一步将Monarch矩阵的概念推广到非方阵。总之，如果只是需要一种类似Monarch矩阵的稀疏化结构矩阵，而不在意理论细节，那么结果就仅限于我们的想象力了。</p>
<h2 id="应用例子">应用例子<a class="anchor-link" href="#应用例子" title="Permanent link">&para;</a></h2>
<p>目前看来，Monarch矩阵最大的特点就是对矩阵乘法比较友好，所以最大的用途无非就是替换全连接层的参数矩阵，从而提高全连接层的效率，这也是原论文实验部分的主要内容。</p>
<p>我们又可以将其分为“事前处理”和“事后处理”两类：“事前处理”就是在训练模型之前就将全连接层的参数矩阵改为Monarch矩阵，这样训练和推理都能提速，训练出来的模型也最贴合Monarch矩阵；“事后处理”就是已经有一个训练好的模型，此时我们可以用Monarch分解给全连接层的参数矩阵找一个Monarch近似，然后替换掉原来的矩阵，必要时再简单微调一下，以此提高原始模型的微调效率或推理效率。</p>
<p>除了替换全连接层外，<a href="https://arxiv.org/abs/2310.12109">《Monarch Mixer: A Simple Sub-Quadratic GEMM-Based Architecture》</a>还讨论了更极端的做法——作为一个Token-Mixer模块直接替换Attention层。不过就笔者看来，Monarch-Mixer并不算太优雅，因为它跟<a href="https://arxiv.org/abs/2105.01601">MLP-Mixer</a>一样，都是用一个可学的矩阵替换掉Attention矩阵，只不过在Monarch-Mixer这里换成了Monarch矩阵。这样的模式学到的是静态的注意力，个人对其普适性是存疑的。</p>
<p>最后，对如今的LLM来说，Monarch矩阵还可以用来构建参数高效的微调方案（Parameter-Efficient Fine-Tuning，PEFT）。我们知道，LoRA是从低秩分解出发设计的，既然低秩和稀疏是两条平行的路线，那么作为稀疏的代表作Monarch矩阵不应该也可以用来构建一种PEFT方案？Google了一下，还真有这样做的，论文名是<a href="https://openreview.net/forum?id=AzTz27n6O2">《MoRe Fine-Tuning with 10x Fewer Parameters》</a>，还很新鲜，是ICML2024的Workshop之一。</p>
<h2 id="蝶之帝王">蝶之帝王<a class="anchor-link" href="#蝶之帝王" title="Permanent link">&para;</a></h2>
<p>最后再简单说说Monarch矩阵的拟合能力。“Monarch”意为“帝王”、“君主”，取自“Monarch Butterfly（帝王蝴蝶）”一词，之所以这样命名，是因为它对标的是更早的“<a href="https://arxiv.org/abs/1903.05895">utterfly矩阵</a>”。</p>
<p>什么是Butterfly矩阵？这个说起来还真有点费劲。Butterfly矩阵是一系列（<span class="math-inline">\log_2 n</span> ）Butterfly因子矩阵的乘积，而Butterfly因子矩阵则是一个分块对角矩阵矩阵，其对角线上的矩阵叫做Butterfly因子（没有“矩阵”两个字），Butterfly因子则是一个<span class="math-inline">2\times 2</span> 的分块矩阵，它的每个块矩阵则是一个对角阵（套娃结束）。如下图所示： </p>
<div align=center><img src="https://markdownimg-hw.oss-cn-beijing.aliyuncs.com/20241106145639.png" style="zoom: 60%;" /></div>

<p>准确的Butterfly矩阵定义大家自行看论文就好，这里不详细展开。Butterfly这个名字来源于作者觉得每个Butterfly因子的形状像Butterfly（蝴蝶），当然像不像大家见仁见智，反正作者觉得像。从字面上来看，“Monarch Butterfly”比“Butterfly”更高级（毕竟是“帝王”），这暗示着Monarch矩阵比Butterfly矩阵更强。确实如此，Monarch论文附录证明了，不管<span class="math-inline">b</span> 什么，<span class="math-inline">\mathcal{M}^{(b,n)}</span> 能覆盖所有的<span class="math-inline">n</span> Butterfly矩阵，并且<span class="math-inline">n &gt; 512</span> <span class="math-inline">\mathcal{M}^{(b,n)}</span> 格大于全体<span class="math-inline">n</span> Butterfly矩阵集合，换言之Butterfly矩阵能做到的Monarch矩阵也能做到，反之未必。</p>
<p>我们也可以从“矩阵-向量”乘法复杂度来直观感知Monarch矩阵表达能力。我们知道，一个<span class="math-inline">n\times n</span> 阵乘以<span class="math-inline">n</span> 向量的标准复杂度是<span class="math-inline">\mathcal{O}(n^2)</span>，但对于某些结构化矩阵可以更低，比如傅立叶变换可以做到<span class="math-inline">\mathcal{O}(n\log n)</span>，Butterfly矩阵也是<span class="math-inline">\mathcal{O}(n\log n)</span>，Monarch矩阵则是<span class="math-inline">\mathcal{O}(n^{1.5})</span>，所以Monarch矩阵“应该”是不弱于Butterfly矩阵的。当然，Butterfly矩阵也有它的好处，比如它的逆和行列式都比较好算，这对于Flow模型等需要求逆和行列式的场景更为方便。</p>
<h2 id="文章小结">文章小结<a class="anchor-link" href="#文章小结" title="Permanent link">&para;</a></h2>
<p>本文介绍了Monarch矩阵，这是Tri Dao前两年提出的一簇能够分解为转置矩阵与稀疏矩阵乘积的矩阵，具备计算高效的特点（众所周知，Tri Dao是高性能的代名词），可以用来为全连接层提速、构建参数高效的微调方式等。</p>
                </div>

                <!-- Comments Section (Giscus) -->
                <section class="comments-section">
                    <h3><i class="fas fa-comments"></i> 评论</h3>
                    <script src="https://giscus.app/client.js"
                        data-repo="Geeks-Z/Geeks-Z.github.io"
                        data-repo-id=""
                        data-category="Announcements"
                        data-category-id=""
                        data-mapping="pathname"
                        data-strict="0"
                        data-reactions-enabled="1"
                        data-emit-metadata="0"
                        data-input-position="bottom"
                        data-theme="preferred_color_scheme"
                        data-lang="zh-CN"
                        crossorigin="anonymous"
                        async>
                    </script>
                </section>
            </article>

            <footer class="post-footer">
                <p>© 2025 Hongwei Zhao. Built with ❤️</p>
            </footer>
        </main>
    </div>

    <!-- Theme Toggle Button -->
    <button class="theme-toggle" id="themeToggle" aria-label="切换主题">
        <i class="fas fa-moon"></i>
    </button>

    <script>
        // Theme Toggle
        const themeToggle = document.getElementById('themeToggle');
        const html = document.documentElement;
        const icon = themeToggle.querySelector('i');
        const hljsDark = document.getElementById('hljs-theme-dark');
        const hljsLight = document.getElementById('hljs-theme-light');
        
        // Check saved theme or system preference
        const savedTheme = localStorage.getItem('theme');
        const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
        
        if (savedTheme === 'dark' || (!savedTheme && prefersDark)) {
            html.setAttribute('data-theme', 'dark');
            icon.className = 'fas fa-sun';
            hljsDark.disabled = false;
            hljsLight.disabled = true;
        }
        
        themeToggle.addEventListener('click', () => {
            const isDark = html.getAttribute('data-theme') === 'dark';
            if (isDark) {
                html.removeAttribute('data-theme');
                icon.className = 'fas fa-moon';
                localStorage.setItem('theme', 'light');
                hljsDark.disabled = true;
                hljsLight.disabled = false;
            } else {
                html.setAttribute('data-theme', 'dark');
                icon.className = 'fas fa-sun';
                localStorage.setItem('theme', 'dark');
                hljsDark.disabled = false;
                hljsLight.disabled = true;
            }
            
            // Update Giscus theme
            const giscusFrame = document.querySelector('iframe.giscus-frame');
            if (giscusFrame) {
                giscusFrame.contentWindow.postMessage({
                    giscus: {
                        setConfig: {
                            theme: isDark ? 'light' : 'dark'
                        }
                    }
                }, 'https://giscus.app');
            }
        });
        
        // Highlight.js
        document.addEventListener('DOMContentLoaded', () => {
            hljs.highlightAll();
        });
        
        // KaTeX auto-render
        document.addEventListener('DOMContentLoaded', () => {
            if (typeof renderMathInElement !== 'undefined') {
                renderMathInElement(document.body, {
                    delimiters: [
                        {left: '$$', right: '$$', display: true},
                        {left: '$', right: '$', display: false},
                        {left: '\\[', right: '\\]', display: true},
                        {left: '\\(', right: '\\)', display: false}
                    ],
                    throwOnError: false
                });
            }
        });
        
        // TOC active state
        const tocLinks = document.querySelectorAll('.toc-container a');
        const headings = document.querySelectorAll('.post-content h2, .post-content h3, .post-content h4');
        
        function updateTocActive() {
            let current = '';
            headings.forEach(heading => {
                const rect = heading.getBoundingClientRect();
                if (rect.top <= 100) {
                    current = heading.getAttribute('id');
                }
            });
            
            tocLinks.forEach(link => {
                link.classList.remove('active');
                if (link.getAttribute('href') === '#' + current) {
                    link.classList.add('active');
                }
            });
        }
        
        window.addEventListener('scroll', updateTocActive);
        updateTocActive();
    </script>
</body>
</html>
