<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>------------------------------------</title>
    <meta name="description" content="------------------------------------ - Hongwei Zhao's Blog">
    <meta name="author" content="Hongwei Zhao">
    
    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Noto+Sans+SC:wght@300;400;500;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    
    <!-- Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <!-- Code Highlighting -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css" id="hljs-theme-dark">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css" id="hljs-theme-light" disabled>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    
    <!-- KaTeX for Math -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>
    
    <style>
        :root {
            /* Light Theme - 明亮清新配色 */
            --primary-color: #4A90D9;
            --primary-hover: #3678C2;
            --link-color: #E86B5F;
            --text-color: #2D2D2D;
            --text-light: #5A5A5A;
            --text-muted: #8A8A8A;
            --bg-color: #FFFFFF;
            --bg-secondary: #F5F7FA;
            --bg-code: #F8F9FC;
            --border-color: #E8ECF0;
            --shadow: 0 2px 8px rgba(0,0,0,0.06);
            --shadow-lg: 0 8px 24px rgba(0,0,0,0.08);
        }

        [data-theme="dark"] {
            --primary-color: #5dade2;
            --primary-hover: #85c1e9;
            --link-color: #e74c3c;
            --text-color: #e5e7eb;
            --text-light: #9ca3af;
            --text-muted: #6b7280;
            --bg-color: #1a1a2e;
            --bg-secondary: #16213e;
            --bg-code: #0f0f23;
            --border-color: #374151;
            --shadow: 0 1px 3px rgba(0,0,0,0.3);
            --shadow-lg: 0 4px 15px rgba(0,0,0,0.4);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            scroll-behavior: smooth;
        }

        body {
            font-family: 'Inter', 'Noto Sans SC', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            font-size: 16px;
            line-height: 1.8;
            color: var(--text-color);
            background: var(--bg-color);
            transition: background-color 0.3s, color 0.3s;
        }

        a {
            color: var(--primary-color);
            text-decoration: none;
            transition: color 0.2s;
        }

        a:hover {
            color: var(--primary-hover);
            text-decoration: underline;
        }

        /* Layout */
        .page-wrapper {
            display: flex;
            max-width: 1400px;
            margin: 0 auto;
            padding: 2rem;
            gap: 3rem;
        }

        /* Sidebar TOC */
        .toc-sidebar {
            width: 260px;
            flex-shrink: 0;
            position: sticky;
            top: 2rem;
            height: fit-content;
            max-height: calc(100vh - 4rem);
            overflow-y: auto;
        }

        .toc-container {
            background: var(--bg-secondary);
            border-radius: 12px;
            padding: 1.5rem;
            border: 1px solid var(--border-color);
        }

        .toc-container h3 {
            font-size: 0.85rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-muted);
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .toc-container ul {
            list-style: none;
        }

        .toc-container li {
            margin-bottom: 0.5rem;
        }

        .toc-container a {
            font-size: 0.9rem;
            color: var(--text-light);
            display: block;
            padding: 0.25rem 0;
            border-left: 2px solid transparent;
            padding-left: 0.75rem;
            transition: all 0.2s;
        }

        .toc-container a:hover,
        .toc-container a.active {
            color: var(--primary-color);
            border-left-color: var(--primary-color);
            text-decoration: none;
        }

        .toc-container ul ul {
            margin-left: 1rem;
        }

        /* Main Content */
        .main-content {
            flex: 1;
            min-width: 0;
            max-width: 800px;
        }

        /* Header */
        .post-header {
            margin-bottom: 2rem;
            padding-bottom: 1.5rem;
            border-bottom: 1px solid var(--border-color);
        }

        .back-link {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.9rem;
            color: var(--text-light);
            margin-bottom: 1.5rem;
        }

        .back-link:hover {
            color: var(--primary-color);
            text-decoration: none;
        }

        .post-header h1 {
            font-size: 2.25rem;
            font-weight: 700;
            line-height: 1.3;
            margin-bottom: 1rem;
            color: var(--text-color);
        }

        .post-meta {
            display: flex;
            flex-wrap: wrap;
            gap: 1.5rem;
            font-size: 0.9rem;
            color: var(--text-light);
        }

        .post-meta span {
            display: flex;
            align-items: center;
            gap: 0.4rem;
        }

        .post-meta i {
            color: var(--text-muted);
        }

        .tags {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-top: 1rem;
        }

        .tag {
            display: inline-block;
            font-size: 0.8rem;
            background: var(--bg-secondary);
            color: var(--text-light);
            padding: 0.25rem 0.75rem;
            border-radius: 20px;
            border: 1px solid var(--border-color);
            transition: all 0.2s;
        }

        .tag:hover {
            background: var(--primary-color);
            color: white;
            border-color: var(--primary-color);
        }

        /* Article Content */
        .post-content {
            font-size: 1rem;
            line-height: 1.9;
        }

        .post-content h1,
        .post-content h2,
        .post-content h3,
        .post-content h4,
        .post-content h5,
        .post-content h6 {
            margin-top: 2rem;
            margin-bottom: 1rem;
            font-weight: 600;
            line-height: 1.4;
            color: var(--text-color);
        }

        .post-content h1 { font-size: 1.875rem; }
        .post-content h2 { 
            font-size: 1.5rem; 
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--border-color);
        }
        .post-content h3 { font-size: 1.25rem; }
        .post-content h4 { font-size: 1.125rem; }

        .post-content p {
            margin-bottom: 1.25rem;
        }

        .post-content ul,
        .post-content ol {
            margin: 1.25rem 0;
            padding-left: 1.5rem;
        }

        .post-content li {
            margin-bottom: 0.5rem;
        }

        .post-content blockquote {
            margin: 1.5rem 0;
            padding: 1rem 1.5rem;
            background: var(--bg-secondary);
            border-left: 4px solid var(--primary-color);
            border-radius: 0 8px 8px 0;
            color: var(--text-light);
            font-style: italic;
        }

        .post-content blockquote p:last-child {
            margin-bottom: 0;
        }

        /* Code */
        .post-content code {
            font-family: 'JetBrains Mono', 'Fira Code', Consolas, monospace;
            font-size: 0.9em;
            background: var(--bg-code);
            padding: 0.2em 0.4em;
            border-radius: 4px;
            color: var(--link-color);
        }

        .post-content pre {
            margin: 1.5rem 0;
            padding: 1.25rem;
            background: var(--bg-code);
            border-radius: 10px;
            overflow-x: auto;
            border: 1px solid var(--border-color);
        }

        .post-content pre code {
            background: none;
            padding: 0;
            color: inherit;
            font-size: 0.875rem;
            line-height: 1.6;
        }

        /* Images */
        .post-content img {
            max-width: 100%;
            height: auto;
            border-radius: 10px;
            margin: 1.5rem 0;
            box-shadow: var(--shadow-lg);
        }

        /* Tables */
        .post-content table {
            width: 100%;
            margin: 1.5rem 0;
            border-collapse: collapse;
            font-size: 0.95rem;
        }

        .post-content th,
        .post-content td {
            padding: 0.75rem 1rem;
            border: 1px solid var(--border-color);
            text-align: left;
        }

        .post-content th {
            background: var(--bg-secondary);
            font-weight: 600;
        }

        .post-content tr:nth-child(even) {
            background: var(--bg-secondary);
        }

        /* Math */
        .math-display {
            margin: 1.5rem 0;
            overflow-x: auto;
            padding: 1rem;
            background: var(--bg-secondary);
            border-radius: 8px;
        }

        /* Anchor links */
        .anchor-link {
            opacity: 0;
            margin-left: 0.5rem;
            color: var(--text-muted);
            font-weight: 400;
            transition: opacity 0.2s;
        }

        .post-content h2:hover .anchor-link,
        .post-content h3:hover .anchor-link,
        .post-content h4:hover .anchor-link {
            opacity: 1;
        }

        /* Theme Toggle */
        .theme-toggle {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: var(--primary-color);
            color: white;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.25rem;
            box-shadow: var(--shadow-lg);
            transition: transform 0.2s, background 0.2s;
            z-index: 1000;
        }

        .theme-toggle:hover {
            transform: scale(1.1);
            background: var(--primary-hover);
        }

        /* Comments Section */
        .comments-section {
            margin-top: 3rem;
            padding-top: 2rem;
            border-top: 1px solid var(--border-color);
        }

        .comments-section h3 {
            font-size: 1.25rem;
            margin-bottom: 1.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        /* Footer */
        .post-footer {
            margin-top: 3rem;
            padding-top: 1.5rem;
            border-top: 1px solid var(--border-color);
            text-align: center;
            font-size: 0.9rem;
            color: var(--text-muted);
        }

        /* Responsive */
        @media (max-width: 1024px) {
            .toc-sidebar {
                display: none;
            }
            
            .page-wrapper {
                padding: 1.5rem;
            }
        }

        @media (max-width: 768px) {
            .post-header h1 {
                font-size: 1.75rem;
            }
            
            .post-meta {
                flex-direction: column;
                gap: 0.5rem;
            }
            
            .theme-toggle {
                bottom: 1rem;
                right: 1rem;
                width: 44px;
                height: 44px;
            }
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-secondary);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--text-muted);
        }
    </style>
</head>
<body>
    <div class="page-wrapper">
        <!-- TOC Sidebar -->
        <aside class="toc-sidebar">
            <div class="toc-container">
                <h3><i class="fas fa-list"></i> 目录</h3>
                <div class="toc">
<ul>
<li><a href="#一全参数微调">一、全参数微调</a></li>
<li><a href="#二adapter-tuning与prefix-tuning">二、Adapter Tuning与Prefix Tuning</a><ul>
<li><a href="#21-adapter-tuning">2.1 Adapter Tuning</a></li>
<li><a href="#22-prefix-tuning">2.2 Prefix Tuning</a></li>
</ul>
</li>
<li><a href="#三什么是lora">三、什么是LoRA</a><ul>
<li><a href="#31-lora整体架构">3.1 LoRA整体架构</a></li>
<li><a href="#32-lora的训练和推理过程">3.2 LoRA的训练和推理过程</a></li>
</ul>
</li>
<li><a href="#四lora低秩适配的原理">四、LoRA低秩适配的原理</a><ul>
<li><a href="#41-什么是秩">4.1 什么是秩</a></li>
<li><a href="#42-svd分解">4.2 SVD分解</a></li>
<li><a href="#43-lora低秩适配">4.3 LoRA低秩适配</a></li>
<li><a href="#44-超参-alpha">4.4 超参 $\alpha$</a></li>
</ul>
</li>
<li><a href="#五lora实验验证低秩矩阵的有效性">五、LoRA实验：验证低秩矩阵的有效性</a><ul>
<li><a href="#51-整体效果">5.1 整体效果</a></li>
<li><a href="#52-低秩矩阵信息量验证">5.2 低秩矩阵信息量验证</a></li>
</ul>
</li>
<li><a href="#六references">六、References</a></li>
</ul>
</div>

            </div>
        </aside>

        <!-- Main Content -->
        <main class="main-content">
            <article>
                <header class="post-header">
                    <a href="../../../../index.html" class="back-link">
                        <i class="fas fa-arrow-left"></i> 返回博客列表
                    </a>
                    <h1>------------------------------------</h1>
                    <div class="post-meta">
                        <span><i class="fas fa-calendar-alt"></i> 2026-02-04</span>
                        <span><i class="fas fa-folder"></i> AINotes/14.PEFT/01.LoRA</span>
                        <span><i class="fas fa-user"></i> Hongwei Zhao</span>
                    </div>
                    <div class="tags">
                        
                    </div>
                </header>

                <div class="post-content">
                    <h2 id="一全参数微调">一、全参数微调<a class="anchor-link" href="#一全参数微调" title="Permanent link">&para;</a></h2>
<div align=center><img src="https://markdownimg-hw.oss-cn-beijing.aliyuncs.com/20251025153210.png" style="zoom: 60%;" /></div>

<p>我们知道，微调的含义，就是把已经训练好的模型（pretrained model）拿来，给它吃特定的下游任务数据，使得模型在预训练权重上继续训练，直至满足下游任务性能标准。预训练模型就像一个<strong>特征提取器</strong>，能够基于先前训练数据中学到的经验，为我们提取有效的特征，大大提升下游任务的训练效果和收敛速度。  </p>
<p><strong>全量微调</strong>指的是，在下游任务的训练中，对预训练模型的每一个参数都做更新。例如图中，给出了Transformer的Q/K/V矩阵的全量微调示例，对每个矩阵来说，在微调时，其<code>d*d</code>个参数，都必须参与更新。  </p>
<p>全量微调的显著缺点是，<strong>训练代价昂贵</strong>。同时，由于模型在预训练阶段已经吃了足够多的数据，收获了足够的经验，因此我<strong>只要想办法给模型增加一个额外知识模块，让这个小模块去适配我的下游任务，模型主体保持不变（freeze）即可</strong>。  </p>
<p>那这样的知识小模块，具体要怎么添加呢？</p>
<h2 id="二adapter-tuning与prefix-tuning">二、Adapter Tuning与Prefix Tuning<a class="anchor-link" href="#二adapter-tuning与prefix-tuning" title="Permanent link">&para;</a></h2>
<p>我们来看在LoRA出现前，两种主流的局部微调办法：<strong>Adapter Tuning与Prefix Tuning</strong>。这也是LoRA的原始论文中，重点比对的两种微调方式。</p>
<h3 id="21-adapter-tuning">2.1 Adapter Tuning<a class="anchor-link" href="#21-adapter-tuning" title="Permanent link">&para;</a></h3>
<div align=center><img src="https://markdownimg-hw.oss-cn-beijing.aliyuncs.com/20251025154337.png" style="zoom: 80%;" /></div>

<p>Adapter Tuning的方法有很多种，这里我们举出Houlsby et al. ,2019提出的方法，这也是LoRA论文中提及这项技术时所引用的第一篇文章。  </p>
<p>图例中的左边是一层Transformer Layer结构，其中的Adapter就是我们说的“额外知识模块”；右边是Adatper的具体结构<strong>。在微调时，除了Adapter的部分，其余的参数都是被冻住的（freeze）</strong>，这样我们就能有效降低训练的代价。Adapter的内部架构不是本文所述的重点，这里我们就不再介绍了。  </p>
<p>但这样的设计架构存在一个<strong>显著劣势</strong>：<strong>添加了Adapter后，模型整体的层数变深，会降低训练速度和推理速度</strong>，原因是：  </p>
<ul>
<li>需要耗费额外的运算量在Adapter上</li>
<li>当我们采用并行训练时（例如Transformer架构常用的张量模型并行），Adapter层会产生额外的通讯量，增加通讯时间</li>
</ul>
<h3 id="22-prefix-tuning">2.2 Prefix Tuning<a class="anchor-link" href="#22-prefix-tuning" title="Permanent link">&para;</a></h3>
<div align=center><img src="https://markdownimg-hw.oss-cn-beijing.aliyuncs.com/20251025154458.png" style="zoom: 80%;" /></div>

<p>Prefix Tuning的方法也有很多种，这里我们选取Li&amp;Liang,2021这一篇进行简述。在这篇中，作者通过对输入数据增加前缀（prefix）来做微调<strong>。当然，prefix也可以不止加在输入层，还可以加在Transformer Layer输出的中间层</strong>，感兴趣的朋友可以查找论文自行研究。  </p>
<p>如图所示，对于<strong>GPT这样的生成式模型</strong>，在输入序列的最前面加入prefix token，图例中加入2个prefix token，在实际应用中，prefix token的个数是个超参，可以根据模型实际微调效果进行调整。对于<strong>BART这样的Encoder-Decoder架构模型</strong>，则在x和y的前面同时添加prefix token<strong>。在后续微调中，我们只需要冻住模型其余部分，单独训练prefix token相关的参数即可，每个下游任务都可以单独训练一套prefix token</strong>。  </p>
<p><strong>那么prefix的含义是什么呢？</strong>prefix的作用是引导模型提取x相关的信息，进而更好地生成y。例如，我们要做一个<strong>summarization</strong>的任务，那么经过微调后，prefix就能领悟到当前要做的是个“总结形式”的任务，然后引导模型去x中提炼关键信息；如果我们要做一个<strong>情感分类</strong>的任务，prefix就能引导模型去提炼出x中和情感相关的语义信息，以此类推。这样的解释可能不那么严谨，但大家可以大致体会一下prefix的作用。  </p>
<p>Prefix Tuning虽然看起来方便，但也存在以下两个显著劣势；  </p>
<ul>
<li>较难训练，且模型的效果并不严格随prefix参数量的增加而上升，这点在原始论文中也有指出</li>
<li>会使得输入层有效信息长度减少。为了节省计算量和显存，我们一般会固定输入数据长度。增加了prefix之后，留给原始文字数据的空间就少了，因此可能会降低原始文字中prompt的表达能力。</li>
</ul>
<h2 id="三什么是lora">三、什么是LoRA<a class="anchor-link" href="#三什么是lora" title="Permanent link">&para;</a></h2>
<p>总结一下，<strong>全参数微调太贵，Adapter Tuning存在训练和推理延迟，Prefix Tuning难训且会减少原始训练数据中的有效文字长度</strong>，那是否有一种微调办法，能改善这些不足呢？  </p>
<p>在这样动机的驱动下，作者提出了<strong>LoRA（Low-Rank Adaptation，低秩适配器）这样一种微调方法</strong>。我们先抛开对“低秩”、“适配器”这样抽象词语的解释，我们先来看LoRA长什么样，要怎么用。在下一节中，我们再来详细解释“低秩”作用的原理。</p>
<h3 id="31-lora整体架构">3.1 LoRA整体架构<a class="anchor-link" href="#31-lora整体架构" title="Permanent link">&para;</a></h3>
<div align=center><img src="https://markdownimg-hw.oss-cn-beijing.aliyuncs.com/20251025154656.png" style="zoom: 80%;" /></div>

<p><strong>图中左侧表示“全参数finetune”的场景</strong>。我们将参数分成了两个部分：  </p>
<ul>
<li><span class="math-inline">W \in \mathbb R^{d*d}</span> ：预训练权重</li>
<li><span class="math-inline">\Delta W \in \mathbb R^{d*d}</span> ：finetune增量权重</li>
</ul>
<p>之所以这么拆分，是因为<strong>全参数finetune可以理解成“冻住的预训练权重” + “微调过程中产生的权重更新量”</strong>。<br />
设输入为 <span class="math-inline">x</span> ，输出为 <span class="math-inline">h</span> ，则有：<br />
<div class="math-display"><br />
h = Wx + \Delta W x<br />
</div><br />
<strong>图中右侧表示“LoRA finetune”的场景。在LoRA中，我们用矩阵A和B来近似表达</strong> <span class="math-inline">\Delta W</span> ：  </p>
<ul>
<li><span class="math-inline">A \in \mathbb R^{r<em>d}</span> ：低秩矩阵 <span class="math-inline">A</span> ，其中 <span class="math-inline">r</span> 被称为“</em><em>秩</em>*”，对 <span class="math-inline">A</span> 用高斯初始化。</li>
<li><span class="math-inline">B \in \mathbb R^{d*r}</span> ：低秩矩阵 <span class="math-inline">B</span> ，对B采用零初始化。</li>
</ul>
<p>经过这样一番拆分，<strong>我们将</strong> <span class="math-inline">\Delta W</span> <strong>改写成</strong> <span class="math-inline">\Delta W = BA</span> <strong>的形式，使得微调参数量从<code>d*d</code>降低至<code>2*r*d</code>，同时不改变输出数据的维度</strong>，即在LoRA下我们有:<br />
<div class="math-display"><br />
h = Wx + BAx<br />
</div><br />
另外，<strong>在原论文中提到过对于两个低秩矩阵，会用超参</strong> <span class="math-inline">\alpha</span> <strong>（一个常数）来做调整</strong>，但没有说明这个超参的作用位置。在读完LoRA的源码后，我发现<strong>这个超参是作为scaling rate直接和低秩矩阵相乘的</strong>，也就是最终的输出为：<br />
<div class="math-display"><br />
h = Wx + \frac{\alpha}{r}BAx<br />
</div></p>
<p>在实操中，一般取 <span class="math-inline">\alpha \ge r</span> ，例如在LoRA源码对GPT2微调，做NLG任务时，就取 <span class="math-inline">\alpha = 32, r=4</span> <strong>。我们会在后文详细介绍这个scaling rate的作用，以及“秩”的具体含义</strong>。  </p>
<p><strong>A和B的初始化方法</strong></p>
<p>需要注意的是，这里对 <span class="math-inline">A</span> 采用高斯初始化，对 <span class="math-inline">B</span> 采用零初始化的目的是，让训练刚开始时 <span class="math-inline">B</span> 的值为0，这样不会给模型带来额外的噪声。那么你可能想问，<strong>那我对</strong><span class="math-inline">A</span><strong>做零初始化，对</strong><span class="math-inline">B</span><strong>做高斯初始化行不行呢？反正看起来只要让</strong> <span class="math-inline">BA</span> <strong>初始化为0就行？</strong>  </p>
<p>针对这个问题，我在github issue上找到了LoRA一作的回答：  </p>
<div align=center><img src="https://markdownimg-hw.oss-cn-beijing.aliyuncs.com/20251025155830.png" style="zoom: 80%;" /></div>

<p>简单来说，当前作者还没有发现转换 <span class="math-inline">A,B</span> 初始化方式产生的显著区别，只要这两者中任意一者为0，另一者不为0即可。</p>
<h3 id="32-lora的训练和推理过程">3.2 LoRA的训练和推理过程<a class="anchor-link" href="#32-lora的训练和推理过程" title="Permanent link">&para;</a></h3>
<p>在3.1中，<strong>我们介绍了LoRA的整体架构：在原始预训练矩阵的旁路上，用低秩矩阵A和B来近似替代增量更新</strong> <span class="math-inline">\Delta W</span> 。你可以在你想要的模型层上做这样的操作，比如Transformer中的 <span class="math-inline">W_{q}, W_{k}, W_{v}, W_{o}</span> 、MLP层的权重、甚至是Embedding部分的权重。在LoRA原始论文中，只对Attention部分的参数做了低秩适配，但在实际操作中，我们可以灵活根据需要设置实验方案，找到最佳的适配方案（有钱万事通）。</p>
<p><strong>3.2.1 训练</strong></p>
<p>在<strong>训练过程</strong>中，我们固定住预训练权重 <span class="math-inline">W</span> ，只对低秩矩阵 <span class="math-inline">A</span> 和 <span class="math-inline">B</span> 进行训练<strong>。在保存权重时，我们只需保存低秩矩阵的部分即可</strong>。按照LoRA论文中的统计，这样的操作使得在微调GPT3 175B时，显存消耗从1.2TB降至350GB；当r=4时，最终保存的模型从350GB降至35MB，极大降低了训练的开销。  </p>
<p>关于训练部分，我们再来看一个有趣的问题：总体上来看，LoRA对显存的节约是显著的，但是在训练的每一时刻，LoRA都能做到节省显存吗？  </p>
<p>考虑backward时对 <span class="math-inline">B</span> 计算梯度，根据 <span class="math-inline">h = Wx + BAx = W_{sum}x</span> （为了敲公式方便，暂时忽略掉 <span class="math-inline">\alpha</span> 一项），我们有：</p>
<p><div class="math-display"><br />
\begin{aligned} \frac{\partial L}{\partial B} &amp;= \frac{\partial L}{\partial h}\frac{\partial h}{\partial W_{sum}}\frac{\partial W_{sum}}{\partial B}\ &amp;=\frac{\partial L}{\partial h}x^{T}\frac{\partial W_{sum}}{\partial B}  \end{aligned}<br />
</div></p>
<p>注意 <span class="math-inline">\frac{\partial L}{\partial h}x^{T}</span> 这一项，你会发现，它和预训练权重 <span class="math-inline">W</span> 的维度<code>d*d</code> 一模一样，也就是为了计算 <span class="math-inline">B</span> 的梯度，我们需要用到和全参数微调过程中一样大小的中间值结果。因此对LoRA来说，<strong>这一层的峰值显存，和全量微调基本是一致的</strong>（算上 <span class="math-inline">\frac{\partial W_{sum}}{\partial B}</span> 一项的话则高于全量微调）。  </p>
<p><strong>LoRA 显存占用少在哪里</strong></p>
<p>预训练权重<span class="math-inline">\mathbf{W}<em>{0}</span> 梯度存储开销，实际就是 LoRA 能大大减少了显存占用的关键。<br />
在 LoRA 训练时，<span class="math-inline">\mathbf{W}</em>{\mathbf{0}}</span> 仍然会参与前向传播和反向传播，但是不会计算其对应梯度 <span class="math-inline">\frac{\partial L}{\partial \mathbf{W}<em>{0}}</span> ，更不会更新其参数。因此，这一步不再需要计算和保存梯度 <span class="math-inline">\frac{\partial L}{\partial \mathbf{W}</em>{0}}</span> ，以及更新 <span class="math-inline">\mathbf{W}_{\mathbf{0}}</span> 。以 <span class="math-inline">d=4096, r=16</span> 为例，这部分减少的梯度显存占用粗略估计为: <span class="math-inline">d * d-2 * d * r=1-\frac{2 r}{d}</span> , 减少了 99.2187% 。</p>
<p><strong>相对于全局微调，这些高效微调技术为什么会使得训练的速度变快呢？</strong></p>
<ol>
<li>
<p>只更新了部分参数：比如 LoRA 原论文就选择只更新 Self Attention 的参数，实际使用时我们还可以选择只更新部分层的参数；</p>
</li>
<li>
<p>减少了通信时间：由于更新的参数量变少了，所以（尤其是多卡训练时）要传输的数据量也变少了，从而减少了传输时间；</p>
</li>
<li>
<p>采用了各种低精度加速技术，如 FP16、FP8 或者 INT8 量化等。</p>
</li>
</ol>
<p>所以总的来说，LoRA 在反向传播阶段计算复杂度还要多一些，只是需要梯度下降的参数少，所以节省显存，梯度下降的也快。</p>
<p>最后，关于<span class="math-inline">B</span> <span class="math-inline">A</span> 两个低秩矩阵的初始化问题，首先我们是需要<span class="math-inline">BA</span> 结果初始是 0，这样就能保证微调开始时新引入的低秩矩阵不会对最终结果造成影响，那么最直接的方式就是令其中一个低秩矩阵初始阶段为全零，另一个为非全零即可，两者不能都为全零，通过带上 LoRA 的梯度计算公式(2)如果和这两个低秩矩阵初始化都是全 0 那么两个矩阵的梯度都是 0，也就训不起来。</p>
<p><strong>3.2.2 推理</strong></p>
<p>在<strong>推理过程</strong>中，<strong>我们按照</strong> <span class="math-inline">W = W + \frac{\alpha}{r}BA</span> <strong>的方式，合并低秩矩阵和预训练权重，然后正常做forward推理。这样我们完全不会更改模型的架构，因此不会像Adapter Tuning一样产生推理上的延时</strong>。下图展示了论文中的实验效果，推理时长的单位是milliseconds，可以发现，LoRA的推理速度显著高于Adapter Tuning。  </p>
<div align=center><img src="https://markdownimg-hw.oss-cn-beijing.aliyuncs.com/20251026101818.png" style="zoom: 80%;" /></div>

<p>在<strong>切换不同下游任务</strong>时，我们可以灵活从 <span class="math-inline">W</span> 中移除低秩权重的部分。例如我们先做下游任务A，做完后通过 <span class="math-inline">W = W + \frac{\alpha}{r}BA</span> 合并权重，并单独保留低秩权重 <span class="math-inline">A,B</span> 。当我们切换到下游任务B时，我们可以通过从 <span class="math-inline">W</span> 中减去低秩权重部分，然后再开启新的LoRA微调。也就是说，<strong>每个下游任务，都可以有自己的一套低秩权重</strong>。  </p>
<p><strong>你可能想问，在每次微调结束后，我一定要把低秩权重合进<span class="math-inline">W</span>中吗？我可以将“预训练权重”和“低秩权重”分开存储吗</strong>？当然没问题啦，LoRA是很灵活的，你完全可以根据自身需要，改写代码，决定权重的保存方式，只要掌握一个核心原则：不管是合还是不合，有办法能区分出预训练和LoRA的部分即可。</p>
<h2 id="四lora低秩适配的原理">四、LoRA低秩适配的原理<a class="anchor-link" href="#四lora低秩适配的原理" title="Permanent link">&para;</a></h2>
<p>在前文中，我们曾反复提到“秩”的概念，并说明LoRA的秩即为超参 <span class="math-inline">r</span> ，同时，我们也不断强调 <span class="math-inline">BA</span> 是 <span class="math-inline">\Delta W</span> 的<strong>近似</strong>。在这一节中，<strong>我们将具象化地来看看“秩”，并说明为何是“近似”，在了解这些后，我们就能来解读超参</strong> <span class="math-inline">\alpha</span> <strong>的作用，并掌握一定的炼丹感觉了</strong>。</p>
<h3 id="41-什么是秩">4.1 什么是秩<a class="anchor-link" href="#41-什么是秩" title="Permanent link">&para;</a></h3>
<p>我们首先来看一个矩阵A：</p>
<pre><code class="language-python">A = [[1, 2, 3],
     [2, 4, 6],
     [3, 6, 9]]
</code></pre>
<p>该矩阵中，row2 = row1 * 2，row3 = row1*3，也就是说，矩阵中的每一行，都可以通过第一行线性表示。  </p>
<p>我们再来看一个矩阵B：</p>
<pre><code class="language-python">B = [[1, 2, 3],
     [7, 11, 5],
     [8, 13, 8]]
</code></pre>
<p>该矩阵中，任意一行，总可以用其他两行的线性组合来表示。  </p>
<p>我们最后再来看一个矩阵C：</p>
<pre><code class="language-python">C = [[1, 0, 0],
     [0, 1, 0],
     [0, 0, 1]]
</code></pre>
<p>该矩阵中，任意一行，都不能从其余行的线性组合中推导而来。  </p>
<p>调用<code>np.linalg.matrix_rank</code>函数，我们可以算出任意矩阵的秩，上面三个矩阵的秩分别为：</p>
<pre><code class="language-python">A = np.array(A)
B = np.array(B)
C = np.array(C)

print(&quot;Rank of A:&quot;, np.linalg.matrix_rank(A)) # 1
print(&quot;Rank of B:&quot;, np.linalg.matrix_rank(B)) # 2
print(&quot;Rank of C:&quot;, np.linalg.matrix_rank(C)) # 3
</code></pre>
<p>对矩阵A来说，由于只要掌握其中的任意一行，其余行都可以由这一行线性推导而来，因此A的秩是1。<br />
对矩阵B来说，由于只要掌握其中的任意两行，其余行都可以由这两行线性组合推导而来，因此B的秩是2。<br />
对矩阵C来说，由于必须完全掌握三行，才能得到完整的C，因此C的秩是3。  </p>
<p>看到这里，你是不是已经对秩有了感性的理解了？<strong>秩表示的是矩阵的信息量</strong>。如果矩阵中的某一维，总可以通过其余维度线性推导而来，那么对模型来说，这一维的信息是冗余的，是重复表达的。对A和B的情况，我们称为<strong>秩亏（rank deficient）</strong>，对C的情况，我们称为<strong>满秩（full rank）</strong>。更严谨的数学定义，大家可以参考《线性代数》（狗头）。  </p>
<p>有了对秩的这层认识，我们自然会想到，<strong>全参数微调中的增量权重</strong> <span class="math-inline">\Delta W</span> <strong>可能也存在冗余的信息，因此我们并不需要用完整的<code>d*d</code> 尺寸来表示它</strong>。那么，<strong>我们要如何找出</strong><span class="math-inline">\Delta W</span><strong>中真正有用的特征维度呢？SVD分解</strong>（奇异值分解），可以帮我们解决这个问题</p>
<h3 id="42-svd分解">4.2 SVD分解<a class="anchor-link" href="#42-svd分解" title="Permanent link">&para;</a></h3>
<div align=center><img src="https://markdownimg-hw.oss-cn-beijing.aliyuncs.com/20251026101856.png" style="zoom: 80%;" /></div>

<p>如图，矩阵 <span class="math-inline">M</span> 是我们需要做信息量检查的矩阵。假设在输入数据的特征空间中，<strong>存在一组正交的单位向量</strong> <span class="math-inline">\vec{v_1}, \vec{v_2}</span> ，经过 <span class="math-inline">M</span> 的变换后，它们变成另一组正交向量 <span class="math-inline">\sigma_1 \vec{u_1}, \sigma_2 \vec{u_2}</span> ，其中 <span class="math-inline">\vec{u_1}, \vec{u_2}</span> <strong>也是一组正交的单位向量</strong>， <span class="math-inline">\sigma_1, \sigma_2</span> 分别表示对应方向上的模。上面这一顿变幻，可以写成：<br />
<div class="math-display"><br />
M[\vec{v_1}, \vec{v_2}] = [\sigma_1 \vec{u_1}, \sigma_2 \vec{u_2}]<br />
</div><br />
稍加改写，就有：<br />
<div class="math-display"><br />
M = \begin{bmatrix}\vec{u_1}&amp;\vec{u_2}\end{bmatrix}\begin{bmatrix}\sigma_1&amp;0 \0&amp;\sigma_2\end{bmatrix}\begin{bmatrix}\vec{v_1}\\vec{v_2}\end{bmatrix}<br />
</div></p>
<p>不难发现， <span class="math-inline">\sigma_{1}, \sigma_{2}</span> <strong>中隐含了对“信息量”的提示</strong>。在本例中 <span class="math-inline">v</span> 经过 <span class="math-inline">M</span> 的转换投射到 <span class="math-inline">u</span> 上时， <span class="math-inline">M</span> 强调了在1方向上蕴含的信息。  </p>
<p>现在再宽泛一些，如果我们能找到这样的一组 <span class="math-inline">v</span> 和 <span class="math-inline">u</span> ，并令 <span class="math-inline">\sigma</span> 矩阵的值从大到小进行排列，那么我们不就能对 <span class="math-inline">M</span> 进行拆解，同时在拆解过程中，找出 <span class="math-inline">M</span> 所强调的那些特征方向了吗？也就是说： <br />
<div class="math-display"><br />
M = U\Sigma V^{T}<br />
</div><br />
<strong>当我们找到这样的</strong> <span class="math-inline">U, \Sigma, V</span> <strong>矩阵后，我们再从这三者中取出对应的<code>top r</code> 行（或列），不就相当于关注到了</strong> <span class="math-inline">M</span> <strong>最强调的那几维特征，进而就能用更低维的矩阵，来近似表达</strong> <span class="math-inline">M</span> <strong>了？</strong>按这种思维拆解 <span class="math-inline">M</span> 的方法，我们称为<strong>SVD分解（奇异值分解）</strong>。</p>
<p>我们再通过一个代码例子，更直观地感受一下这种近似，大家注意看下注释（例子改编自：<a href="https://medium.com/@Shrishml/lora-low-rank-adaptation-from-the-first-principle-7e1adec71541">LoRA: Low-Rank Adaptation from the first principle</a></p>
<pre><code class="language-python">import torch
import numpy as np
torch.manual_seed(0)

# ------------------------------------
# n：输入数据维度
# m：输出数据维度
# ------------------------------------
n = 10
m = 10

# ------------------------------------
# 随机初始化权重W
# 之所以这样初始化，是为了让W不要满秩，
# 这样才有低秩分解的意义
# ------------------------------------
nr = 10
mr = 2
W = torch.randn(nr,mr)@torch.randn(mr,nr)

# ------------------------------------
# 随机初始化输入数据x
# ------------------------------------
x = torch.randn(n)

# ------------------------------------
# 计算Wx
# ------------------------------------
y = W@x
print(&quot;原始权重W计算出的y值为:\n&quot;, y)

# ------------------------------------
# 计算W的秩
# ------------------------------------
r= np.linalg.matrix_rank(W)
print(&quot;W的秩为: &quot;, r)

# ------------------------------------
# 对W做SVD分解
# ------------------------------------
U, S, V = torch.svd(W)

# ------------------------------------
# 根据SVD分解结果，
# 计算低秩矩阵A和B
# ------------------------------------
U_r = U[:, :r]
S_r = torch.diag(S[:r])
V_r = V[:,:r].t()

B = U_r@S_r # shape = (d, r)
A = V_r     # shape = (r, d)

# ------------------------------------
# 计算y_prime = BAx
# ------------------------------------
y_prime = B@A@x

print(&quot;SVD分解W后计算出的y值为:\n&quot;, y_prime)

print(&quot;原始权重W的参数量为: &quot;, W.shape[0]*W.shape[1])
print(&quot;低秩适配后权重B和A的参数量为: &quot;, A.shape[0]*A.shape[1] + B.shape[0]*B.shape[1])
</code></pre>
<p>输出结果为：</p>
<pre><code class="language-python">原始权重W计算出的y值为:
 tensor([ 3.3896,  1.0296,  1.5606, -2.3891, -0.4213, -2.4668, -4.4379, -0.0375,
        -3.2790, -2.9361])
W的秩为:  2
SVD分解W后计算出的y值为:
 tensor([ 3.3896,  1.0296,  1.5606, -2.3891, -0.4213, -2.4668, -4.4379, -0.0375,
        -3.2790, -2.9361])
原始权重W的参数量为:  100
低秩适配后权重B和A的参数量为:  40
</code></pre>
<p><strong>参数量变少了，但并不影响最终输出的结果</strong>。</p>
<h3 id="43-lora低秩适配">4.3 LoRA低秩适配<a class="anchor-link" href="#43-lora低秩适配" title="Permanent link">&para;</a></h3>
<p>好，那既然SVD分解这么有效，那我直接对 <span class="math-inline">\Delta W</span> 做SVD，找到对应的低秩矩阵 <span class="math-inline">A,B</span> ，不就大功告成了吗？<br />
<strong>想法虽然好，但困难是明显的：能直接做SVD的前提是</strong><span class="math-inline">\Delta W</span><strong>是确定的</strong>，而现实中<span class="math-inline">\Delta W</span>作为全参数微调中的权重增量，如果你不全参数微调一遍，又怎么能知道<span class="math-inline">\Delta W</span>长什么样呢？而如果你做了全量微调，那还要低秩适配做什么呢？  </p>
<p>你可能又想：那我能不能对预训练权重 <span class="math-inline">W</span> 做SVD呢，因为 <span class="math-inline">W</span> 是确定的呀。<br />
<strong>想法虽然好，但逻辑是不合理的：我们说过，微调的目的是给模型注入和下游任务相关的领域新知识</strong>。也就是说，<span class="math-inline">\Delta W</span><strong>和</strong> <span class="math-inline">W</span> <strong>的表达含义是不同的，前者是新知识，后者是旧知识</strong>，我们的目的是要去新知识中拆解信息量丰富的维度。  </p>
<p>好，<strong>那既然通过数学方法直接做SVD行不通，那就让模型自己去学怎么做SVD吧！</strong>因此LoRA最终的低秩适配策略是：我把秩 <span class="math-inline">r</span> 当成一个超参，再让模型自己去学低秩矩阵 <span class="math-inline">A,B</span> ，这不就简单又省事吗！  </p>
<p>行，到这里我们已经具象化地了解了LoRA低秩适配的原理了，也知道 <span class="math-inline">W</span> 和<span class="math-inline">\Delta W</span>所表达含义的差异了，<strong>现在，我们可以来看前文遗留的问题：超参</strong> <span class="math-inline">\alpha</span> <strong>是什么意思？</strong></p>
<h3 id="44-超参-alpha">4.4 超参 <span class="math-inline">\alpha</span><a class="anchor-link" href="#44-超参-alpha" title="Permanent link">&para;</a></h3>
<p>我们先来看论文对<span class="math-inline">\alpha</span>的解释：  </p>
<p><img alt="" src="https://pica.zhimg.com/v2-b5a98033309f587201a1ba649090f058_1440w.jpg" /></p>
<p>这段话大致意思是说，在我们采用Adam做优化器时，调整<span class="math-inline">\alpha</span>的作用就相当于调整learning rate。一般而言，我们把<span class="math-inline">\alpha</span>设置为我们第一次做实验时设置的 <span class="math-inline">r</span> ，然后就把<span class="math-inline">\alpha</span>固定下来，之后只调整 <span class="math-inline">r</span> 即可，这样做的好处是当我们尝试不同的 <span class="math-inline">r</span> 时，我们不需要再去调整别的超参了。  </p>
<p>不知道大家第一次读到这段话是什么感受，反正我是没有读懂。google搜了一遍，也没找到具体的解释。直到我按顺序捋了一遍LoRA低秩适配的设计思想后，我好像领悟了一些，下面我来谈谈我的个人见解。  </p>
<p>首先，回顾一下我们的输出计算方法为： <br />
<div class="math-display"><br />
h = Wx + \frac{\alpha}{r}BAx<br />
</div></p>
<p>其中， <span class="math-inline">W</span> 表示预训练权重（<strong>旧知识</strong>）， <span class="math-inline">\frac{\alpha}{r}BA</span> 表示增量权重 <span class="math-inline">\Delta W</span> 的近似（<strong>新知识</strong>）。理论上说，当 <span class="math-inline">r</span> <strong>较小时，我们提取的是</strong> <span class="math-inline">\Delta W</span> <strong>中信息含量最丰富的维度，此时信息精炼，但不全面；当</strong> <span class="math-inline">r</span> <strong>较大时，我们的低秩近似越逼近</strong><span class="math-inline">\Delta W</span><strong>，此时信息更加全面，但带来的噪声也越多（含有很多冗余无效的信息）</strong>。  </p>
<p>基于这个猜想，当我们第一次做实验时，我们会尽量把 <span class="math-inline">r</span> 调得大些，例如32、64，并假设在这个秩下，低秩权重已经非常近似 <span class="math-inline">\Delta W</span> 了，因此这时我们设置 <span class="math-inline">\alpha = r</span> ，意味着我们假定LoRA低秩微调的效果和全参数微调持平。  </p>
<p>那么接下来，我们肯定就要往小的 <span class="math-inline">r</span> 进行尝试了。这时我们把 <span class="math-inline">\alpha</span> 固定住，意味着随着 <span class="math-inline">r</span> 的减小， <span class="math-inline">\frac{\alpha}{r}</span> 会越来越大，我们这样做的原因是：  </p>
<ul>
<li>
<p><strong>当</strong> <span class="math-inline">r</span> <strong>越小时，低秩矩阵表示的信息精炼，但不全面。我们通过调大</strong> <span class="math-inline">\frac{\alpha}{r}</span> <strong>，来放大forward过程中新知识对模型的影响</strong>。</p>
</li>
<li>
<p><strong>当</strong> <span class="math-inline">r</span> <strong>越小时，低秩矩阵表示的信息精炼，噪声/冗余信息少，此时梯度下降的方向也更加确信，所以我们可以通过调大</strong> <span class="math-inline">\frac{\alpha}{r}</span> <strong>，适当增加梯度下降的步伐，也就相当于调整learning rate了</strong>。</p>
</li>
</ul>
<p>好，到这里，我们已经一起学完了LoRA低秩适配的核心思想了。我们前面说过，因为无法用SVD做直接分解，所以作者寄希望于LoRA能“<strong>学习</strong>“到 <span class="math-inline">\Delta W</span> 真正的低秩分解矩阵 <span class="math-inline">A, B</span> ，但是怎么证明LoRA学到的东西就和SVD分解出来的东西有关系呢？接下来，我们一起来解读作者的实验。</p>
<h2 id="五lora实验验证低秩矩阵的有效性">五、LoRA实验：验证低秩矩阵的有效性<a class="anchor-link" href="#五lora实验验证低秩矩阵的有效性" title="Permanent link">&para;</a></h2>
<h3 id="51-整体效果">5.1 整体效果<a class="anchor-link" href="#51-整体效果" title="Permanent link">&para;</a></h3>
<div align=center><img src="https://markdownimg-hw.oss-cn-beijing.aliyuncs.com/20251027095611.png" style="zoom: 80%;" /></div>

<p>首先，作者将LoRA和其余微调方法（全参数微调，Adatper Tuning等）做了比较。纵列表示不同的微调模型，横列表示不同的数据集，加粗部分表示最好的效果指标。可以发现，无论是在各个数据集微调准确率指标上，还是在最后平均微调准确率指标上（Avg.），LoRA都取得了不错的表现，而且它可训练的参数量也非常小。</p>
<h3 id="52-低秩矩阵信息量验证">5.2 低秩矩阵信息量验证<a class="anchor-link" href="#52-低秩矩阵信息量验证" title="Permanent link">&para;</a></h3>
<p>我们前面说过，当 <span class="math-inline">r</span> 越小时，低秩矩阵所含的信息越精炼，但同时也可能越不全面。那么到底 <span class="math-inline">r</span> 要取多少才合适呢？</p>
<p><strong>5.2.1 直接验证不同 <span class="math-inline">r</span> 值下的微调效果</strong></p>
<p>尽管理论上我们可以在模型的任意一层嵌入低秩适配器（比如Embedding， Attention，MLP等），但LoRA中只选咋在Attention层嵌入，并做了相关实验（论文中也鼓励读者可以多做别的尝试），我们来看下Attention层的实验效果：  </p>
<div align=center><img src="https://markdownimg-hw.oss-cn-beijing.aliyuncs.com/20251027095810.png" style="zoom: 80%;" /></div>

<p><code>WikiSQL</code> 和<code>MultiNLI</code>是用于微调的数据集，Weight Type指明在Attention的哪一部分做了低秩适配。可以发现， <span class="math-inline">r=4,8</span> 于 <span class="math-inline">r=64</span> 的效果几乎持平，甚至还略优于 <span class="math-inline">r=64</span> 。这更加说明了“低秩”的有效性。为了更具象化地验证这一点，我们进一步来看<span class="math-inline">r=8</span>和<span class="math-inline">r=64</span>这两个低秩空间的相交程度。  </p>
<p><strong>5.2.2 不同低秩空间的相交程度</strong></p>
<p>假设 <span class="math-inline">A_{r=8}</span> 和 <span class="math-inline">A_{r=64}</span> 分别是在 <span class="math-inline">r=8</span> 和 <span class="math-inline">r=64</span> 下训练出来的低秩矩阵，我们现在想做这么一件事：  </p>
<ul>
<li>从 <span class="math-inline">A_{r=8}</span> 中取出 <span class="math-inline">top_i</span> 个信息最丰富的维度（其中 <span class="math-inline">1\le i \le 8</span> ）</li>
<li>从 <span class="math-inline">A_{r=64}</span> 中取出 <span class="math-inline">top_{j}</span> 个信息最丰富的维度（其中 <span class="math-inline">1\le j \le 64</span> ）</li>
<li>计算这<span class="math-inline">top_i</span>个维度和<span class="math-inline">top_{j}</span>个维度的相交程度，以此来确定两个低秩矩阵间信息的重合度</li>
</ul>
<p><strong>那我怎么找出top个信息最丰富的维度呢？别忘了，我们有SVD方法</strong>，且这回<span class="math-inline">A_{r=8}</span>和<span class="math-inline">A_{r=64}</span>都是确定的了。所以，我们可以对低秩矩阵，再做SVD分解，然后分别得到这两者的右奇异矩阵（也就是前文说的 <span class="math-inline">V^{T}</span> ），但LoRA论文里，用 <span class="math-inline">U</span> 来表示右奇异矩阵，那么我们也入乡随俗把，令：  </p>
<ul>
<li>
<p><span class="math-inline">U_{A_{r=8}}</span> 表示 <span class="math-inline">A_{r=8}</span> 的右奇异矩阵， <span class="math-inline">U_{A_{r=8}}^{i}</span> 表示该右奇异矩阵信息量最丰富的 <span class="math-inline">top_{i}</span> 个维度（复习一下前文，根据 <span class="math-inline">\Sigma</span> 判断信息含量）</p>
</li>
<li>
<p><span class="math-inline">U_{A_{r=64}}</span> 表示 <span class="math-inline">A_{r=64}</span> 的右奇异矩阵， <span class="math-inline">U_{A_{r=64}}^{j}</span> 表示该右奇异矩阵信息量最丰富的 <span class="math-inline">top_{j}</span> 个维度。</p>
</li>
</ul>
<p>好，明确了这些定义后，我们可以来看 <span class="math-inline">A_{r=8}</span> 的 <span class="math-inline">top_{i}</span> 个特征维度，与 <span class="math-inline">A_{r=64}</span> 的 <span class="math-inline">top_{j}</span> 个特征维度的相交程度计算了，这个相交指标也被称为"<strong>Grassmann distance</strong>"。  </p>
<div align=center><img src="https://markdownimg-hw.oss-cn-beijing.aliyuncs.com/20251027101120.png" style="zoom: 80%;" /></div>

<p>从上式可知，<strong>相交程度（Grassmann distance）位于</strong> <span class="math-inline">[0, 1]</span> 之间，该值越大，表示相应的两个子空间越相似。感兴趣的朋友，可以参考论文附录G部分的相关证明。我们这里只关注结论。  </p>
<p>好，把这个指标计算完了，那就可视化一波呗，所以作者继续给出了如下四张图：  </p>
<div align=center><img src="https://markdownimg-hw.oss-cn-beijing.aliyuncs.com/20251027101051.png" style="zoom: 80%;" /></div>

<p>不知道你们第一次看到这张图是什么感觉，反正我是没看懂（欸这话怎么感觉在哪听过一次）。所以以下又是我（不负责任）的解读。  </p>
<p>首先，作者是在 <span class="math-inline">W_{q}, W_{v}</span> 上都做了低秩分解，所以1、3图和2、4图分别为一组，我们就选1、3图来看吧。<br />
其次，<strong>作者做这个实验的目的，其实是想看高秩空间中到底包含了多少低秩空间的信息，这样才能解释为什么</strong> <span class="math-inline">r=64</span> <strong>和</strong> <span class="math-inline">r=8</span> <strong>的效果基本持平</strong>。所以作者在计算Grassmann distance和绘制图表时的逻辑是：</p>
<ul>
<li>
<p>对 <span class="math-inline">A_{r=8}</span> ，当 <span class="math-inline">i=1</span> 时，我想和 <span class="math-inline">A_{r=64}</span> 的 <span class="math-inline">top_{j}, j&gt;=1</span> 进行相似度计算，这样我就能知道， <span class="math-inline">A_{r=8}</span> 中最丰富的那1维信息，究竟包含了多少在 <span class="math-inline">A_{r=64}</span> 的 <span class="math-inline">top_1, top_2, ..., top_{64}</span> 中。</p>
</li>
<li>
<p>对 <span class="math-inline">A_{r=8}</span> ，当 <span class="math-inline">i = 2</span> 时，我想和 <span class="math-inline">A_{r=64}</span> 的 <span class="math-inline">top_{j}, j&gt;=2</span> 进行相似度计算，这样我就能知道， <span class="math-inline">A_{r=8}</span> 中最丰富的那2维信息，究竟包含了多少在 <span class="math-inline">A_{r=64}</span> 的 <span class="math-inline">top_2, top_3, ..., top_{64}</span> 中。</p>
</li>
<li>
<p>以此类推，因为我想<strong>验证的是大秩空间(</strong> <span class="math-inline">A_{r=64}</span> <strong>)对小秩空间(</strong> <span class="math-inline">A_{r=8}</span> <strong>)的包含程度</strong>，所以 <span class="math-inline">i=k</span> 时，我只绘制 <span class="math-inline">j \ge k</span> 的部分，其余部分不绘制。所以才有了图1中，左下角的那一片空白。</p>
</li>
<li>
<p>那 <span class="math-inline">i=k, j \le k</span> 的部分，也就是小秩空间对大秩空间中top维度的包含程度，虽然我没绘制在图1里，但我可以单独拿出来绘制在图3中。所以图3其实是图1左下角缺失部分的填充。</p>
</li>
</ul>
<p>好，解释完这一点，我们再具体来看图例。颜色越浅，表示相似度越高。在图1中，我们不难发现 <span class="math-inline">i=1</span> 这一行的颜色是最浅的，随着 <span class="math-inline">i</span> 的增加，颜色逐渐变深。这说明小秩空间中，信息量越高的那几维特征，和大秩空间的相交度越高，因此它们也是小秩空间表现能持平大秩空间的主要原因，<strong>这也更加论证了作者所说的“低秩”的有效性</strong>。  </p>
<p><strong>看到这个图表结论，你可能有一个疑惑</strong>：不是说 <span class="math-inline">A_{r=8}</span> 取的是 <span class="math-inline">\Delta W</span> 信息最丰富的8个维度，而 <span class="math-inline">A_{r=64}</span> 取的是 <span class="math-inline">\Delta W</span> 信息最丰富的64个维度吗？那么它们的前8个维度应该是一样的啊！所以随着 <span class="math-inline">i</span> 的增加，空间重合度不是应该越来越大吗？怎么是图表的结果是越来越小呢？  </p>
<p>这是因为“<span class="math-inline">A_{r=8}</span> 取的是 <span class="math-inline">\Delta W</span> 信息最丰富的8个维度，而 <span class="math-inline">A_{r=64}</span> 取的是 <span class="math-inline">\Delta W</span> 信息最丰富的64个维度”这个现象，是我们的理想，而当模型真正学出来时却不是这样。模型会尽可能往信息最丰富的维度学，但不能保证 <strong><span class="math-inline">r</span></strong> 取多少，最终学出来的一定就是客观存在的<span class="math-inline">\Delta W</span>的top <span class="math-inline">r</span>，只能说当<span class="math-inline">r</span>取的比较小时，模型更有可能贴近真正的top <span class="math-inline">r</span>；当<span class="math-inline">r</span>取比较大时，模型学出的是部分有价值的信息和一些噪声（另外，也许 <span class="math-inline">\Delta W</span> 真正的秩还可能小于 <span class="math-inline">r</span> 呢），而这个实验则刚好论证了这一点。  </p>
<p>如果理解了这一点，接下来我们可以更好来解读下一个实验了：<strong>模型不同的层，它们的<span class="math-inline">r</span>要如何设置呢</strong>？  </p>
<p><strong>5.2.3 不同层的<span class="math-inline">r</span>值设置</strong></p>
<p>前面我们看到，<strong>LoRA作用在了</strong> <span class="math-inline">W_{q}</span> <strong>和</strong> <span class="math-inline">W_{v}</span> <strong>上，那么对于这两个不同的矩阵，</strong> <span class="math-inline">r</span> <strong>值设置上是否也有不同的讲究呢？</strong>  </p>
<p>为了解答这一点，作者又设计了一个实验：对三个矩阵 <span class="math-inline">W_{q}, W_{v}, Random Gaussia</span> ，每个矩阵分别设置两组不同的随机种子，跑出两组不同的低秩矩阵 <span class="math-inline">A_{r=64}</span> ，计算这两组低秩矩阵的Grassmann distance，结果如下：  </p>
<div align=center><img src="https://markdownimg-hw.oss-cn-beijing.aliyuncs.com/20251027102159.png" style="zoom: 80%;" /></div>

<p>按我们之前说明的，两组 <span class="math-inline">A_{r=64}</span> 并不是完美学出客观存在的 <span class="math-inline">\Delta W</span> 的top 64维最丰富的信息，而是“部分有效的信息+一些噪声”，基于此我们不难想到：两组 <span class="math-inline">A_{r=64}</span> 都能学到的信息，大概率就是有用的信息了。所以我们对这两组<span class="math-inline">A_{r=64}</span>也做了相似度的计算，从左图中可以看出，<span class="math-inline">A_{r=64}</span>的top 10的颜色最浅，在这以内的，可能就是较为有效的信息了。根据这样的分析结果，我们也能对模型的不同部分采用不同的秩。  </p>
<p><strong>5.2.4 预训练权重 VS 微调权重</strong></p>
<p>之前我们说过，<strong>预训练权重</strong> <span class="math-inline">W</span> <strong>是旧知识，微调权重</strong> <span class="math-inline">\Delta W</span> <strong>是新知识。所以正常来说，</strong> <span class="math-inline">\Delta W</span> <strong>中应该会有一些</strong> <span class="math-inline">W</span> <strong>没有关注到的部分。所以，我们也有必要论证我们训出的低秩矩阵是不是符合了这一点</strong>。作者设计的实验结果如下：  </p>
<div align=center><img src="https://markdownimg-hw.oss-cn-beijing.aliyuncs.com/20251027103149.png" style="zoom: 80%;" /></div>

<p>其中 <span class="math-inline">\Delta W_{q}</span> <strong>表示训练出来的用低秩矩阵近似的结果</strong>，不是前文所说的客观存在 <span class="math-inline">\Delta W</span> 。我们来解读一下这个实验：  </p>
<p>首先看表格的最下行，分别对预训练权重 <span class="math-inline">W_q</span> ，增量权重 <span class="math-inline">\Delta W_q</span> 计算范数，<strong>我们可以将这个指标粗略地理解为</strong> <span class="math-inline">W_q, \Delta W_q</span> <strong>中蕴含的全量信息量</strong>。</p>
<p>接下来，我们求指标 <span class="math-inline">||U^{T}W_qV^{T}||</span> ，这里我们共有6组 <span class="math-inline">U, V</span> 值：前3个来自 <span class="math-inline">r=4</span> 时， <span class="math-inline">\Delta W_q, W_q, RandomGaussian</span> 矩阵的奇异值分解结果，后三个以此类推。因此 <span class="math-inline">||U^{T}W_qV^{T}||</span> 表示：把预训练权重 <span class="math-inline">W_{q}</span> 分别投影到 <span class="math-inline">\Delta W_q, W_q, RandomGaussian</span> 这三者的低秩近似特征空间中去，去计算投影过后 <span class="math-inline">W_{q}</span> 在对应特征空间的信息量。如果 <span class="math-inline">W_q</span> 和对应特征空间越相似，则 <span class="math-inline">||U^{T}W_qV^{T}||</span> 值越大。</p>
<p>光看概念是不是有些迷糊，那我们来找个具体指标解读一下吧：</p>
<p>首先来看61.95和21.67这一组。61.95表示预训练权重 <span class="math-inline">W_q</span> 本身具有的信息量，21.67表示把 <span class="math-inline">W_q</span> 投影到自己 <span class="math-inline">r=4</span> 的低秩空间后的信息量（投影到低秩空间必然会产生信息损失）。</p>
<p>再来看0.32和0.02这一组。0.32表示预训练权重<span class="math-inline">W_q</span>投影到增量权重 <span class="math-inline">\Delta W_q</span> 的 <span class="math-inline">r=4</span> 的低秩空间后的信息量，0.02同理类推。可以看出，含义新知识的增量权重与随机权重相比，和预训练权重还是有一定相关性的。</p>
<p>最后，我们再来看6.91和0.32。预训练权重投影到增量权重的低秩空间后，信息量从61.95降为0.32，<strong>说明预训练权重（旧知识）和增量权重（新知识）的分布间还是存在显著差异的</strong>。6.91表示增量权重本身的信息量<strong>。因此21.95 = 6.91/0.32这个值，恰好能表示增量权重对预训练权重中那些没有强调的信息的放大程度</strong>。秩越小，放大程度越明显。</p>
<h2 id="六references">六、References<a class="anchor-link" href="#六references" title="Permanent link">&para;</a></h2>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/650197598">深入浅出 LoRA</a></li>
<li><a href="https://mp.weixin.qq.com/s/KKEzBfmphVln-bNufy_M9g">LLM 微调(Finetune) 技术--LoRA</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/636215898">大模型参数高效微调技术原理综述（五）-LoRA、AdaLoRA、QLoRA</a></li>
<li><a href="https://kexue.fm/archives/9590">梯度视角下的 LoRA：简介、分析、猜测及推广</a></li>
<li><a href="https://kexue.fm/archives/10001#how_to_cite">配置不同的学习率，LoRA 还能再涨一点？</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/702629428">大模型高效微调-LoRA 原理详解和训练过程深入分析</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/646831196">图解大模型微调系列之：大模型低秩适配器LoRA（原理篇）</a></li>
<li><a href="https://arxiv.org/pdf/2106.09685">https//arxiv.org/pdf/2106.09685.pdf</a></li>
<li><a href="https://github.com/microsoft/LoRA">https://github.com/microsoft/LoRA</a> </li>
<li><a href="https://medium.com/%40Shrishml/lora-low-rank-adaptation-from-the-first-principle-7e1adec71541">https://medium.com/@Shrishml/lora-low-rank-adaptation-from-the-first-principle-7e1adec71541</a>  </li>
<li><a href="https://blog.sciencenet.cn/blog-696950-699432.html">https://blog.sciencenet.cn/blog-696950-699432.html</a> </li>
<li><a href="https://kexue.fm/archives/9590/comment-page-1">https://kexue.fm/archives/9590/comment-page-1</a></li>
<li><a href="https://mp.weixin.qq.com/s/mxg4H7hF82lILUua4mwFSw">LLM微调(Finetune) 技术--LoRA</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/1891217133259711785">探秘Transformer系列之（22）--- LoRA</a></li>
</ul>
                </div>

                <!-- Comments Section (Giscus) -->
                <section class="comments-section">
                    <h3><i class="fas fa-comments"></i> 评论</h3>
                    <script src="https://giscus.app/client.js"
                        data-repo="Geeks-Z/Geeks-Z.github.io"
                        data-repo-id=""
                        data-category="Announcements"
                        data-category-id=""
                        data-mapping="pathname"
                        data-strict="0"
                        data-reactions-enabled="1"
                        data-emit-metadata="0"
                        data-input-position="bottom"
                        data-theme="preferred_color_scheme"
                        data-lang="zh-CN"
                        crossorigin="anonymous"
                        async>
                    </script>
                </section>
            </article>

            <footer class="post-footer">
                <p>© 2025 Hongwei Zhao. Built with ❤️</p>
            </footer>
        </main>
    </div>

    <!-- Theme Toggle Button -->
    <button class="theme-toggle" id="themeToggle" aria-label="切换主题">
        <i class="fas fa-moon"></i>
    </button>

    <script>
        // Theme Toggle
        const themeToggle = document.getElementById('themeToggle');
        const html = document.documentElement;
        const icon = themeToggle.querySelector('i');
        const hljsDark = document.getElementById('hljs-theme-dark');
        const hljsLight = document.getElementById('hljs-theme-light');
        
        // Check saved theme or system preference
        const savedTheme = localStorage.getItem('theme');
        const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
        
        if (savedTheme === 'dark' || (!savedTheme && prefersDark)) {
            html.setAttribute('data-theme', 'dark');
            icon.className = 'fas fa-sun';
            hljsDark.disabled = false;
            hljsLight.disabled = true;
        }
        
        themeToggle.addEventListener('click', () => {
            const isDark = html.getAttribute('data-theme') === 'dark';
            if (isDark) {
                html.removeAttribute('data-theme');
                icon.className = 'fas fa-moon';
                localStorage.setItem('theme', 'light');
                hljsDark.disabled = true;
                hljsLight.disabled = false;
            } else {
                html.setAttribute('data-theme', 'dark');
                icon.className = 'fas fa-sun';
                localStorage.setItem('theme', 'dark');
                hljsDark.disabled = false;
                hljsLight.disabled = true;
            }
            
            // Update Giscus theme
            const giscusFrame = document.querySelector('iframe.giscus-frame');
            if (giscusFrame) {
                giscusFrame.contentWindow.postMessage({
                    giscus: {
                        setConfig: {
                            theme: isDark ? 'light' : 'dark'
                        }
                    }
                }, 'https://giscus.app');
            }
        });
        
        // Highlight.js
        document.addEventListener('DOMContentLoaded', () => {
            hljs.highlightAll();
        });
        
        // KaTeX auto-render
        document.addEventListener('DOMContentLoaded', () => {
            if (typeof renderMathInElement !== 'undefined') {
                renderMathInElement(document.body, {
                    delimiters: [
                        {left: '$$', right: '$$', display: true},
                        {left: '$', right: '$', display: false},
                        {left: '\\[', right: '\\]', display: true},
                        {left: '\\(', right: '\\)', display: false}
                    ],
                    throwOnError: false
                });
            }
        });
        
        // TOC active state
        const tocLinks = document.querySelectorAll('.toc-container a');
        const headings = document.querySelectorAll('.post-content h2, .post-content h3, .post-content h4');
        
        function updateTocActive() {
            let current = '';
            headings.forEach(heading => {
                const rect = heading.getBoundingClientRect();
                if (rect.top <= 100) {
                    current = heading.getAttribute('id');
                }
            });
            
            tocLinks.forEach(link => {
                link.classList.remove('active');
                if (link.getAttribute('href') === '#' + current) {
                    link.classList.add('active');
                }
            });
        }
        
        window.addEventListener('scroll', updateTocActive);
        updateTocActive();
    </script>
</body>
</html>
