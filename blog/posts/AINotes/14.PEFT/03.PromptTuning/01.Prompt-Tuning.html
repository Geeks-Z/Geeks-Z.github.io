<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Untitled</title>
    <meta name="description" content="Untitled - Hongwei Zhao's Blog">
    <meta name="author" content="Hongwei Zhao">
    
    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Noto+Sans+SC:wght@300;400;500;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    
    <!-- Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <!-- Code Highlighting -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css" id="hljs-theme-dark">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css" id="hljs-theme-light" disabled>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    
    <!-- KaTeX for Math -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>
    
    <style>
        :root {
            /* Light Theme - 明亮清新配色 */
            --primary-color: #4A90D9;
            --primary-hover: #3678C2;
            --link-color: #E86B5F;
            --text-color: #2D2D2D;
            --text-light: #5A5A5A;
            --text-muted: #8A8A8A;
            --bg-color: #FFFFFF;
            --bg-secondary: #F5F7FA;
            --bg-code: #F8F9FC;
            --border-color: #E8ECF0;
            --shadow: 0 2px 8px rgba(0,0,0,0.06);
            --shadow-lg: 0 8px 24px rgba(0,0,0,0.08);
        }

        [data-theme="dark"] {
            --primary-color: #5dade2;
            --primary-hover: #85c1e9;
            --link-color: #e74c3c;
            --text-color: #e5e7eb;
            --text-light: #9ca3af;
            --text-muted: #6b7280;
            --bg-color: #1a1a2e;
            --bg-secondary: #16213e;
            --bg-code: #0f0f23;
            --border-color: #374151;
            --shadow: 0 1px 3px rgba(0,0,0,0.3);
            --shadow-lg: 0 4px 15px rgba(0,0,0,0.4);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            scroll-behavior: smooth;
        }

        body {
            font-family: 'Inter', 'Noto Sans SC', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            font-size: 16px;
            line-height: 1.8;
            color: var(--text-color);
            background: var(--bg-color);
            transition: background-color 0.3s, color 0.3s;
        }

        a {
            color: var(--primary-color);
            text-decoration: none;
            transition: color 0.2s;
        }

        a:hover {
            color: var(--primary-hover);
            text-decoration: underline;
        }

        /* Layout */
        .page-wrapper {
            display: flex;
            max-width: 1400px;
            margin: 0 auto;
            padding: 2rem;
            gap: 3rem;
        }

        /* Sidebar TOC */
        .toc-sidebar {
            width: 260px;
            flex-shrink: 0;
            position: sticky;
            top: 2rem;
            height: fit-content;
            max-height: calc(100vh - 4rem);
            overflow-y: auto;
        }

        .toc-container {
            background: var(--bg-secondary);
            border-radius: 12px;
            padding: 1.5rem;
            border: 1px solid var(--border-color);
        }

        .toc-container h3 {
            font-size: 0.85rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-muted);
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .toc-container ul {
            list-style: none;
        }

        .toc-container li {
            margin-bottom: 0.5rem;
        }

        .toc-container a {
            font-size: 0.9rem;
            color: var(--text-light);
            display: block;
            padding: 0.25rem 0;
            border-left: 2px solid transparent;
            padding-left: 0.75rem;
            transition: all 0.2s;
        }

        .toc-container a:hover,
        .toc-container a.active {
            color: var(--primary-color);
            border-left-color: var(--primary-color);
            text-decoration: none;
        }

        .toc-container ul ul {
            margin-left: 1rem;
        }

        /* Main Content */
        .main-content {
            flex: 1;
            min-width: 0;
            max-width: 800px;
        }

        /* Header */
        .post-header {
            margin-bottom: 2rem;
            padding-bottom: 1.5rem;
            border-bottom: 1px solid var(--border-color);
        }

        .back-link {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.9rem;
            color: var(--text-light);
            margin-bottom: 1.5rem;
        }

        .back-link:hover {
            color: var(--primary-color);
            text-decoration: none;
        }

        .post-header h1 {
            font-size: 2.25rem;
            font-weight: 700;
            line-height: 1.3;
            margin-bottom: 1rem;
            color: var(--text-color);
        }

        .post-meta {
            display: flex;
            flex-wrap: wrap;
            gap: 1.5rem;
            font-size: 0.9rem;
            color: var(--text-light);
        }

        .post-meta span {
            display: flex;
            align-items: center;
            gap: 0.4rem;
        }

        .post-meta i {
            color: var(--text-muted);
        }

        .tags {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-top: 1rem;
        }

        .tag {
            display: inline-block;
            font-size: 0.8rem;
            background: var(--bg-secondary);
            color: var(--text-light);
            padding: 0.25rem 0.75rem;
            border-radius: 20px;
            border: 1px solid var(--border-color);
            transition: all 0.2s;
        }

        .tag:hover {
            background: var(--primary-color);
            color: white;
            border-color: var(--primary-color);
        }

        /* Article Content */
        .post-content {
            font-size: 1rem;
            line-height: 1.9;
        }

        .post-content h1,
        .post-content h2,
        .post-content h3,
        .post-content h4,
        .post-content h5,
        .post-content h6 {
            margin-top: 2rem;
            margin-bottom: 1rem;
            font-weight: 600;
            line-height: 1.4;
            color: var(--text-color);
        }

        .post-content h1 { font-size: 1.875rem; }
        .post-content h2 { 
            font-size: 1.5rem; 
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--border-color);
        }
        .post-content h3 { font-size: 1.25rem; }
        .post-content h4 { font-size: 1.125rem; }

        .post-content p {
            margin-bottom: 1.25rem;
        }

        .post-content ul,
        .post-content ol {
            margin: 1.25rem 0;
            padding-left: 1.5rem;
        }

        .post-content li {
            margin-bottom: 0.5rem;
        }

        .post-content blockquote {
            margin: 1.5rem 0;
            padding: 1rem 1.5rem;
            background: var(--bg-secondary);
            border-left: 4px solid var(--primary-color);
            border-radius: 0 8px 8px 0;
            color: var(--text-light);
            font-style: italic;
        }

        .post-content blockquote p:last-child {
            margin-bottom: 0;
        }

        /* Code */
        .post-content code {
            font-family: 'JetBrains Mono', 'Fira Code', Consolas, monospace;
            font-size: 0.9em;
            background: var(--bg-code);
            padding: 0.2em 0.4em;
            border-radius: 4px;
            color: var(--link-color);
        }

        .post-content pre {
            margin: 1.5rem 0;
            padding: 1.25rem;
            background: var(--bg-code);
            border-radius: 10px;
            overflow-x: auto;
            border: 1px solid var(--border-color);
        }

        .post-content pre code {
            background: none;
            padding: 0;
            color: inherit;
            font-size: 0.875rem;
            line-height: 1.6;
        }

        /* Images */
        .post-content img {
            max-width: 100%;
            height: auto;
            border-radius: 10px;
            margin: 1.5rem 0;
            box-shadow: var(--shadow-lg);
        }

        /* Tables */
        .post-content table {
            width: 100%;
            margin: 1.5rem 0;
            border-collapse: collapse;
            font-size: 0.95rem;
        }

        .post-content th,
        .post-content td {
            padding: 0.75rem 1rem;
            border: 1px solid var(--border-color);
            text-align: left;
        }

        .post-content th {
            background: var(--bg-secondary);
            font-weight: 600;
        }

        .post-content tr:nth-child(even) {
            background: var(--bg-secondary);
        }

        /* Math */
        .math-display {
            margin: 1.5rem 0;
            overflow-x: auto;
            padding: 1rem;
            background: var(--bg-secondary);
            border-radius: 8px;
        }

        /* Anchor links */
        .anchor-link {
            opacity: 0;
            margin-left: 0.5rem;
            color: var(--text-muted);
            font-weight: 400;
            transition: opacity 0.2s;
        }

        .post-content h2:hover .anchor-link,
        .post-content h3:hover .anchor-link,
        .post-content h4:hover .anchor-link {
            opacity: 1;
        }

        /* Theme Toggle */
        .theme-toggle {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: var(--primary-color);
            color: white;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.25rem;
            box-shadow: var(--shadow-lg);
            transition: transform 0.2s, background 0.2s;
            z-index: 1000;
        }

        .theme-toggle:hover {
            transform: scale(1.1);
            background: var(--primary-hover);
        }

        /* Comments Section */
        .comments-section {
            margin-top: 3rem;
            padding-top: 2rem;
            border-top: 1px solid var(--border-color);
        }

        .comments-section h3 {
            font-size: 1.25rem;
            margin-bottom: 1.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        /* Footer */
        .post-footer {
            margin-top: 3rem;
            padding-top: 1.5rem;
            border-top: 1px solid var(--border-color);
            text-align: center;
            font-size: 0.9rem;
            color: var(--text-muted);
        }

        /* Responsive */
        @media (max-width: 1024px) {
            .toc-sidebar {
                display: none;
            }
            
            .page-wrapper {
                padding: 1.5rem;
            }
        }

        @media (max-width: 768px) {
            .post-header h1 {
                font-size: 1.75rem;
            }
            
            .post-meta {
                flex-direction: column;
                gap: 0.5rem;
            }
            
            .theme-toggle {
                bottom: 1rem;
                right: 1rem;
                width: 44px;
                height: 44px;
            }
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-secondary);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--text-muted);
        }
    </style>
</head>
<body>
    <div class="page-wrapper">
        <!-- TOC Sidebar -->
        <aside class="toc-sidebar">
            <div class="toc-container">
                <h3><i class="fas fa-list"></i> 目录</h3>
                <div class="toc">
<ul>
<li><a href="#面向预训练语言模型的-prompt-tuning-技术发展历程">面向预训练语言模型的 Prompt-Tuning 技术发展历程</a></li>
<li><a href="#prompt-vs-fine-tuning">Prompt vs Fine-tuning</a></li>
<li><a href="#prompt-tuning-的研究进展">Prompt-Tuning 的研究进展</a><ul>
<li><a href="#连续提示模板">连续提示模板</a></li>
</ul>
</li>
<li><a href="#prompt-tuning-的本质">Prompt-Tuning 的本质</a><ul>
<li><a href="#prompt-是一种针对任务的指令">Prompt 是一种针对任务的指令</a></li>
<li><a href="#复用预训练目标实现基于-prompt-的统一范式">复用预训练目标——实现基于 Prompt 的统一范式</a></li>
<li><a href="#prompt-的本质是参数有效性学习">Prompt 的本质是参数有效性学习</a></li>
</ul>
</li>
<li><a href="#面向超大规模模型的-prompt-tuning">面向超大规模模型的 Prompt-Tuning</a><ul>
<li><a href="#in-context-learning上下文学习">In-Context Learning（上下文学习）</a></li>
</ul>
</li>
</ul>
</div>

            </div>
        </aside>

        <!-- Main Content -->
        <main class="main-content">
            <article>
                <header class="post-header">
                    <a href="../../../../index.html" class="back-link">
                        <i class="fas fa-arrow-left"></i> 返回博客列表
                    </a>
                    <h1>Untitled</h1>
                    <div class="post-meta">
                        <span><i class="fas fa-calendar-alt"></i> 2026-02-04</span>
                        <span><i class="fas fa-folder"></i> AINotes/14.PEFT/03.PromptTuning</span>
                        <span><i class="fas fa-user"></i> Hongwei Zhao</span>
                    </div>
                    <div class="tags">
                        
                    </div>
                </header>

                <div class="post-content">
                    <h2 id="面向预训练语言模型的-prompt-tuning-技术发展历程">面向预训练语言模型的 Prompt-Tuning 技术发展历程<a class="anchor-link" href="#面向预训练语言模型的-prompt-tuning-技术发展历程" title="Permanent link">&para;</a></h2>
<p><img alt="图片" src="https://markdownimg-hw.oss-cn-beijing.aliyuncs.com/image202312101657510.png" /></p>
<p>Prompt-Tuning 自从 GPT-3 被提出以来，从传统的离散、连续的 Prompt 的构建、走向面向超大规模模型的 In-Context Learning、Instruction-tuning 和 Chain-of-Thought。</p>
<p>自从 GPT、EMLO、BERT 的相继提出，以<code>Pre-training + Fine-tuning</code> 的模式在诸多自然语言处理（NLP）任务中被广泛使用，其先在<code>Pre-training</code>阶段通过一个模型在大规模无监督语料上预先训练一个 <strong>预训练语言模型（Pre-trained Language Model，PLM）</strong> ，然后在<code>Fine-tuning</code>阶段基于训练好的语言模型在具体的下游任务上再次进行 <strong>微调（Fine-tuning）</strong> ，以获得适应下游任务的模型。</p>
<p>这种模式在诸多任务的表现上超越了传统的监督学习方法，不论在工业生产、科研创新还是竞赛中均作为新的主流方式。然而，这套模式也存在着一些问题。例如，在大多数的下游任务微调时， <strong>下游任务的目标与预训练的目标差距过大</strong> 导致提升效果不明显， <strong>微调过程中依赖大量的监督语料</strong> 等。</p>
<p><strong>至此，以 GPT-3、PET 为首提出一种基于预训练语言模型的新的微调范式——Prompt-Tuning</strong> ，其旨在通过添加模板的方法来避免引入额外的参数，从而让语言模型可以在小样本（Few-shot）或零样本（Zero-shot）场景下达到理想的效果。Prompt-Tuning 又可以称为 Prompt、Prompting、Prompt-based Fine-tuning 等。</p>
<p>因此简单的来说，Prompt-Tuning 的动机旨在解决目前传统 Fine-tuning 的两个痛点问题：</p>
<ul>
<li><strong>降低语义差异（Bridge the gap between Pre-training and Fine-tuning）</strong> ：预训练任务主要以 Masked Language Modeling（MLM）为主，而下游任务则重新引入新的训练参数，因此两个阶段的目标通常有较大差异。因此需要解决如何缩小 Pre-training 和 Fine-tuning 两个阶段目标差距过大的问题；</li>
<li><strong>避免过拟合（Overfitting of the head）</strong> ：由于在 Fine-tuning 阶段需要新引入额外的参数以适配相应的任务需要，因此在样本数量有限的情况容易发生过拟合，降低了模型的泛化能力。因此需要面对预训练语言模型的过拟合问题。</li>
</ul>
<h2 id="prompt-vs-fine-tuning">Prompt vs Fine-tuning<a class="anchor-link" href="#prompt-vs-fine-tuning" title="Permanent link">&para;</a></h2>
<p><img alt="image-20230402151604671" src="https://markdownimg-hw.oss-cn-beijing.aliyuncs.com/image202304171642665.png" /></p>
<p><strong>Fine-tuning：预训练语言模型“迁就”各种下游任务</strong><br />
具体体现就是上面提到的通过引入各种辅助任务 loss，将其添加到预训练模型中，然后继续 pre-training，以便让其更加适配下游任务。总之，这个过程中，<a href="https://www.zhihu.com/search?q=预训练语言模型&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra={&quot;sourceType&quot;%3A&quot;answer&quot;%2C&quot;sourceId&quot;%3A2127127513}">预训练语言模型</a>做出了更多的牺牲。</p>
<p>先在 Pre-training 阶段通过一个模型在大规模无监督语料上预先训练一个 预训练语言模型（Pre-trained Language Model，PLM） ，然后在 Fine-tuning 阶段基于训练好的语言模型在具体的下游任务上再次进行 微调（Fine-tuning） ，以获得适应下游任务的模型。</p>
<p>问题：在大多数的下游任务微调时， 下游任务的目标与预训练的目标差距过大 导致提升效果不明显， 微调过程中依赖大量的监督语料 等。</p>
<p><strong>Prompting 中，是各种下游任务“迁就预训练语言模型。</strong><br />
具体体现也是上面介绍的，我们需要对不同任务进行重构，使得它达到适配预训练语言模型的效果。总之，这个过程中，是下游任务做出了更多的牺牲。</p>
<p><strong>Prompt-Tuning</strong> Prompt-Tuning 又可以称为 Prompt、Prompting、Prompt-based Fine-tuning</p>
<ul>
<li>In-context Learning ：是 Prompt 的前身。其通过从训练集中挑选一些样本作为任务的提示提示（Natural Language Prompt），来实现免参数更新的模型预测；</li>
<li>Demonstration Learning ：添加一些新的文本作为提示。例如在对“I like the Disney film. It was [MASK]”进行情感分析时，可以拼接一些相似场景的 ground-truth 文本“I like the book, it was great.”、“The music is boring. It is terrible for me.”等。此时模型在根据新添加的两个样例句子就可以“照葫芦画瓢”式地预测结果了</li>
</ul>
<h2 id="prompt-tuning-的研究进展">Prompt-Tuning 的研究进展<a class="anchor-link" href="#prompt-tuning-的研究进展" title="Permanent link">&para;</a></h2>
<h3 id="连续提示模板">连续提示模板<a class="anchor-link" href="#连续提示模板" title="Permanent link">&para;</a></h3>
<blockquote>
<p>假设针对分类任务, 给定一个输入句子<span class="math-inline">x</span>, 连续提示的模板可以定义为: <span class="math-inline">T=[x][v_1][v_2]...[v_m][mask]</span> 其中<span class="math-inline">[v_i]</span> 是伪标记, 其仅代表一个抽象的 token, 并没有实际的含义, 本质上是一个向量。</p>
</blockquote>
<h2 id="prompt-tuning-的本质">Prompt-Tuning 的本质<a class="anchor-link" href="#prompt-tuning-的本质" title="Permanent link">&para;</a></h2>
<h3 id="prompt-是一种针对任务的指令">Prompt 是一种针对任务的指令<a class="anchor-link" href="#prompt-是一种针对任务的指令" title="Permanent link">&para;</a></h3>
<p><strong>Prompt 本质上是对下游任务的指令，可以作为一种信息增强。</strong></p>
<p>简单的来说，就是告诉模型需要做什么任务，输出什么内容。上文我们提及到的离散或连续的模板，本质上就是一种对任务的提示。当数据集不同（乃至样本不同）的时候，我们期望模型能够自适应的选择不同的模板，这也相当于说不同的任务会有其对应的提示信息。</p>
<p>例如在对电影评论进行二分类的时候，最简单的提示模板是“. It was [mask].”，但是其并没有突出该任务的具体特性，我们可以为其设计一个能够突出该任务特性的模板，例如“The movie review is . It was [mask].”，然后根据 mask 位置的输出结果通过 Verbalizer 映射到具体的标签上。这一类具备任务特性的模板可以称之为指令（Instruction）。</p>
<p>下面展示几个任务设计的指令模板：</p>
<div align=center><img src="https://markdownimg-hw.oss-cn-beijing.aliyuncs.com/20240126221506.png" style="zoom: 50%;" /></div>

<p>看似设计指令是一件容易的事情，但是在真实使用过程中，预训练模型很难“理解”这些指令，根据最近研究工作发现，主要总结如下几个原因：</p>
<p><strong>预训练模型不够大</strong> ：我们常使用的 BERT-base、BERT-large、RoBERTa-base 和 RoBERTa-large 只有不到 10 亿参数，相比于现如今 GPT-3、OPT 等只能算作小模型，有工作发现，<strong>小模型在进行 Prompt Tuning 的时候会比 Fine-tuning 效果差</strong>，是因为小模型很容易受到模板的影响</p>
<blockquote>
<p>对比一下传统的 Fine-tuning，每个样本的输入几乎都是不同的，然而基于 Prompt 的方法中，所有的样本输入都会包含相同的指令，这就导致小模型很容易受到这些指令带来的干扰。</p>
</blockquote>
<p><strong>缺乏指令相关的训练</strong> ：这些小模型在预训练阶段没有专门学习过如何理解一些特殊的指令。</p>
<blockquote>
<p>我们回顾一下上面章节，不论是生成离散的模板还是连续的模板，都是在向现有的预训练语言模型进行“妥协”，即找到能够让当前预训练语言模型在小样本上效果最好的模板，或者说是站在已有预训练模型的基础上寻找模板。然而这种寻找到的模板不可读也不可解释，或者过于通用，不具备任务特性，无法很好地在真实场景下使用。因此，我们需要的是先设计好任务相关的指令，使得这些指令是可读的，可在真实场景下使用的。不过由于预训练模型没见过这些指令，所以很难在小样本上快速理解它们。</p>
</blockquote>
<h3 id="复用预训练目标实现基于-prompt-的统一范式">复用预训练目标——实现基于 Prompt 的统一范式<a class="anchor-link" href="#复用预训练目标实现基于-prompt-的统一范式" title="Permanent link">&para;</a></h3>
<h3 id="prompt-的本质是参数有效性学习">Prompt 的本质是参数有效性学习<a class="anchor-link" href="#prompt-的本质是参数有效性学习" title="Permanent link">&para;</a></h3>
<p>根据前文的讲解，我们可以发现，实现 Prompt-Tuning 只需要考虑如何设计模板或指令，而模型和训练目标则都是复用预训练阶段的，即在整个训练过程中，无须添加任何参数（或只需要添加非常少量的与模板有关的参数），而其他参数都是训练好的。基于这个思想，我们再一次将 Prompt 升华到更高的层面—— <strong>Prompt 的本质是参数有效性学习（Parameter-Efficient Learning，PEL）</strong> 。</p>
<blockquote>
<p><strong>参数有效性学习的背景</strong> ：在一般的计算资源条件下，大规模的模型（例如 GPT-3）很难再进行微调，因为所有的参数都需要计算梯度并进行更新，消耗时间和空间资源。为了解决这个问题，参数有效性学习被提出，其旨在确保模型效果不受太大影响的条件下尽可能地提高训练的时间和空间效率。<br />
<strong>参数有效性训练</strong> ：在参数有效性学习过程中，大模型中只需要指定或额外添加少量的可训练参数，而其余的参数全部冻结，这样可以大大提高模型的训练效率的同时，确保指标不会受到太大影响。</p>
</blockquote>
<p>常见经典的参数有效性学习有<strong>Adapter-Tuning、Prefix-Tuning、BitFit</strong>。下面进行简单的介绍。</p>
<p><strong>（1）Adapter-Tuning</strong></p>
<p>Adapter-Tuning 在 2019 年提出，其面向预训练语言模型的参数有效性学习。在多层 Transformer 模型中，在微调过程中所有的参数都需要更新，显然并不是有效的。为了提高效率，该方法提出固定 Transformer 的全部参数，然后在 Transformer 的每一个 Block 里嵌入一些新初始化的 Adapter Network。如下图所示：</p>
<div align=center><img src="https://markdownimg-hw.oss-cn-beijing.aliyuncs.com/20240127154715.png" style="zoom: 80%;" /></div>
<p>Adapter位于Feed-Forward Layer之后、残差连接之前。Adapter本质上就是两层MLP，分别负责将Transformer的表征降维和升维（右图）。基于Adapter的方法，<strong>只需要添加不到5%的可训练参数，即可以几乎达到全参数训练的效果</strong>，在训练过程中大大节省了训练时间，做到时间有效性。因此在真实场景应用时，不同的任务我们不需要重新对整个预训练模型进行微调，我们只需要保存Adapter即可，而预训练模型的其他参数都是原始预训练的，这样就做到了空间的有效性。</p>
<p><strong>（2）Prefix-Tuning</strong></p>
<p>Prefix-Tuning 也是很经典的参数有效性学习，其是受到 Prompt-Tuning 的启发。我们说 Prompt-Tuning 的本质是参数有效性学习，是因为整个预训练模型参数可以全部固定，只需要对 Template 对应的少量参数（例如连续模板的 Prompt Encoder、伪标记对应的 Embedding 等）进行训练。在 Prefix-Tuning 中，则是除了对输入层添加模板外，还对 Transformer 的每一层添加“模板”。Prefix-Tuning 与传统 Fine-tuning 的对比图如下所示：</p>
<div align=center><img src="https://markdownimg-hw.oss-cn-beijing.aliyuncs.com/20240127160607.png" style="zoom: 80%;" /></div>

<p>可以看到，Transformer 的参数完全固定，而我们只需要对 Prefix 部分进行训练即可，对于不同的任务训练不同的 Prefix，在实际使用时，挑选任务相关的 Prefix 和 Transformer 进行组装，实现可插拔式的应用。<br />
与 Prefix-Tuning 类似的方法还有 P-tuning V2，不同之处在于 Prefix-Tuning 是面向文本生成领域的，P-tuning V2 面向自然语言理解。但本质上完全相同。下图针对 Prefix-tuning（P-tuning V2）与 Prompt-Tuning 对比（黄色部分表示可训练的参数，蓝色表示被冻结的参数）：</p>
<div align=center><img src="https://markdownimg-hw.oss-cn-beijing.aliyuncs.com/20240127160730.png" style="zoom: 80%;" /></div>

<p>左图表示的是基于连续提示的 Prompt-Tuning（例如 P-tuning），我们可以发现只有输入层对应模板部分的 Embedding 和 MLP 参数是可训练的，右图部分表示 Prefix-Tuning（P-tuning V2），Transformer 的每一层的前缀部分也是可训练的，可以抽象的认为是在每一层添加了连续的模板。但是实际上，Prefix-Tuning（P-tuning V2）并不是真正的在每一层添加模板，而是通过 HuggingFace 框架内置的 past_key_value 参数控制。其本质上与 Adapter 类似，是在 Transformer 内部对 Key 和 Value 插入可训练的两个 MLP。</p>
<p>有相关工作对 Adapter、Prefix-Tuning、LoRA 等参数有效性学习进行了集成，因为这些参数有效性学习方法本质上都是插入少量的新的参数，这些新的参数可以对预训练模型起到提示作用，只不过并不是以人类可读的离散的模板形式体现而已。</p>
<p>下图是《UniPELT: A Unified Framework for Parameter-Efficient Language Model Tuning》提出将这些参数有效性方法进行统一，提出 UniPELT 框架：</p>
<div align=center><img src="https://markdownimg-hw.oss-cn-beijing.aliyuncs.com/20240127210051.png" style="zoom: 80%;" /></div>

<p><strong>（3）BitFit</strong></p>
<p>BitFit 的思想更简单，其不需要对预训练模型做任何改动，只需要指定神经网络中的偏向（Bias）为可训练参数即可，BitFit 的参数量只有不到 2%，但是实验效果可以接近全量参数。</p>
<p>介绍了上述的一些参数有效性方法，我们发现，Prompt-Tuning 也符合其主旨。基于参数有效性的思想，也有许多工作致力于 Prompt 与参数有效性的结合，例如《Delta Tuning: A Comprehensive Study of Parameter Efficient Methods for Pre-trained Language Models》、《LiST: Lite Prompted Self-training Makes Parameter-efficient Few-shot Learners》、《Making Parameter-efficient Tuning More Efficient: A Unified Framework for Classification Tasks》、《P-Adapters- Robustly Extracting Factual Information from Language Models with Diverse Prompts》、《Context-Tuning: Learning Contextualized Prompts for Natural Language Generation》，由于相关工作非常多而且更新频繁，这里不一一介绍。</p>
<h2 id="面向超大规模模型的-prompt-tuning">面向超大规模模型的 Prompt-Tuning<a class="anchor-link" href="#面向超大规模模型的-prompt-tuning" title="Permanent link">&para;</a></h2>
<p>Prompt-Tuning 发展的两年来，有诸多工作发现，对于超过 10 亿参数量的模型来说，Prompt-Tuning 所带来的增益远远高于标准的 Fine-tuning，小样本甚至是零样本的性能也能够极大地被激发出来，得益于这些模型的<strong>参数量足够大</strong>，训练过程中使用了足够多的语料，同时设计的预训练任务足够有效。最为经典的大规模语言模型则是 2020 年提出的 GPT-3，其拥有大约 1750 亿的参数，且发现只需要设计合适的模板或指令即可以实现免参数训练的零样本学习。</p>
<p>2022 年底到 2023 年初，国内外也掀起了 AIGC 的浪潮，典型代表是 OpenAI 发布的 ChatGPT、GPT-4 大模型，Google 发布的 Bard 以及百度公司发布的文心一言等。超大规模模型进入新的纪元，而这些轰动世界的产物，离不开强大的 Prompt-Tuning 技术。本文默认以 GPT-3 为例，介绍几个面向超大规模的 Prompt-Tuning 方法，分别为：</p>
<ul>
<li><strong>上下文学习 In-Context Learning（ICL）</strong> ：直接挑选少量的训练样本作为该任务的提示；</li>
<li><strong>指令学习 Instruction-tuning</strong> ：构建任务指令集，促使模型根据任务指令做出反馈；</li>
<li><strong>思维链 Chain-of-Thought（CoT）</strong> ：给予或激发模型具有推理和解释的信息，通过线性链式的模式指导模型生成合理的结果。</li>
</ul>
<h3 id="in-context-learning上下文学习">In-Context Learning（上下文学习）<a class="anchor-link" href="#in-context-learning上下文学习" title="Permanent link">&para;</a></h3>
<p>In-Context learning（ICL）最早在 GPT-3 中提出， 旨在从训练集中挑选少量的标注样本，设计任务相关的指令形成提示模板，用于指导测试样本生成相应的结果 。ICT 的工作原理如下所示：</p>
                </div>

                <!-- Comments Section (Giscus) -->
                <section class="comments-section">
                    <h3><i class="fas fa-comments"></i> 评论</h3>
                    <script src="https://giscus.app/client.js"
                        data-repo="Geeks-Z/Geeks-Z.github.io"
                        data-repo-id=""
                        data-category="Announcements"
                        data-category-id=""
                        data-mapping="pathname"
                        data-strict="0"
                        data-reactions-enabled="1"
                        data-emit-metadata="0"
                        data-input-position="bottom"
                        data-theme="preferred_color_scheme"
                        data-lang="zh-CN"
                        crossorigin="anonymous"
                        async>
                    </script>
                </section>
            </article>

            <footer class="post-footer">
                <p>© 2025 Hongwei Zhao. Built with ❤️</p>
            </footer>
        </main>
    </div>

    <!-- Theme Toggle Button -->
    <button class="theme-toggle" id="themeToggle" aria-label="切换主题">
        <i class="fas fa-moon"></i>
    </button>

    <script>
        // Theme Toggle
        const themeToggle = document.getElementById('themeToggle');
        const html = document.documentElement;
        const icon = themeToggle.querySelector('i');
        const hljsDark = document.getElementById('hljs-theme-dark');
        const hljsLight = document.getElementById('hljs-theme-light');
        
        // Check saved theme or system preference
        const savedTheme = localStorage.getItem('theme');
        const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
        
        if (savedTheme === 'dark' || (!savedTheme && prefersDark)) {
            html.setAttribute('data-theme', 'dark');
            icon.className = 'fas fa-sun';
            hljsDark.disabled = false;
            hljsLight.disabled = true;
        }
        
        themeToggle.addEventListener('click', () => {
            const isDark = html.getAttribute('data-theme') === 'dark';
            if (isDark) {
                html.removeAttribute('data-theme');
                icon.className = 'fas fa-moon';
                localStorage.setItem('theme', 'light');
                hljsDark.disabled = true;
                hljsLight.disabled = false;
            } else {
                html.setAttribute('data-theme', 'dark');
                icon.className = 'fas fa-sun';
                localStorage.setItem('theme', 'dark');
                hljsDark.disabled = false;
                hljsLight.disabled = true;
            }
            
            // Update Giscus theme
            const giscusFrame = document.querySelector('iframe.giscus-frame');
            if (giscusFrame) {
                giscusFrame.contentWindow.postMessage({
                    giscus: {
                        setConfig: {
                            theme: isDark ? 'light' : 'dark'
                        }
                    }
                }, 'https://giscus.app');
            }
        });
        
        // Highlight.js
        document.addEventListener('DOMContentLoaded', () => {
            hljs.highlightAll();
        });
        
        // KaTeX auto-render
        document.addEventListener('DOMContentLoaded', () => {
            if (typeof renderMathInElement !== 'undefined') {
                renderMathInElement(document.body, {
                    delimiters: [
                        {left: '$$', right: '$$', display: true},
                        {left: '$', right: '$', display: false},
                        {left: '\\[', right: '\\]', display: true},
                        {left: '\\(', right: '\\)', display: false}
                    ],
                    throwOnError: false
                });
            }
        });
        
        // TOC active state
        const tocLinks = document.querySelectorAll('.toc-container a');
        const headings = document.querySelectorAll('.post-content h2, .post-content h3, .post-content h4');
        
        function updateTocActive() {
            let current = '';
            headings.forEach(heading => {
                const rect = heading.getBoundingClientRect();
                if (rect.top <= 100) {
                    current = heading.getAttribute('id');
                }
            });
            
            tocLinks.forEach(link => {
                link.classList.remove('active');
                if (link.getAttribute('href') === '#' + current) {
                    link.classList.add('active');
                }
            });
        }
        
        window.addEventListener('scroll', updateTocActive);
        updateTocActive();
    </script>
</body>
</html>
