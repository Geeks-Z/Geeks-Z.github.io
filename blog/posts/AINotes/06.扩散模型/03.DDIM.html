<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>扩散模型之DDIM</title>
    <meta name="description" content="扩散模型之DDIM - Hongwei Zhao's Blog">
    <meta name="author" content="Hongwei Zhao">
    
    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Noto+Sans+SC:wght@300;400;500;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    
    <!-- Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <!-- Code Highlighting -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css" id="hljs-theme-dark">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css" id="hljs-theme-light" disabled>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    
    <!-- KaTeX for Math -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>
    
    <style>
        :root {
            /* Light Theme */
            --primary-color: #2980b9;
            --primary-hover: #1a5276;
            --link-color: #c0392b;
            --text-color: #333;
            --text-light: #666;
            --text-muted: #999;
            --bg-color: #fff;
            --bg-secondary: #f8f9fa;
            --bg-code: #f5f5f5;
            --border-color: #e5e7eb;
            --shadow: 0 1px 3px rgba(0,0,0,0.1);
            --shadow-lg: 0 4px 15px rgba(0,0,0,0.1);
        }

        [data-theme="dark"] {
            --primary-color: #5dade2;
            --primary-hover: #85c1e9;
            --link-color: #e74c3c;
            --text-color: #e5e7eb;
            --text-light: #9ca3af;
            --text-muted: #6b7280;
            --bg-color: #1a1a2e;
            --bg-secondary: #16213e;
            --bg-code: #0f0f23;
            --border-color: #374151;
            --shadow: 0 1px 3px rgba(0,0,0,0.3);
            --shadow-lg: 0 4px 15px rgba(0,0,0,0.4);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            scroll-behavior: smooth;
        }

        body {
            font-family: 'Inter', 'Noto Sans SC', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            font-size: 16px;
            line-height: 1.8;
            color: var(--text-color);
            background: var(--bg-color);
            transition: background-color 0.3s, color 0.3s;
        }

        a {
            color: var(--primary-color);
            text-decoration: none;
            transition: color 0.2s;
        }

        a:hover {
            color: var(--primary-hover);
            text-decoration: underline;
        }

        /* Layout */
        .page-wrapper {
            display: flex;
            max-width: 1400px;
            margin: 0 auto;
            padding: 2rem;
            gap: 3rem;
        }

        /* Sidebar TOC */
        .toc-sidebar {
            width: 260px;
            flex-shrink: 0;
            position: sticky;
            top: 2rem;
            height: fit-content;
            max-height: calc(100vh - 4rem);
            overflow-y: auto;
        }

        .toc-container {
            background: var(--bg-secondary);
            border-radius: 12px;
            padding: 1.5rem;
            border: 1px solid var(--border-color);
        }

        .toc-container h3 {
            font-size: 0.85rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-muted);
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .toc-container ul {
            list-style: none;
        }

        .toc-container li {
            margin-bottom: 0.5rem;
        }

        .toc-container a {
            font-size: 0.9rem;
            color: var(--text-light);
            display: block;
            padding: 0.25rem 0;
            border-left: 2px solid transparent;
            padding-left: 0.75rem;
            transition: all 0.2s;
        }

        .toc-container a:hover,
        .toc-container a.active {
            color: var(--primary-color);
            border-left-color: var(--primary-color);
            text-decoration: none;
        }

        .toc-container ul ul {
            margin-left: 1rem;
        }

        /* Main Content */
        .main-content {
            flex: 1;
            min-width: 0;
            max-width: 800px;
        }

        /* Header */
        .post-header {
            margin-bottom: 2rem;
            padding-bottom: 1.5rem;
            border-bottom: 1px solid var(--border-color);
        }

        .back-link {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.9rem;
            color: var(--text-light);
            margin-bottom: 1.5rem;
        }

        .back-link:hover {
            color: var(--primary-color);
            text-decoration: none;
        }

        .post-header h1 {
            font-size: 2.25rem;
            font-weight: 700;
            line-height: 1.3;
            margin-bottom: 1rem;
            color: var(--text-color);
        }

        .post-meta {
            display: flex;
            flex-wrap: wrap;
            gap: 1.5rem;
            font-size: 0.9rem;
            color: var(--text-light);
        }

        .post-meta span {
            display: flex;
            align-items: center;
            gap: 0.4rem;
        }

        .post-meta i {
            color: var(--text-muted);
        }

        .tags {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-top: 1rem;
        }

        .tag {
            display: inline-block;
            font-size: 0.8rem;
            background: var(--bg-secondary);
            color: var(--text-light);
            padding: 0.25rem 0.75rem;
            border-radius: 20px;
            border: 1px solid var(--border-color);
            transition: all 0.2s;
        }

        .tag:hover {
            background: var(--primary-color);
            color: white;
            border-color: var(--primary-color);
        }

        /* Article Content */
        .post-content {
            font-size: 1rem;
            line-height: 1.9;
        }

        .post-content h1,
        .post-content h2,
        .post-content h3,
        .post-content h4,
        .post-content h5,
        .post-content h6 {
            margin-top: 2rem;
            margin-bottom: 1rem;
            font-weight: 600;
            line-height: 1.4;
            color: var(--text-color);
        }

        .post-content h1 { font-size: 1.875rem; }
        .post-content h2 { 
            font-size: 1.5rem; 
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--border-color);
        }
        .post-content h3 { font-size: 1.25rem; }
        .post-content h4 { font-size: 1.125rem; }

        .post-content p {
            margin-bottom: 1.25rem;
        }

        .post-content ul,
        .post-content ol {
            margin: 1.25rem 0;
            padding-left: 1.5rem;
        }

        .post-content li {
            margin-bottom: 0.5rem;
        }

        .post-content blockquote {
            margin: 1.5rem 0;
            padding: 1rem 1.5rem;
            background: var(--bg-secondary);
            border-left: 4px solid var(--primary-color);
            border-radius: 0 8px 8px 0;
            color: var(--text-light);
            font-style: italic;
        }

        .post-content blockquote p:last-child {
            margin-bottom: 0;
        }

        /* Code */
        .post-content code {
            font-family: 'JetBrains Mono', 'Fira Code', Consolas, monospace;
            font-size: 0.9em;
            background: var(--bg-code);
            padding: 0.2em 0.4em;
            border-radius: 4px;
            color: var(--link-color);
        }

        .post-content pre {
            margin: 1.5rem 0;
            padding: 1.25rem;
            background: var(--bg-code);
            border-radius: 10px;
            overflow-x: auto;
            border: 1px solid var(--border-color);
        }

        .post-content pre code {
            background: none;
            padding: 0;
            color: inherit;
            font-size: 0.875rem;
            line-height: 1.6;
        }

        /* Images */
        .post-content img {
            max-width: 100%;
            height: auto;
            border-radius: 10px;
            margin: 1.5rem 0;
            box-shadow: var(--shadow-lg);
        }

        /* Tables */
        .post-content table {
            width: 100%;
            margin: 1.5rem 0;
            border-collapse: collapse;
            font-size: 0.95rem;
        }

        .post-content th,
        .post-content td {
            padding: 0.75rem 1rem;
            border: 1px solid var(--border-color);
            text-align: left;
        }

        .post-content th {
            background: var(--bg-secondary);
            font-weight: 600;
        }

        .post-content tr:nth-child(even) {
            background: var(--bg-secondary);
        }

        /* Math */
        .math-display {
            margin: 1.5rem 0;
            overflow-x: auto;
            padding: 1rem;
            background: var(--bg-secondary);
            border-radius: 8px;
        }

        /* Anchor links */
        .anchor-link {
            opacity: 0;
            margin-left: 0.5rem;
            color: var(--text-muted);
            font-weight: 400;
            transition: opacity 0.2s;
        }

        .post-content h2:hover .anchor-link,
        .post-content h3:hover .anchor-link,
        .post-content h4:hover .anchor-link {
            opacity: 1;
        }

        /* Theme Toggle */
        .theme-toggle {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: var(--primary-color);
            color: white;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.25rem;
            box-shadow: var(--shadow-lg);
            transition: transform 0.2s, background 0.2s;
            z-index: 1000;
        }

        .theme-toggle:hover {
            transform: scale(1.1);
            background: var(--primary-hover);
        }

        /* Comments Section */
        .comments-section {
            margin-top: 3rem;
            padding-top: 2rem;
            border-top: 1px solid var(--border-color);
        }

        .comments-section h3 {
            font-size: 1.25rem;
            margin-bottom: 1.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        /* Footer */
        .post-footer {
            margin-top: 3rem;
            padding-top: 1.5rem;
            border-top: 1px solid var(--border-color);
            text-align: center;
            font-size: 0.9rem;
            color: var(--text-muted);
        }

        /* Responsive */
        @media (max-width: 1024px) {
            .toc-sidebar {
                display: none;
            }
            
            .page-wrapper {
                padding: 1.5rem;
            }
        }

        @media (max-width: 768px) {
            .post-header h1 {
                font-size: 1.75rem;
            }
            
            .post-meta {
                flex-direction: column;
                gap: 0.5rem;
            }
            
            .theme-toggle {
                bottom: 1rem;
                right: 1rem;
                width: 44px;
                height: 44px;
            }
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-secondary);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--text-muted);
        }
    </style>
</head>
<body>
    <div class="page-wrapper">
        <!-- TOC Sidebar -->
        <aside class="toc-sidebar">
            <div class="toc-container">
                <h3><i class="fas fa-list"></i> 目录</h3>
                <div class="toc">
<ul>
<li><a href="#ddim原理">DDIM原理</a></li>
<li><a href="#实验结果">实验结果</a></li>
<li><a href="#代码实现">代码实现</a></li>
<li><a href="#其它重建和插值">其它：重建和插值</a></li>
<li><a href="#小结">小结</a></li>
<li><a href="#参考">参考</a></li>
</ul>
</div>

            </div>
        </aside>

        <!-- Main Content -->
        <main class="main-content">
            <article>
                <header class="post-header">
                    <a href="../../../index.html" class="back-link">
                        <i class="fas fa-arrow-left"></i> 返回博客列表
                    </a>
                    <h1>扩散模型之DDIM</h1>
                    <div class="post-meta">
                        <span><i class="fas fa-calendar-alt"></i> 2026-01-28</span>
                        <span><i class="fas fa-folder"></i> AINotes/06.扩散模型</span>
                        <span><i class="fas fa-user"></i> Hongwei Zhao</span>
                    </div>
                    <div class="tags">
                        
                    </div>
                </header>

                <div class="post-content">
                    <h1 id="扩散模型之ddim">扩散模型之DDIM<a class="anchor-link" href="#扩散模型之ddim" title="Permanent link">&para;</a></h1>
<p><strong>Author:</strong> [小小将]</p>
<p><strong>Link:</strong> [https://zhuanlan.zhihu.com/p/565698027]</p>
<blockquote>
<p>“What I cannot create, I do not understand.” -- Richard Feynman</p>
</blockquote>
<p>上一篇文章<a href="https://zhuanlan.zhihu.com/p/563661713">https://zhuanlan.zhihu.com/p/563661713</a>介绍了经典扩散模型DDPM的原理和实现，对于扩散模型来说，一个最大的缺点是需要设置较长的扩散步数才能得到好的效果，这导致了<strong>生成样本的速度较慢</strong>，比如扩散步数为1000的话，那么生成一个样本就要模型推理1000次。这篇文章我们将介绍另外一种扩散模型<strong>DDIM</strong>（<a href="https://arxiv.org/abs/2010.02502">https://arxiv.org/abs/2010.02502</a>），<strong>DDIM和DDPM有相同的训练目标</strong>，但是它不再限制扩散过程必须是一个马尔卡夫链，这使得DDIM可以<strong>采用更小的采样步数来加速生成过程</strong>，DDIM的另外是一个特点是从一个随机噪音<strong>生成样本的过程是一个确定的过程</strong>（中间没有加入随机噪音）。</p>
<h2 id="ddim原理">DDIM原理<a class="anchor-link" href="#ddim原理" title="Permanent link">&para;</a></h2>
<p>在介绍DDIM之前，先来回顾一下DDPM。在DDPM中，扩散过程（前向过程）定义为一个马尔卡夫链：</p>
<p><span class="math-inline">q(\mathbf{x}<em>{1:T} \vert \mathbf{x}_0) = \prod^T</em>{t=1} q(\mathbf{x}<em>t \vert \mathbf{x}</em>{t-1}) \quad q(\mathbf{x}<em>t \vert \mathbf{x}</em>{t-1}) = \mathcal{N}(\mathbf{x}<em>t; \sqrt{\frac{\alpha_t}{\alpha</em>{t-1}}} \mathbf{x}<em>{t-1}, \Big(1-\frac{\alpha_t}{\alpha</em>{t-1}}\Big)\mathbf{I}) \</span></p>
<p>注意，在DDIM的论文中，<span class="math-inline">\alpha_t</span> 实是DDPM论文中的<span class="math-inline">\bar{\alpha}_t</span>，那么DDPM论文中的前向过程<span class="math-inline">\beta_t</span> 为：</p>
<p><span class="math-inline">\beta_t = \Big(1-\frac{\alpha_t}{\alpha_{t-1}}\Big) \</span></p>
<p>扩散过程的一个重要特性是可以直接用<span class="math-inline">\mathbf{x}_0</span> 对任意的<span class="math-inline">\mathbf{x}_t</span> 行采样：</p>
<p><span class="math-inline">q(\mathbf{x}_t \vert \mathbf{x}_0) = \mathcal{N}(\mathbf{x}_t; \sqrt{{\alpha}_t} \mathbf{x}_0, (1 - {\alpha}_t)\mathbf{I}) \</span></p>
<p>而DDPM的反向过程也定义为一个马尔卡夫链：</p>
<p><span class="math-inline">p_\theta(\mathbf{x}<em>{0:T}) = p(\mathbf{x}_T) \prod^T</em>{t=1} p_\theta(\mathbf{x}<em>{t-1} \vert \mathbf{x}_t) \quad p</em>\theta(\mathbf{x}<em>{t-1} \vert \mathbf{x}_t) = \mathcal{N}(\mathbf{x}</em>{t-1}; \boldsymbol{\mu}<em>\theta(\mathbf{x}_t, t), \boldsymbol{\Sigma}</em>\theta(\mathbf{x}_t, t))\</span></p>
<p>这里用神经网络<span class="math-inline">p_\theta(\mathbf{x}<em>{t-1} \vert \mathbf{x}_t)</span> 拟合真实的分布<span class="math-inline">q(\mathbf{x}</em>{t-1} \vert \mathbf{x}_t)</span>。DDPM的前向过程和反向过程如下所示： </p>
<p><img alt="" src="https://markdownimg-hw.oss-cn-beijing.aliyuncs.com/202410312116805.jpg" /><br />
 我们近一步发现后验分布<span class="math-inline">q(\mathbf{x}_{t-1} \vert \mathbf{x}_t, \mathbf{x}_0)</span> 一个可获取的高斯分布：</p>
<p><span class="math-inline">q(\mathbf{x}<em>{t-1} \vert \mathbf{x}_t, \mathbf{x}_0) = \mathcal{N}(\mathbf{x}</em>{t-1}; \color{blue}{\tilde{\boldsymbol{\mu}}}(\mathbf{x}_t, \mathbf{x}_0), \color{red}{\tilde{\beta}_t} \mathbf{I}) \</span></p>
<p>其中这个高斯分布的方差是定值，而均值是一个依赖<span class="math-inline">\mathbf{x}_0</span> <span class="math-inline">\mathbf{x}_t</span> 组合函数：</p>
<p><span class="math-inline">\tilde{\boldsymbol{\mu}}<em>t (\mathbf{x}_t, \mathbf{x}_0) = \frac{\sqrt{\alpha_t}(1 - {\alpha}</em>{t-1})}{\sqrt{\alpha_{t-1}}(1 - {\alpha}<em>t)} \mathbf{x}_t + \frac{\sqrt{{\alpha}</em>{t-1}}\beta_t}{1 - {\alpha}_t} \mathbf{x}_0\</span></p>
<p>然后我们基于变分法得到如下的优化目标：</p>
<p><span class="math-inline">\begin{aligned} L  &amp;= \mathbb{E}<em>{q(\mathbf{x}</em>{1:T}\vert \mathbf{x}<em>{0})} \Big[ \log\frac{q(\mathbf{x}</em>{1:T}\vert\mathbf{x}<em>0)}{p</em>\theta(\mathbf{x}<em>{0:T})} \Big] \ &amp;= \underbrace{D</em>\text{KL}(q(\mathbf{x}<em>T \vert \mathbf{x}_0) \parallel p</em>\theta(\mathbf{x}<em>T))}</em>{L_T} + \sum_{t=2}^T \underbrace{\mathbb{E}<em>{q(\mathbf{x}</em>{t}\vert \mathbf{x}<em>{0})}\Big[D</em>\text{KL}(q(\mathbf{x}<em>{t-1} \vert \mathbf{x}_t, \mathbf{x}_0) \parallel p</em>\theta(\mathbf{x}<em>{t-1} \vert\mathbf{x}_t))\Big]}</em>{L_{t-1}} -\underbrace{\mathbb{E}<em>{q(\mathbf{x}</em>{1}\vert \mathbf{x}<em>{0})}\log p</em>\theta(\mathbf{x}<em>0 \vert \mathbf{x}_1)}</em>{L_0} \end{aligned}\</span></p>
<p>根据两个高斯分布的KL公式，我们近一步得到：</p>
<p><span class="math-inline">L_{t-1}=\mathbb{E}<em>{q(\mathbf{x}</em>{t}\vert \mathbf{x}<em>{0})}\Big[ \frac{1}{2{\sigma_t^2}}|\tilde{\boldsymbol{\mu}}_t(\mathbf{x}_t, \mathbf{x}_0) - {\boldsymbol{\mu}</em>\theta(\mathbf{x}_t, t)} |^2\Big] \</span></p>
<p>根据扩散过程的特性，我们通过重参数化可以近一步简化上述目标：</p>
<p><span class="math-inline">L_{t-1}=\mathbb{E}<em>{\mathbf{x}</em>{0},\mathbf{\epsilon}\sim \mathcal{N}(\mathbf{0}, \mathbf{I})}\Big[ \frac{\beta_t^2}{2{\sigma_t^2}\alpha_t(1-\bar{\alpha}<em>t)}| \mathbf{\epsilon}- \mathbf{\epsilon}</em>\theta\big(\sqrt{\bar{\alpha}_t}\mathbf{x}_0 + \sqrt{1 - \bar{\alpha}_t}\mathbf{\epsilon}, t\big)|^2\Big] \</span></p>
<p>如果去掉系数，那么就能得到更简化的优化目标：</p>
<p><span class="math-inline">L_{t-1}^{\text{simple}}=\mathbb{E}<em>{\mathbf{x}</em>{0},\mathbf{\epsilon}\sim \mathcal{N}(\mathbf{0}, \mathbf{I})}\Big[ | \mathbf{\epsilon}- \mathbf{\epsilon}_\theta\big(\sqrt{\bar{\alpha}_t}\mathbf{x}_0 + \sqrt{1 - \bar{\alpha}_t}\mathbf{\epsilon}, t\big)|^2\Big] \</span></p>
<p>仔细分析DDPM的优化目标会发现，DDPM其实仅仅依赖边缘分布<span class="math-inline">q(\mathbf{x}<em>t \vert \mathbf{x}_0)</span>，而并不是直接作用在联合分布<span class="math-inline">q(\mathbf{x}</em>{1:T} \vert \mathbf{x}<em>0)</span>。这带来的一个启示是：DDPM这个隐变量模型可以有很多推理分布来选择，只要推理分布满足边缘分布条件（扩散过程的特性）即可，而且这些推理过程并不一定要是马尔卡夫链。但值得注意的一个点是，我们要得到DDPM的优化目标，还需要知道分布<span class="math-inline">q(\mathbf{x}</em>{t-1} \vert \mathbf{x}<em>t, \mathbf{x}_0)</span>，之前我们在根据贝叶斯公式推导这个分布时是知道分布<span class="math-inline">q(\mathbf{x}_t \vert \mathbf{x}</em>{t-1})</span> ，而且依赖了前向过程的马尔卡夫链特性。如果要解除对前向过程的依赖，那么我们就需要直接定义这个分布<span class="math-inline">q(\mathbf{x}_{t-1} \vert \mathbf{x}_t, \mathbf{x}_0)</span>。 基于上述分析，DDIM论文中将推理分布定义为：</p>
<p><span class="math-inline">q_{\sigma}(\mathbf{x}<em>{1:T} \vert \mathbf{x}_0) = q</em>{\sigma}(\mathbf{x}<em>{T} \vert \mathbf{x}_0)\prod^T</em>{t=2} q_{\sigma}(\mathbf{x}<em>{t-1} \vert \mathbf{x}</em>{t},\mathbf{x}_{0}) \</span></p>
<p>这里要同时满足<span class="math-inline">q_{\sigma}(\mathbf{x}<em>{T} \vert \mathbf{x}_0)=\mathcal{N}(\sqrt{\alpha_T}\mathbf{x}</em>{0},(1-{\alpha_T})\mathbf{I})</span> 及对于所有的<span class="math-inline">t\ge2</span> ：</p>
<p><span class="math-inline">q_\sigma(\mathbf{x}<em>{t-1} \vert \mathbf{x}_t, \mathbf{x}_0) = \mathcal{N}(\mathbf{x}</em>{t-1}; \sqrt{\alpha_{t-1}}\mathbf{x}<em>0 + \sqrt{1 - \alpha</em>{t-1} - \sigma_t^2} \frac{\mathbf{x}_t - \sqrt{\alpha_t}\mathbf{x}_0}{\sqrt{1 - \alpha_t}}, \sigma_t^2 \mathbf{I})\</span></p>
<p>这里的方差<span class="math-inline">\sigma_t^2</span> 一个实数，不同的设置就是不一样的分布，所以<span class="math-inline">q_{\sigma}(\mathbf{x}<em>{1:T} \vert \mathbf{x}_0)</span> 实是一系列的推理分布。可以看到这里分布<span class="math-inline">q</em>\sigma(\mathbf{x}<em>{t-1} \vert \mathbf{x}_t, \mathbf{x}_0)</span> 均值也定义为一个依赖<span class="math-inline">\mathbf{x}_0</span> <span class="math-inline">\mathbf{x}_t</span> 组合函数，之所以定义为这样的形式，是因为根据<span class="math-inline">q</em>{\sigma}(\mathbf{x}_{T} \vert \mathbf{x}_0)</span>，我们可以通过数学归纳法证明，对于所有的<span class="math-inline">t</span> 满足：</p>
<p><span class="math-inline">q_{\sigma}(\mathbf{x}_t \vert \mathbf{x}_0) = \mathcal{N}(\mathbf{x}_t; \sqrt{{\alpha}_t} \mathbf{x}_0, (1 - {\alpha}_t)\mathbf{I}) \</span></p>
<p>这部分的证明见DDIM论文的附录部分，另外博客<a href="https://kexue.fm/archives/9181">https://kexue.fm/archives/9181</a>也从待定系数法来证明了分布<span class="math-inline">q_\sigma(\mathbf{x}<em>{t-1} \vert \mathbf{x}_t, \mathbf{x}_0)</span> 构造的形式。 可以看到这里定义的推理分布<span class="math-inline">q</em>{\sigma}(\mathbf{x}<em>{1:T} \vert \mathbf{x}_0)</span> 没有直接定义前向过程，但这里满足了我们前面要讨论的两个条件：边缘分布<span class="math-inline">q</em>{\sigma}(\mathbf{x}<em>t \vert \mathbf{x}_0) = \mathcal{N}(\mathbf{x}_t; \sqrt{{\alpha}_t} \mathbf{x}_0, (1 - {\alpha}_t)\mathbf{I})</span>，同时已知后验分布<span class="math-inline">q</em>\sigma(\mathbf{x}<em>{t-1} \vert \mathbf{x}_t, \mathbf{x}_0)</span>。同样地，我们可以按照和DDPM的一样的方式去推导优化目标，最终也会得到同样的<span class="math-inline">L^{\text{simple}}</span>（虽然VLB的系数不同，论文3.2部分也证明了这个结论）。 论文也给出了一个前向过程是非马尔可夫链的示例，如下图所示，这里前向过程是<span class="math-inline">q</em>\sigma(\mathbf{x}<em>{t} \vert \mathbf{x}</em>{t-1}, \mathbf{x}<em>0)</span>，由于生成<span class="math-inline">\mathbf{x}_t</span> 仅依赖<span class="math-inline">\mathbf{x}</em>{t-1}</span>，而且依赖<span class="math-inline">\mathbf{x}_0</span>，所以是一个非马尔可夫链： </p>
<p><img alt="" src="https://markdownimg-hw.oss-cn-beijing.aliyuncs.com/202410312116806.jpg" /><br />
 注意，这里只是一个前向过程的示例，而实际上我们上述定义的推理分布并不需要前向过程就可以得到和DDPM一样的优化目标。与DDPM一样，这里也是用神经网络<span class="math-inline">\mathbf{\epsilon}<em>\theta</span> 预测噪音，那么根据<span class="math-inline">q</em>\sigma(\mathbf{x}<em>{t-1} \vert \mathbf{x}_t, \mathbf{x}_0)</span> 形式，在生成阶段，我们可以用如下公式来从<span class="math-inline">\mathbf{x}</em>{t}</span> 成<span class="math-inline">\mathbf{x}_{t-1}</span>：</p>
<p><span class="math-inline">\mathbf{x}<em>{t-1}  = \sqrt{\alpha</em>{t-1}}\Big(\underbrace{\frac{\mathbf{x}<em>t-\sqrt{1-\alpha</em>{t}}\mathbf{\epsilon}<em>\theta(\mathbf{x}_t, t)}{\sqrt{\alpha</em>{t}}}}<em>{\text{predicted}\ \mathbf{x}_0}\Big) + \underbrace{\sqrt{1 - \alpha</em>{t-1} - \sigma_t^2} \cdot \mathbf{\epsilon}<em>\theta(\mathbf{x}_t, t)}</em>{\text{direction pointing to }\ \mathbf{x}<em>t} + \underbrace{\sigma_t\epsilon_t}</em>{\text {random noise}}\</span></p>
<p>这里将生成过程分成三个部分：一是由预测的<span class="math-inline">\mathbf{x}_0</span> 产生的，二是由指向<span class="math-inline">\mathbf{x}_t</span> 部分，三是随机噪音（这里<span class="math-inline">\epsilon_t</span> 与<span class="math-inline">\mathbf{x}_t</span> 关的噪音）。论文将<span class="math-inline">\sigma_t^2</span> 一步定义为：</p>
<p><span class="math-inline">\sigma_t^2 = \eta \cdot \tilde{\beta}<em>t=\eta \cdot\sqrt{(1-\alpha</em>{t-1})/(1-\alpha_{t})}\sqrt{(1-\alpha_{t}/\alpha_{t-1})} \</span></p>
<p>这里考虑两种情况，一是<span class="math-inline">\eta=1</span>，此时<span class="math-inline">\sigma_t^2 = \tilde{\beta}_t</span>，此时生成过程就和DDPM一样了。另外一种情况是<span class="math-inline">\eta=0</span>，这个时候生成过程就没有随机噪音了，是一个确定性的过程，论文将这种情况下的模型称为<strong>DDIM</strong>（<strong>denoising diffusion implicit model）</strong>，一旦最初的随机噪音<span class="math-inline">\mathbf{x}_T</span> 定了，那么DDIM的样本生成就变成了确定的过程。</p>
<p>上面我们终于得到了DDIM模型，那么我们现在来看如何来加速生成过程。虽然DDIM和DDPM的训练过程一样，但是我们前面已经说了，DDIM并没有明确前向过程，这意味着我们可以<strong>定义一个更短的步数的前向过程</strong>。具体地，这里我们从原始的序列<span class="math-inline">[1, ..., T]</span> 样一个长度为<span class="math-inline">S</span> 子序列<span class="math-inline">[\tau_1,...,\tau_S]</span>，我们将<span class="math-inline">\mathbf{x}<em>{\tau </em>{1}},...,\mathbf{x}<em>{\tau</em>{S}}</span> 前向过程定义为一个马尔卡夫链，并且它们满足：<span class="math-inline">q(\mathbf{x}<em>{\tau</em>{i}} \vert \mathbf{x}<em>0) = \mathcal{N}(\mathbf{x}_t; \sqrt{{\alpha}</em>{\tau_{i}}} \mathbf{x}<em>0, (1 - {\alpha}</em>{\tau_{i}})\mathbf{I})</span>。下图展示了一个具体的示例：</p>
<p><img alt="" src="https://markdownimg-hw.oss-cn-beijing.aliyuncs.com/202410312116807.jpg" /><br />
 那么生成过程也可以用这个子序列的反向马尔卡夫链来替代，由于<span class="math-inline">S</span> 以设置比原来的步数<span class="math-inline">L</span> 小，那么就可以加速生成过程。这里的生成过程变成：</p>
<p><span class="math-inline">\mathbf{x}<em>{\tau</em>{i-1}}  = \sqrt{\alpha_{\tau_{i-1}}}\Big(\frac{\mathbf{x}<em>{\tau</em>{i}}-\sqrt{1-\alpha_{\tau_{i}}}\mathbf{\epsilon}<em>\theta(\mathbf{x}</em>{\tau_{i}}, \tau_{i})}{\sqrt{\alpha_{\tau_{i}}}}\Big) + \sqrt{1 - \alpha_{\tau_{i-1}} - \sigma_{\tau_{i}}^2} \cdot \mathbf{\epsilon}<em>\theta(\mathbf{x}</em>{\tau_{i}}, \tau_{i})+\sigma_{\tau_{i}}\epsilon\</span></p>
<p>其实上述的加速，我们是将前向过程按如下方式进行了分解：</p>
<p><span class="math-inline">q_{\sigma,\tau}(\mathbf{x}<em>{1:T} \vert \mathbf{x}_0) = q</em>{\sigma,\tau}(\mathbf{x}<em>{T} \vert \mathbf{x}_0)\prod^S</em>{i=1} q_{\sigma}(\mathbf{x}<em>{\tau</em>{i-1}} \vert \mathbf{x}<em>{\tau</em>{i}},\mathbf{x}<em>{0})\prod</em>{t\in \bar\tau}q_{\sigma,\tau}(\mathbf{x}<em>{t}\vert \mathbf{x}</em>{0}) \</span></p>
<p>其中<span class="math-inline">\bar\tau={1,...,T}\backslash \tau</span>。这包含了两个图：其中一个就是由<span class="math-inline">{\mathbf{x}<em>{\tau_i}}</em>{i=1}^S</span> 成的马尔可夫链，另外一个是剩余的变量<span class="math-inline">{\mathbf{x}<em>{t}}</em>{t\in \bar\tau}</span> 成的星状图。同时生成过程，我们也只用马尔可夫链的那部分来生成：</p>
<p><span class="math-inline">p_\theta(\mathbf{x}<em>{0:T}) = p(\mathbf{x}_T) \underbrace {\prod^S</em>{i=1} p_\theta(\mathbf{x}<em>{\tau</em>{i-1}} \vert \mathbf{x}<em>{\tau</em>{i}})}<em>{\text{use to produce sample}} \times \underbrace {\prod</em>{t\in \bar\tau}p_\theta(\mathbf{x}<em>{0} \vert \mathbf{x}</em>{t})}_{\text {only for VLB}} \</span></p>
<p>论文共设计了两种方法来采样子序列，分别是：</p>
<ul>
<li><strong>Linear</strong>：采用线性的序列<span class="math-inline">\tau_i=\lfloor ci\rfloor</span>；</li>
<li><strong>Quadratic</strong>：采样二次方的序列<span class="math-inline">\tau_i=\lfloor ci^2\rfloor</span>；</li>
</ul>
<p>这里的<span class="math-inline">c</span> 一个定值，它的设定使得<span class="math-inline">\tau_{-1}</span> 接近<span class="math-inline">T</span>。论文中只对CIFAR10数据集采用<strong>Quadratic</strong>序列，其它数据集均采用<strong>Linear</strong>序列。</p>
<h2 id="实验结果">实验结果<a class="anchor-link" href="#实验结果" title="Permanent link">&para;</a></h2>
<p>下表为不同的<span class="math-inline">\eta</span> 以及不同采样步数下的对比结果，可以看到DDIM（<span class="math-inline">\eta=0</span>）在较短的步数下就能得到比较好的效果，媲美DDPM（<span class="math-inline">\eta=1</span>）的生成效果。如果<span class="math-inline">S</span> 置为50，那么相比原来的生成过程就可以加速20倍。 </p>
<p><img alt="" src="https://markdownimg-hw.oss-cn-beijing.aliyuncs.com/202410312116808.jpg" />  </p>
<h2 id="代码实现">代码实现<a class="anchor-link" href="#代码实现" title="Permanent link">&para;</a></h2>
<p>DDIM和DDPM的训练过程一样，所以可以直接在DDPM的基础上加一个新的生成方法（这里主要参考了<a href="https://github.com/ermongroup/ddim">https://github.com/ermongroup/ddim</a>以及<a href="https://github.com/huggingface/diffusers/blob/main/src/diffusers/schedulers/scheduling_ddim.py">https://github.com/huggingface/diffusers/blob/main/src/diffusers/schedulers/scheduling_ddim.py</a>），具体代码如下所示：</p>
<pre><code>class GaussianDiffusion:
    def __init__(self, timesteps=1000, beta_schedule='linear'):
     pass

    # ...

 # use ddim to sample
    @torch.no_grad()
    def ddim_sample(
        self,
        model,
        image_size,
        batch_size=8,
        channels=3,
        ddim_timesteps=50,
        ddim_discr_method=&quot;uniform&quot;,
        ddim_eta=0.0,
        clip_denoised=True):
        # make ddim timestep sequence
        if ddim_discr_method == 'uniform':
            c = self.timesteps // ddim_timesteps
            ddim_timestep_seq = np.asarray(list(range(0, self.timesteps, c)))
        elif ddim_discr_method == 'quad':
            ddim_timestep_seq = (
                (np.linspace(0, np.sqrt(self.timesteps * .8), ddim_timesteps)) ** 2
            ).astype(int)
        else:
            raise NotImplementedError(f'There is no ddim discretization method called &quot;{ddim_discr_method}&quot;')
        # add one to get the final alpha values right (the ones from first scale to data during sampling)
        ddim_timestep_seq = ddim_timestep_seq + 1
        # previous sequence
        ddim_timestep_prev_seq = np.append(np.array([0]), ddim_timestep_seq[:-1])

        device = next(model.parameters()).device
        # start from pure noise (for each example in the batch)
        sample_img = torch.randn((batch_size, channels, image_size, image_size), device=device)
        for i in tqdm(reversed(range(0, ddim_timesteps)), desc='sampling loop time step', total=ddim_timesteps):
            t = torch.full((batch_size,), ddim_timestep_seq[i], device=device, dtype=torch.long)
            prev_t = torch.full((batch_size,), ddim_timestep_prev_seq[i], device=device, dtype=torch.long)

            # 1. get current and previous alpha_cumprod
            alpha_cumprod_t = self._extract(self.alphas_cumprod, t, sample_img.shape)
            alpha_cumprod_t_prev = self._extract(self.alphas_cumprod, prev_t, sample_img.shape)

            # 2. predict noise using model
            pred_noise = model(sample_img, t)

            # 3. get the predicted x_0
            pred_x0 = (sample_img - torch.sqrt((1. - alpha_cumprod_t)) * pred_noise) / torch.sqrt(alpha_cumprod_t)
            if clip_denoised:
                pred_x0 = torch.clamp(pred_x0, min=-1., max=1.)

            # 4. compute variance: &quot;sigma_t(η)&quot; -&gt; see formula (16)
            # σ_t = sqrt((1 − α_t−1)/(1 − α_t)) * sqrt(1 − α_t/α_t−1)
            sigmas_t = ddim_eta * torch.sqrt(
                (1 - alpha_cumprod_t_prev) / (1 - alpha_cumprod_t) * (1 - alpha_cumprod_t / alpha_cumprod_t_prev))

            # 5. compute &quot;direction pointing to x_t&quot; of formula (12)
            pred_dir_xt = torch.sqrt(1 - alpha_cumprod_t_prev - sigmas_t**2) * pred_noise

            # 6. compute x_{t-1} of formula (12)
            x_prev = torch.sqrt(alpha_cumprod_t_prev) * pred_x0 + pred_dir_xt + sigmas_t * torch.randn_like(sample_img)

            sample_img = x_prev

        return sample_img.cpu().numpy()

</code></pre>
<p>这里以MNIST数据集为例，训练的扩散步数为500，直接采用DDPM（即推理500次）生成的样本如下所示： </p>
<p><img alt="" src="https://markdownimg-hw.oss-cn-beijing.aliyuncs.com/202410312116809.jpg" /><br />
 同样的模型，我们采用DDIM来加速生成过程，这里DDIM的采样步数为50，其生成的样本质量和500步的DDPM相当： </p>
<p><img alt="" src="https://markdownimg-hw.oss-cn-beijing.aliyuncs.com/202410312116810.jpg" /><br />
 完整的代码示例见<a href="https://github.com/xiaohu2015/nngen">https://github.com/xiaohu2015/nngen</a>。</p>
<h2 id="其它重建和插值">其它：重建和插值<a class="anchor-link" href="#其它重建和插值" title="Permanent link">&para;</a></h2>
<p>在DDIM论文中，还额外讨论了两个小点的内容<strong>：重建和插值</strong>。所谓重建是指的首先用原始图像求逆得到对应的噪音然后再进行生成的过程；而插值是指的对两个随机噪音进行插值从而得到融合两种噪音的图像。 首先是重建，对于DDIM，其<span class="math-inline">\eta=0</span>，这个时候从<span class="math-inline">\mathbf{x}<em>{t}</span> 成<span class="math-inline">\mathbf{x}</em>{t-1}</span> 更新公式就变为：</p>
<p><span class="math-inline">\mathbf{x}<em>{t-1}  = \sqrt{\alpha</em>{t-1}}\Big(\frac{\mathbf{x}<em>t-\sqrt{1-\alpha</em>{t}}\mathbf{\epsilon}<em>\theta(\mathbf{x}_t, t)}{\sqrt{\alpha</em>{t}}}\Big)+ \sqrt{1 - \alpha_{t-1}} \cdot \mathbf{\epsilon}_\theta(\mathbf{x}_t, t)\</span></p>
<p>我们进一步对上述公式进行变换可得到：</p>
<p><span class="math-inline">\frac{\mathbf{x}<em>{t-1}}{\sqrt{\alpha</em>{t-1}}} = \frac{\mathbf{x}<em>t}{\sqrt{\alpha</em>{t}}} +  \Big(\sqrt{\frac{1-\alpha_{t-1}}{\alpha_{t-1}}} - \sqrt{\frac{1-\alpha_{t}}{\alpha_{t}}} \Big)\mathbf{\epsilon}_\theta(\mathbf{x}_t, t) \</span></p>
<p>当<span class="math-inline">T</span> 够大时，以上公式其实可以看成用欧拉法来求解一个<strong>常微分方程</strong>（<strong>ODE</strong>，ordinary differential equation）：</p>
<p><span class="math-inline">\frac{\mathbf{x}<em>{t-\Delta t}}{\sqrt{\alpha</em>{t-\Delta t}}} = \frac{\mathbf{x}<em>t}{\sqrt{\alpha</em>{t}}} +  \Big(\sqrt{\frac{1-\alpha_{t-\Delta t}}{\alpha_{t-\Delta t}}} - \sqrt{\frac{1-\alpha_{t}}{\alpha_{t}}} \Big)\mathbf{\epsilon}_\theta(\mathbf{x}_t, t) \</span></p>
<p>这里令<span class="math-inline">\sigma=\sqrt{1-\alpha}/\sqrt{\alpha}</span>，<span class="math-inline">\bar{\mathbf{x}}=\mathbf{x}/\sqrt{\alpha}</span>，它们都是关于<span class="math-inline">t</span> 函数，这样对应的ODE就是：</p>
<p><span class="math-inline">\text{d}\bar{\mathbf{x}}(t)=\mathbf{\epsilon}_\theta(\frac{\bar{\mathbf{x}}(t)}{\sqrt{\sigma^2+1}}, t)\text{d}\sigma(t) \</span></p>
<p>看成ODE后，我们可以利用如下公式对生成过程进行逆操作：</p>
<p><span class="math-inline">\frac{\mathbf{x}<em>{t+1}}{\sqrt{\alpha</em>{t+1}}} = \frac{\mathbf{x}<em>t}{\sqrt{\alpha</em>{t}}} +  \Big(\sqrt{\frac{1-\alpha_{t+1}}{\alpha_{t+1}}} - \sqrt{\frac{1-\alpha_{t}}{\alpha_{t}}} \Big)\mathbf{\epsilon}_\theta(\mathbf{x}_t, t) \</span></p>
<p>这意味着，我们可以由一个原始图像<span class="math-inline">\mathbf{x}_0</span> 到对应的随机噪音<span class="math-inline">\mathbf{x}_T</span>，然后我们再用<span class="math-inline">\mathbf{x}_T</span> 行生成就可以重建原始图像<span class="math-inline">\mathbf{x}_0</span>(具体的代码实现见<a href="https://github.com/openai/improved-diffusion/blob/main/improved_diffusion/gaussian_diffusion.py#L524-L560">https://github.com/openai/improved-diffusion/blob/main/improved_diffusion/gaussian_diffusion.py#L524-L560</a>）。论文也通过在CIFAR10测试集上的实验来证明当步数足够时，这种方式可以得到较低的重建误差： </p>
<p><img alt="" src="https://markdownimg-hw.oss-cn-beijing.aliyuncs.com/202410312116811.jpg" /><br />
 第二个插值，对于DDIM，两个不同的随机噪音会产生不同的图像，但是如果我们对这两个随机噪音进行插值生成新的<span class="math-inline">\mathbf{x}_T</span>，那么将生成融合的图像。这里采用的插值方法是<strong>球面线性插值</strong>（ spherical linear interpolation）：</p>
<p><span class="math-inline">\mathbf{x}_T^{(\alpha)}=\frac{\sin ((1-\alpha)\theta)}{\sin (\theta)}\mathbf{x}_T^{(0)}+\frac{\sin (\alpha\theta)}{\sin (\theta)}\mathbf{x}_T^{(1)} \quad \theta = \arccos\Big(\frac{(\mathbf{x}_T^{(0)})^\text{T}\mathbf{x}_T^{(1)}}{| \mathbf{x}_T^{(0)}||\mathbf{x}_T^{(1)}|}\Big) \</span></p>
<p>这里的参数<span class="math-inline">\alpha\in[0,1]</span> 制插值系数，具体的代码实现见<a href="https://github.com/ermongroup/ddim/blob/main/runners/diffusion.py#L296-L334">https://github.com/ermongroup/ddim/blob/main/runners/diffusion.py#L296-L334</a>。下图展示了一些具体的插值效果： </p>
<p><img alt="" src="https://markdownimg-hw.oss-cn-beijing.aliyuncs.com/202410312116812.jpg" /><br />
DDIM的重建和插值也在文本转图像模型DALLE-2中使用，不过这里插值的是扩散模型的条件CLIP image embedding，详情见论文<strong><a href="https://arxiv.org/abs/2204.06125">https://arxiv.org/abs/2204.06125</a></strong>。 </p>
<p><img alt="" src="https://markdownimg-hw.oss-cn-beijing.aliyuncs.com/202410312116813.jpg" /><br />
<img alt="" src="https://markdownimg-hw.oss-cn-beijing.aliyuncs.com/202410312116814.jpg" /><br />
<img alt="" src="https://markdownimg-hw.oss-cn-beijing.aliyuncs.com/202410312116815.jpg" />  </p>
<h2 id="小结">小结<a class="anchor-link" href="#小结" title="Permanent link">&para;</a></h2>
<p>如果从直观上看，DDIM的加速方式非常简单，直接采样一个子序列，其实论文<a href="https://arxiv.org/abs/2102.09672">https://arxiv.org/abs/2102.09672</a>也采用了类似的方式来加速。另外DDIM和其它扩散模型的一个较大的区别是其生成过程是确定性的。</p>
<h2 id="参考">参考<a class="anchor-link" href="#参考" title="Permanent link">&para;</a></h2>
<ul>
<li><a href="https://arxiv.org/abs/2010.02502">https://arxiv.org/abs/2010.02502</a></li>
<li><a href="https://github.com/ermongroup/ddim">https://github.com/ermongroup/ddim</a></li>
<li><a href="https://github.com/openai/improved-diffusion">https://github.com/openai/improved-diffusion</a></li>
<li><a href="https://github.com/huggingface/diffusers/blob/main/src/diffusers/schedulers/scheduling_ddim.py">https://github.com/huggingface/diffusers/blob/main/src/diffusers/schedulers/scheduling_ddim.py</a></li>
<li><a href="https://github.com/CompVis/latent-diffusion/blob/main/ldm/models/diffusion/ddim.py">https://github.com/CompVis/latent-diffusion/blob/main/ldm/models/diffusion/ddim.py</a></li>
<li><a href="https://kexue.fm/archives/9181">https://kexue.fm/archives/9181</a></li>
</ul>
                </div>

                <!-- Comments Section (Giscus) -->
                <section class="comments-section">
                    <h3><i class="fas fa-comments"></i> 评论</h3>
                    <script src="https://giscus.app/client.js"
                        data-repo="Geeks-Z/Geeks-Z.github.io"
                        data-repo-id=""
                        data-category="Announcements"
                        data-category-id=""
                        data-mapping="pathname"
                        data-strict="0"
                        data-reactions-enabled="1"
                        data-emit-metadata="0"
                        data-input-position="bottom"
                        data-theme="preferred_color_scheme"
                        data-lang="zh-CN"
                        crossorigin="anonymous"
                        async>
                    </script>
                </section>
            </article>

            <footer class="post-footer">
                <p>© 2025 Hongwei Zhao. Built with ❤️</p>
            </footer>
        </main>
    </div>

    <!-- Theme Toggle Button -->
    <button class="theme-toggle" id="themeToggle" aria-label="切换主题">
        <i class="fas fa-moon"></i>
    </button>

    <script>
        // Theme Toggle
        const themeToggle = document.getElementById('themeToggle');
        const html = document.documentElement;
        const icon = themeToggle.querySelector('i');
        const hljsDark = document.getElementById('hljs-theme-dark');
        const hljsLight = document.getElementById('hljs-theme-light');
        
        // Check saved theme or system preference
        const savedTheme = localStorage.getItem('theme');
        const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
        
        if (savedTheme === 'dark' || (!savedTheme && prefersDark)) {
            html.setAttribute('data-theme', 'dark');
            icon.className = 'fas fa-sun';
            hljsDark.disabled = false;
            hljsLight.disabled = true;
        }
        
        themeToggle.addEventListener('click', () => {
            const isDark = html.getAttribute('data-theme') === 'dark';
            if (isDark) {
                html.removeAttribute('data-theme');
                icon.className = 'fas fa-moon';
                localStorage.setItem('theme', 'light');
                hljsDark.disabled = true;
                hljsLight.disabled = false;
            } else {
                html.setAttribute('data-theme', 'dark');
                icon.className = 'fas fa-sun';
                localStorage.setItem('theme', 'dark');
                hljsDark.disabled = false;
                hljsLight.disabled = true;
            }
            
            // Update Giscus theme
            const giscusFrame = document.querySelector('iframe.giscus-frame');
            if (giscusFrame) {
                giscusFrame.contentWindow.postMessage({
                    giscus: {
                        setConfig: {
                            theme: isDark ? 'light' : 'dark'
                        }
                    }
                }, 'https://giscus.app');
            }
        });
        
        // Highlight.js
        document.addEventListener('DOMContentLoaded', () => {
            hljs.highlightAll();
        });
        
        // KaTeX auto-render
        document.addEventListener('DOMContentLoaded', () => {
            if (typeof renderMathInElement !== 'undefined') {
                renderMathInElement(document.body, {
                    delimiters: [
                        {left: '$$', right: '$$', display: true},
                        {left: '$', right: '$', display: false},
                        {left: '\\[', right: '\\]', display: true},
                        {left: '\\(', right: '\\)', display: false}
                    ],
                    throwOnError: false
                });
            }
        });
        
        // TOC active state
        const tocLinks = document.querySelectorAll('.toc-container a');
        const headings = document.querySelectorAll('.post-content h2, .post-content h3, .post-content h4');
        
        function updateTocActive() {
            let current = '';
            headings.forEach(heading => {
                const rect = heading.getBoundingClientRect();
                if (rect.top <= 100) {
                    current = heading.getAttribute('id');
                }
            });
            
            tocLinks.forEach(link => {
                link.classList.remove('active');
                if (link.getAttribute('href') === '#' + current) {
                    link.classList.add('active');
                }
            });
        }
        
        window.addEventListener('scroll', updateTocActive);
        updateTocActive();
    </script>
</body>
</html>
