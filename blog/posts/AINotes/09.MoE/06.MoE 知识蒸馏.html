<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Untitled</title>
    <meta name="description" content="Untitled - Hongwei Zhao's Blog">
    <meta name="author" content="Hongwei Zhao">
    
    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Noto+Sans+SC:wght@300;400;500;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    
    <!-- Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <!-- Code Highlighting -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css" id="hljs-theme-dark">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css" id="hljs-theme-light" disabled>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    
    <!-- KaTeX for Math -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>
    
    <style>
        :root {
            /* Light Theme - 明亮清新配色 */
            --primary-color: #4A90D9;
            --primary-hover: #3678C2;
            --link-color: #E86B5F;
            --text-color: #2D2D2D;
            --text-light: #5A5A5A;
            --text-muted: #8A8A8A;
            --bg-color: #FFFFFF;
            --bg-secondary: #F5F7FA;
            --bg-code: #F8F9FC;
            --border-color: #E8ECF0;
            --shadow: 0 2px 8px rgba(0,0,0,0.06);
            --shadow-lg: 0 8px 24px rgba(0,0,0,0.08);
        }

        [data-theme="dark"] {
            --primary-color: #5dade2;
            --primary-hover: #85c1e9;
            --link-color: #e74c3c;
            --text-color: #e5e7eb;
            --text-light: #9ca3af;
            --text-muted: #6b7280;
            --bg-color: #1a1a2e;
            --bg-secondary: #16213e;
            --bg-code: #0f0f23;
            --border-color: #374151;
            --shadow: 0 1px 3px rgba(0,0,0,0.3);
            --shadow-lg: 0 4px 15px rgba(0,0,0,0.4);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            scroll-behavior: smooth;
        }

        body {
            font-family: 'Inter', 'Noto Sans SC', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            font-size: 16px;
            line-height: 1.8;
            color: var(--text-color);
            background: var(--bg-color);
            transition: background-color 0.3s, color 0.3s;
        }

        a {
            color: var(--primary-color);
            text-decoration: none;
            transition: color 0.2s;
        }

        a:hover {
            color: var(--primary-hover);
            text-decoration: underline;
        }

        /* Layout */
        .page-wrapper {
            display: flex;
            max-width: 1400px;
            margin: 0 auto;
            padding: 2rem;
            gap: 3rem;
        }

        /* Sidebar TOC */
        .toc-sidebar {
            width: 260px;
            flex-shrink: 0;
            position: sticky;
            top: 2rem;
            height: fit-content;
            max-height: calc(100vh - 4rem);
            overflow-y: auto;
        }

        .toc-container {
            background: var(--bg-secondary);
            border-radius: 12px;
            padding: 1.5rem;
            border: 1px solid var(--border-color);
        }

        .toc-container h3 {
            font-size: 0.85rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-muted);
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .toc-container ul {
            list-style: none;
        }

        .toc-container li {
            margin-bottom: 0.5rem;
        }

        .toc-container a {
            font-size: 0.9rem;
            color: var(--text-light);
            display: block;
            padding: 0.25rem 0;
            border-left: 2px solid transparent;
            padding-left: 0.75rem;
            transition: all 0.2s;
        }

        .toc-container a:hover,
        .toc-container a.active {
            color: var(--primary-color);
            border-left-color: var(--primary-color);
            text-decoration: none;
        }

        .toc-container ul ul {
            margin-left: 1rem;
        }

        /* Main Content */
        .main-content {
            flex: 1;
            min-width: 0;
            max-width: 800px;
        }

        /* Header */
        .post-header {
            margin-bottom: 2rem;
            padding-bottom: 1.5rem;
            border-bottom: 1px solid var(--border-color);
        }

        .back-link {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.9rem;
            color: var(--text-light);
            margin-bottom: 1.5rem;
        }

        .back-link:hover {
            color: var(--primary-color);
            text-decoration: none;
        }

        .post-header h1 {
            font-size: 2.25rem;
            font-weight: 700;
            line-height: 1.3;
            margin-bottom: 1rem;
            color: var(--text-color);
        }

        .post-meta {
            display: flex;
            flex-wrap: wrap;
            gap: 1.5rem;
            font-size: 0.9rem;
            color: var(--text-light);
        }

        .post-meta span {
            display: flex;
            align-items: center;
            gap: 0.4rem;
        }

        .post-meta i {
            color: var(--text-muted);
        }

        .tags {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-top: 1rem;
        }

        .tag {
            display: inline-block;
            font-size: 0.8rem;
            background: var(--bg-secondary);
            color: var(--text-light);
            padding: 0.25rem 0.75rem;
            border-radius: 20px;
            border: 1px solid var(--border-color);
            transition: all 0.2s;
        }

        .tag:hover {
            background: var(--primary-color);
            color: white;
            border-color: var(--primary-color);
        }

        /* Article Content */
        .post-content {
            font-size: 1rem;
            line-height: 1.9;
        }

        .post-content h1,
        .post-content h2,
        .post-content h3,
        .post-content h4,
        .post-content h5,
        .post-content h6 {
            margin-top: 2rem;
            margin-bottom: 1rem;
            font-weight: 600;
            line-height: 1.4;
            color: var(--text-color);
        }

        .post-content h1 { font-size: 1.875rem; }
        .post-content h2 { 
            font-size: 1.5rem; 
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--border-color);
        }
        .post-content h3 { font-size: 1.25rem; }
        .post-content h4 { font-size: 1.125rem; }

        .post-content p {
            margin-bottom: 1.25rem;
        }

        .post-content ul,
        .post-content ol {
            margin: 1.25rem 0;
            padding-left: 1.5rem;
        }

        .post-content li {
            margin-bottom: 0.5rem;
        }

        .post-content blockquote {
            margin: 1.5rem 0;
            padding: 1rem 1.5rem;
            background: var(--bg-secondary);
            border-left: 4px solid var(--primary-color);
            border-radius: 0 8px 8px 0;
            color: var(--text-light);
            font-style: italic;
        }

        .post-content blockquote p:last-child {
            margin-bottom: 0;
        }

        /* Code */
        .post-content code {
            font-family: 'JetBrains Mono', 'Fira Code', Consolas, monospace;
            font-size: 0.9em;
            background: var(--bg-code);
            padding: 0.2em 0.4em;
            border-radius: 4px;
            color: var(--link-color);
        }

        .post-content pre {
            margin: 1.5rem 0;
            padding: 1.25rem;
            background: var(--bg-code);
            border-radius: 10px;
            overflow-x: auto;
            border: 1px solid var(--border-color);
        }

        .post-content pre code {
            background: none;
            padding: 0;
            color: inherit;
            font-size: 0.875rem;
            line-height: 1.6;
        }

        /* Images */
        .post-content img {
            max-width: 100%;
            height: auto;
            border-radius: 10px;
            margin: 1.5rem 0;
            box-shadow: var(--shadow-lg);
        }

        /* Tables */
        .post-content table {
            width: 100%;
            margin: 1.5rem 0;
            border-collapse: collapse;
            font-size: 0.95rem;
        }

        .post-content th,
        .post-content td {
            padding: 0.75rem 1rem;
            border: 1px solid var(--border-color);
            text-align: left;
        }

        .post-content th {
            background: var(--bg-secondary);
            font-weight: 600;
        }

        .post-content tr:nth-child(even) {
            background: var(--bg-secondary);
        }

        /* Math */
        .math-display {
            margin: 1.5rem 0;
            overflow-x: auto;
            padding: 1rem;
            background: var(--bg-secondary);
            border-radius: 8px;
        }

        /* Anchor links */
        .anchor-link {
            opacity: 0;
            margin-left: 0.5rem;
            color: var(--text-muted);
            font-weight: 400;
            transition: opacity 0.2s;
        }

        .post-content h2:hover .anchor-link,
        .post-content h3:hover .anchor-link,
        .post-content h4:hover .anchor-link {
            opacity: 1;
        }

        /* Theme Toggle */
        .theme-toggle {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: var(--primary-color);
            color: white;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.25rem;
            box-shadow: var(--shadow-lg);
            transition: transform 0.2s, background 0.2s;
            z-index: 1000;
        }

        .theme-toggle:hover {
            transform: scale(1.1);
            background: var(--primary-hover);
        }

        /* Comments Section */
        .comments-section {
            margin-top: 3rem;
            padding-top: 2rem;
            border-top: 1px solid var(--border-color);
        }

        .comments-section h3 {
            font-size: 1.25rem;
            margin-bottom: 1.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        /* Footer */
        .post-footer {
            margin-top: 3rem;
            padding-top: 1.5rem;
            border-top: 1px solid var(--border-color);
            text-align: center;
            font-size: 0.9rem;
            color: var(--text-muted);
        }

        /* Responsive */
        @media (max-width: 1024px) {
            .toc-sidebar {
                display: none;
            }
            
            .page-wrapper {
                padding: 1.5rem;
            }
        }

        @media (max-width: 768px) {
            .post-header h1 {
                font-size: 1.75rem;
            }
            
            .post-meta {
                flex-direction: column;
                gap: 0.5rem;
            }
            
            .theme-toggle {
                bottom: 1rem;
                right: 1rem;
                width: 44px;
                height: 44px;
            }
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-secondary);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--text-muted);
        }
    </style>
</head>
<body>
    <div class="page-wrapper">
        <!-- TOC Sidebar -->
        <aside class="toc-sidebar">
            <div class="toc-container">
                <h3><i class="fas fa-list"></i> 目录</h3>
                <div class="toc">
<ul>
<li><a href="#one-student-knows-all-experts-know-from-sparse-to-dense">One Student Knows All Experts Know: From Sparse to Dense</a></li>
<li><a href="#太长不看版">太长不看版</a></li>
<li><a href="#1-背景稀疏-moe-模型虽强大却难以部署">1 背景：稀疏 MoE 模型虽强大却难以部署</a></li>
<li><a href="#2-moe-基本介绍">2 MoE 基本介绍</a></li>
<li><a href="#3-知识整合的问题定义">3 知识整合的问题定义</a></li>
<li><a href="#4-第一阶段知识整合">4 第一阶段：知识整合</a></li>
<li><a href="#5-第二阶段知识蒸馏">5 第二阶段：知识蒸馏</a></li>
<li><a href="#6-视觉任务实验结果">6 视觉任务实验结果</a></li>
<li><a href="#7-文本任务实验结果">7 文本任务实验结果</a></li>
<li><a href="#8-消融实验结果">8 消融实验结果</a></li>
<li><a href="#references">References</a></li>
<li><a href="#kimi全文翻译-arrow_down">Kimi全文翻译 :arrow_down:</a></li>
<li><a href="#0-摘要">0. 摘要</a></li>
<li><a href="#1-引言">1. 引言</a></li>
<li><a href="#2-预备知识">2. 预备知识</a><ul>
<li><a href="#21-专家混合">2.1. 专家混合</a></li>
<li><a href="#22-问题公式化">2.2. 问题公式化</a></li>
</ul>
</li>
<li><a href="#3-方法">3. 方法</a><ul>
<li><a href="#31-从-moe-中收集知识">3.1. 从 MoE 中收集知识</a><ul>
<li><a href="#311-求和与平均">3.1.1 求和与平均</a></li>
</ul>
</li>
<li><a href="#32-top-k-知识收集">3.2. Top-K 知识收集</a><ul>
<li><a href="#321-svd-知识收集">3.2.1 SVD 知识收集</a></li>
</ul>
</li>
<li><a href="#33-知识蒸馏">3.3. 知识蒸馏</a></li>
<li><a href="#34-优化">3.4. 优化</a></li>
</ul>
</li>
<li><a href="#4-实验">4. 实验</a><ul>
<li><a href="#41-计算机视觉">4.1. 计算机视觉</a><ul>
<li><a href="#实验设置">实验设置</a></li>
<li><a href="#411-imagenet-上的结果">4.1.1 ImageNet 上的结果</a></li>
<li><a href="#412-cifar10-上的结果">4.1.2 Cifar10 上的结果</a></li>
</ul>
</li>
<li><a href="#42-自然语言处理">4.2. 自然语言处理</a><ul>
<li><a href="#实验设置_1">实验设置</a></li>
<li><a href="#421-nlu-基准上的结果">4.2.1 NLU 基准上的结果</a></li>
</ul>
</li>
<li><a href="#43-消融研究">4.3. 消融研究</a></li>
</ul>
</li>
<li><a href="#5-结论和未来工作">5. 结论和未来工作</a></li>
</ul>
</div>

            </div>
        </aside>

        <!-- Main Content -->
        <main class="main-content">
            <article>
                <header class="post-header">
                    <a href="../../../index.html" class="back-link">
                        <i class="fas fa-arrow-left"></i> 返回博客列表
                    </a>
                    <h1>Untitled</h1>
                    <div class="post-meta">
                        <span><i class="fas fa-calendar-alt"></i> 2026-02-04</span>
                        <span><i class="fas fa-folder"></i> AINotes/09.MoE</span>
                        <span><i class="fas fa-user"></i> Hongwei Zhao</span>
                    </div>
                    <div class="tags">
                        
                    </div>
                </header>

                <div class="post-content">
                    <h2 id="one-student-knows-all-experts-know-from-sparse-to-dense">One Student Knows All Experts Know: From Sparse to Dense<a class="anchor-link" href="#one-student-knows-all-experts-know-from-sparse-to-dense" title="Permanent link">&para;</a></h2>
<blockquote>
<p><a href="https://arxiv.org/pdf/2201.10890.pdf">One Student Knows All Experts Know: From Sparse to Dense</a></p>
</blockquote>
<h2 id="太长不看版">太长不看版<a class="anchor-link" href="#太长不看版" title="Permanent link">&para;</a></h2>
<p>人类教育系统由多个 Expert 来训练一位 Student。专家混合 (Mixture-of-experts, MoE) 是一种强大的稀疏架构，包括多个 Expert 模型。但是，MoE 的架构容易过拟合，难以部署，对业界其实并不友好。</p>
<p>这个工作受到人类教育的启发，作者提出了一种新的任务<strong>：知识整合</strong> (Knowledge Integration)，本文的方法分为2步<strong>：知识聚合 (Knowledge Gathering) 和知识蒸馏 (Knowledge Distillation)</strong>。使用稀疏的教师模型来蒸馏密集的学生模型。学生是一个密集的模型，从不同 Expert 那里获取知识。</p>
<p>为了从不同的预训练 Expert 那里有效地收集知识，本文研究了4种不同的可能的知识收集方法，即 Summation, Averaging, Top-K Knowledge Gathering (Top-KG), 和 Singular Value Decomposition Knowledge Gathering (SVD-KG)。然后再通过知识蒸馏精炼密集的学生模型。</p>
<h2 id="1-背景稀疏-moe-模型虽强大却难以部署">1 背景：稀疏 MoE 模型虽强大却难以部署<a class="anchor-link" href="#1-背景稀疏-moe-模型虽强大却难以部署" title="Permanent link">&para;</a></h2>
<p>回顾一个研究员，一路走来的学习历程，大多数人都是从多个教师 (即 Expert 那里) 学习到不同的知识。受人类教育的启发，这项工作侧重于通过一组 Expert 的知识来训练一个强大的学生模型。</p>
<div align=center><img src="https://markdownimg-hw.oss-cn-beijing.aliyuncs.com/20241105110119.png" /></div>

<p>在 MoE 中，每个 Expert 都是整个模型中的一个子神经网络。对于输入的每个子集，只有一个特定的子网络被激活，MoE 的这种稀疏计算的方式使我们能够将模型扩展到万亿参数的规模。</p>
<p>但是，MoE 方法也有问题，比如很容易过拟合。使用 MoE 模型时，我们通常在大型数据集上预训练 MoE，然后在各种下游任务上去做微调。在大多数情况下，这些下游任务才是我们想要解决的目标问题。MoE 的应用存在下面3大问题：</p>
<p>第一，<strong>容易过拟合</strong>。与 Dense 的模型相比，稀疏模型更多的可训练参数和稀疏的条件计算会引入过拟合，尤其是当数据集的规模不够大的时候。</p>
<p>第二，<strong>比较难部署</strong>。即使我们成功地训练了一个 MoE 模型，它其实也是很难部署的。对于参数量达到数万亿规模的 MoE 模型，我们就需要在不同设备 (GPU, TPU) 上面部署不同的专家来减小设备上的内存消耗。</p>
<p>第三，<strong>MoE 模型硬件不友好，专家并行性代价高昂</strong>。对于 GPU 集群，all-to-all 操作太慢，无法扩大 MoE 模型。而且，门控函数包括许多创建 token mask 的操作，选择 top-k Expert 并寻找每个 Expert 的输入 token 的 id。由于 tensor 的稀疏表示，所有这些操作都很浪费。</p>
<p>总之，稀疏 MoE 虽然强大，但是在实践中相对难以使用。密集的模型能力稍差，但是却容易使用，因此，本文希望结合稀疏模型的能力来训练高效又易于使用的密集模型。</p>
<h2 id="2-moe-基本介绍">2 MoE 基本介绍<a class="anchor-link" href="#2-moe-基本介绍" title="Permanent link">&para;</a></h2>
<p><strong>MoE 的基本概念和定义</strong></p>
<p>给定一个具有 <span class="math-inline">E</span> 个可训练的 Expert 和输入 <span class="math-inline">x\in \mathbb{R}^D</span> 的 MoE 模型，模型的输出可以表示为：</p>
<p><div class="math-display">\begin{equation} \mathrm{MoE}(x)=\sum_{i=1}^E {G(x)}_i {e_i(x)} \end{equation} \tag{1}</div><br />
式中， <span class="math-inline">e_i:\mathbb{R}^D \to \mathbb{R}^D</span> 表示第 <span class="math-inline">i</span> 个 Expert， <span class="math-inline">{G(\cdot)}:\mathbb{R}^D \to \mathbb{R}^E</span> 表示门控网络， <span class="math-inline">{G(x)}_i</span> 是第 <span class="math-inline">i</span> 个 Expert 的路由权重。通常， <span class="math-inline">e(\cdot)</span> 和 <span class="math-inline">G(\cdot)</span> 都由神经网络参数化，且 <span class="math-inline">G(\cdot)</span> 的输出应由 Softmax 函数激活：</p>
<p><div class="math-display">\begin{equation} \mathrm{G}(x)=\mathrm{topK}(\omega(h(x)+\epsilon)) \end{equation} \tag{2}</div>  </p>
<p>式中， <span class="math-inline">\omega</span> 是 Softmax 函数， <span class="math-inline">h(\cdot):\mathbb{R}^D \to \mathbb{R}^E</span> 是线性层， <span class="math-inline">\epsilon \sim \mathcal{N}(0,\frac{1}{E^2})</span> 是高斯噪声，其中，选择 <span class="math-inline">\mathrm{topK}</span> 的 Expert 来激活是 MoE 的关键模块。通常将 <span class="math-inline">K</span> 设置为 1 或 2，以便模型整体的计算成本和相应的密集模型相当。</p>
<p><strong>MoE 的常见目标函数</strong></p>
<p>在训练 MoE 模型时，如果我们不加任何的正则化策略，大多数 token 可能会派到一小部分 Expert 里面，其他的 Expert 只会收到很少很少的 token，这种极不平衡的分配会导致 MoE 模型的效率很低且精度较差。因此，为了实现不同 Expert 的平衡工作负载，通常使用辅助的平衡损失函数：</p>
<p><div class="math-display">\begin{equation}  \mathrm{L_{balance}} = E \cdot \sum_{i=1}^E m_i \cdot P_i \end{equation} \tag{3}</div>  </p>
<p>式中， <span class="math-inline">E</span> 是 Expert 的数量， <span class="math-inline">m</span> 是个向量，其中 <span class="math-inline">m_i</span> 的定义是分配给第 <span class="math-inline">i</span> 个 Expert 的 token 的比例，表达式如下：</p>
<p><div class="math-display">\begin{equation} m_i = \frac{1}{N} \sum_{j=1}^{N} \mathrm{k}(x_j)_i \end{equation} \tag{4}</div>  </p>
<p>其中， <span class="math-inline">N</span> 是 token 的数量， <span class="math-inline">\mathrm{k}(x_j)_i</span> 是分配给第 <span class="math-inline">i</span> 个 Expert 的 token 数量。由于这个式子设计 top-k 的计算，因此是不可微的。</p>
<p><span class="math-inline">P_i</span> 的定义是路由给第 <span class="math-inline">i</span> 个 Expert 的 token 的概率，表达式如下：</p>
<p><div class="math-display">\begin{equation} P_i = \omega(h(x)+\epsilon)_i \end{equation} \tag{5}</div>  </p>
<p>当我们试图优化辅助平衡损失函数时，其实是希望 <span class="math-inline">\mathrm{G}(x)</span> 的输出是均匀分布。</p>
<h2 id="3-知识整合的问题定义">3 知识整合的问题定义<a class="anchor-link" href="#3-知识整合的问题定义" title="Permanent link">&para;</a></h2>
<p>本文的方法知识整合可以分为2步<strong>：知识聚合</strong> (Knowledge Gathering) 和<strong>知识蒸馏</strong> (Knowledge Distillation)</p>
<p>对于第1步，给定 <span class="math-inline">E</span> 个 Expert 模型 <span class="math-inline">{e_1(\cdot),e_2(\cdot),\dots,e_E(\cdot)}</span> ，希望最大化学生模型 <span class="math-inline">s(\cdot)</span> 中的知识。给定输入的表征 <span class="math-inline">x</span> ，在一个 Transformer Block 内，每个 Expert 都是一个 FFN，可以表示为：</p>
<p><div class="math-display">\begin{equation}  e_i(x)=f^{i}_{2}(\sigma(f^{i}_1(x))) \end{equation} \tag{6}</div><br />
式中， <span class="math-inline">f^{i}_1(\cdot)</span> 和 <span class="math-inline">f^{i}_2(\cdot)</span> 是第 <span class="math-inline">i</span> 个 Expert 的线性变换， <span class="math-inline">\sigma(\cdot)</span> 是激活函数。对于密集的学生模型，有相同的架构但不同的训练参数：</p>
<p><div class="math-display">\begin{equation}  s(x)=g_{2}(\sigma(g_1(x))) \end{equation} \tag{7}</div>  </p>
<p>然后目标就是根据 <span class="math-inline">{f^{1}_1,\dots, f^{E}_1}</span> 和 <span class="math-inline">{f^{1}_2,\dots, f^{E}_2}</span> 来估计 <span class="math-inline">g_1</span> 和 <span class="math-inline">g_2</span> 的参数。</p>
<p>第2个阶段是对密集的学生模型进行微调，以最小化教师输出和学生输出之间的差异。</p>
<p>本文的目标是尽可能地保留 MoE 给密集学生模型带来的帮助。因此，本文搞了个指标来衡量密集的学生模型整合 MoE 对应的知识的能力：</p>
<p><div class="math-display">\begin{equation} \mathrm{MoE~benefits}= \frac{\mathrm{score}<em>{student}-\mathrm{score}</em>{dense}}{\mathrm{score}<em>{MoE}-\mathrm{score}</em>{dense}} \end{equation} \tag{8}</div><br />
 其中， <span class="math-inline">\mathrm{score}</span> 可以是衡量模型的任何指标。 <span class="math-inline">\mathrm{score}_{dense}</span> 指直接训练密集的学生模型的性能。</p>
<h2 id="4-第一阶段知识整合">4 第一阶段：知识整合<a class="anchor-link" href="#4-第一阶段知识整合" title="Permanent link">&para;</a></h2>
<p>如下图2所示是知识整合的具体方法，整体的思路就是2步：知识聚合 (Knowledge Gathering) 和知识蒸馏 (Knowledge Distillation)。</p>
<p>在初始化学生模型的时候，大部分的参数其实是和教师模型重合的，比如 Embedding 层，Attention 层，归一化层。所以对于这些层的参数，学生模型可以直接复制教师模型的。问题的关键在于 MoE 层，MoE 层比单个 FFN 层具有更多的可学习参数，每个 Expert 都是一个有独立参数的 FFN。知识聚合的目的就是合并来自不同 FFN Expert 的知识，并将知识分配给学生模型中的单个 FFN。作者研究了4种不同的知识聚合方法，即：Summation, Averaging, Top-K Knowledge Gathering (Top-KG), 和 Singular Value Decomposition Knowledge Gathering (SVD-KG)。</p>
<div align=center><img src="https://markdownimg-hw.oss-cn-beijing.aliyuncs.com/20241105104438.png" style="zoom: 60%;" /></div>

<p>假设 <span class="math-inline">E</span> 个 Expert 的线性层为 <span class="math-inline">{f^1, f^2, \dots, f^E }</span> ，每个线性层 <span class="math-inline">f^i(\cdot):\mathbb{R}^{d_1} \to \mathbb{R}^{d_2}</span> 有权重 <span class="math-inline">W_f^i \in \mathbb{R}^{d_{1} \times d_{2}}</span> 和偏置 <span class="math-inline">b_f^i \in \mathbb{R}^{d_2}</span> 。知识聚合的目标就是：</p>
<p><div class="math-display">\begin{equation} \begin{aligned}  &amp; \mathrm{KG}(f^1, f^2, \dots, f^E) \ = &amp; \mathrm{KG}(W_f^1, W_f^2, \dots, W_f^E;b_f^1, b_f^2, \dots, b_f^E)  \ \approx &amp;(W_g ; b_g) = g \ \end{aligned} \end{equation} \tag{9}</div><br />
简单来讲就是把 <span class="math-inline">{f^1, f^2, \dots, f^E }</span> 的权重给搞成单 Expert 的权重 <span class="math-inline">g</span> 。式中， <span class="math-inline">g(\cdot):\mathbb{R}^{d_1} \to \mathbb{R}^{d_2}</span> 是线性层，有权重 <span class="math-inline">W_g \in \mathbb{R}^{d_{1} \times d_{2}}</span> 和偏置 <span class="math-inline">b_g \in \mathbb{R}^{d_2}</span> 。</p>
<p>偏置 <span class="math-inline">b_g</span> 的确定方法比较简单，这里作者直接加权平均所有 Expert 的偏置项：</p>
<p><div class="math-display">\begin{equation} b_g=\frac{1}{E} \sum_{i=1}^E b_f^i \end{equation} \tag{10}</div> <br />
采用这种简单的策略是因为可训练参数较少，存储在 bias 中的知识远小于 weight 中的知识。</p>
<p>权重 <span class="math-inline">W_g</span> 的确定方法有下面4种：</p>
<p><strong>累加 (Summation)</strong>：</p>
<p><div class="math-display">\begin{equation} W_g=\sum_{i=1}^E W_f^i \end{equation} \tag{11}</div>  </p>
<p><strong>取均值 (Averaging)</strong>：</p>
<p><div class="math-display">\begin{equation} W_g=\frac{1}{E} \sum_{i=1}^E W_f^i \end{equation} \tag{12}</div>  </p>
<p><strong>Top-K Knowledge Gathering</strong>：</p>
<p>对于第 <span class="math-inline">i</span> 个 Expert 的权重矩阵 <span class="math-inline">W^{\mathrm{i}} \in \mathbb{R}^{d_{1} \times d_{2}}</span> ，首先计算每一列的权重的范数 <span class="math-inline">l^{\mathrm{i}} \in \mathbb{R}^{d_{1}}</span> ，然后根据 <span class="math-inline">l^i</span> 选择 Top-K ( <span class="math-inline">K=\frac{d_{2}}{E}</span> )，选择出来的矩阵是 <span class="math-inline">W^{\mathrm{i}}<em>g \in \mathbb{R}^{d</em>{1} \times K}</span> 。最后将所有专家提取的矩阵连接起来作为最终的学生初始化 <span class="math-inline">W_g \in \mathbb{R}^{d_{1} \times d_{2}}</span> 。</p>
<p><strong>SVD Knowledge Gathering</strong></p>
<p>矩阵的低秩分解用于把一个非低秩矩阵转化成低秩矩阵，这样的低秩矩阵可以近似整个矩阵的知识，可以通过从多个低秩矩阵重构高阶矩阵。作者在本文中使用 SVD 来提取关键知识并将它们合并：</p>
<p><div class="math-display">\begin{equation} W_f^i= U_f^i S_f^i {V_f^i}^T\approx {U_f^i}<em>{K^i} {S_f^i}</em>{K^i} {V_f^i}<em>{K^i}^T \end{equation} \tag{13}</div><br />
式中， <span class="math-inline">U_f^i \in \mathbb{R}^{d_1 \times d_1}</span> ， <span class="math-inline">V_f^i \in \mathbb{R}^{d_2 \times d_2}</span> 是酉矩阵， <span class="math-inline">S_f^i \in \mathbb{R}^{d_1 \times d_2}</span> 是对角矩阵。通常选择 <span class="math-inline">S_f^i</span> 中的 top-K 元素并构建 <span class="math-inline">{U_f^i}</em>{K^i} \in \mathbb{R}^{d_1 \times K^i}</span> ， <span class="math-inline">{S_f^i}<em>{K^i} \in \mathbb{R}^{{K^i} \times {K^i}}</span> 和 <span class="math-inline">{V_f^i}</em>{K^i} \in \mathbb{R}^{d_2 \times {K^i}}</span> 来逼近 <span class="math-inline">W_f^i</span> 。</p>
<p>然后按照下式得到低秩分解之后的 <span class="math-inline">W_g</span> ：</p>
<p><div class="math-display">\begin{equation} \small \begin{aligned} [~U_g~][~U_g~]&amp;= \left[ \begin{array}{ccc} {U_f^1}<em>{K^1} &amp; \dots &amp; {U_f^E}</em>{K^E}  \end{array}  \right ], \ [~S_g~] &amp;= \left[ \begin{array}{ccc} {S_f^1}<em>{K^1} &amp; ~ &amp; ~ \ ~ &amp; \ddots &amp; ~ \ ~ &amp; ~ &amp; {S_f^E}</em>{K^E} \end{array}  \right ], \ [~V_g~] &amp;= \left[ \begin{array}{c} {V_f^1}<em>{K^1} \  \vdots \ {V_f^E}</em>{K^E}  \end{array}  \right ] \ \end{aligned} \end{equation} \tag{14}</div>  </p>
<p><div class="math-display">\begin{equation} W_g= U_g S_g {V_g}^T \end{equation} \tag{15}</div>  </p>
<p>式中， <span class="math-inline">W_g</span> 是一个 <span class="math-inline">K_g</span> 秩的矩阵，式中 <span class="math-inline">K_g=\Sigma_{i=1}^E K^i</span> ，涵盖每个 Expert 的关键知识。</p>
<h2 id="5-第二阶段知识蒸馏">5 第二阶段：知识蒸馏<a class="anchor-link" href="#5-第二阶段知识蒸馏" title="Permanent link">&para;</a></h2>
<p>作者进一步对学生模型进行蒸馏，蒸馏损失可以写成：</p>
<p><div class="math-display">\begin{equation} \mathrm{L}<em>{distill}^{soft} = T^2 \mathrm{L</em>{KL}}(\omega(z_{s}/T), \omega(z_{t}/T)) \end{equation} \tag{16}</div><br />
式中， <span class="math-inline">\omega</span> 是 Softmax 函数， <span class="math-inline">L_{KL}</span> 是 KL 散度损失函数。  </p>
<p>最后的损失函数可以写成：</p>
<p><div class="math-display">\begin{equation} \mathrm{L_{total}} = \alpha \mathrm{L_{main}} + (1-\alpha) \mathrm{L_{distill}} \end{equation} \tag{17}</div>  </p>
<p>式中， <span class="math-inline">\mathrm{L_{main}}</span> 取决于具体的任务。比如图像分类里面就是 CE Loss。对于 BERT 预训练，它应该是 masked language modeling loss 和 next sentence prediction loss。</p>
<h2 id="6-视觉任务实验结果">6 视觉任务实验结果<a class="anchor-link" href="#6-视觉任务实验结果" title="Permanent link">&para;</a></h2>
<p>如下图3所示是 ImageNet 图像识别任务的实验结果。预训练的数据集使用的是 ImageNet-1K，基线模型选择 WideNet。Benefits 是8式所定义的那样，表示在知识集成之后，Dense 模型保留了多少改进。根据图3可以发现，SVD Knowledge Gathering 的方法的性能最好，因此在接下来的实验中，作者将基于 SVD 的方法设置为默认选择。可以观察到 OneS-L-SVD 在 ImageNet 上实现了 78.4% 的 top-1 准确率，只有 15M 参数。与最强的 Switch-L 相比，本文的模型提高了 0.6%。OneS-L-SVD 实现了与 ViT-B 相当的性能，只有 17% 的可训练参数。这些结果显示了知识整合的有效性。</p>
<div align=center><img src="https://markdownimg-hw.oss-cn-beijing.aliyuncs.com/20241105104513.png" style="zoom: 60%;" /></div>

<h2 id="7-文本任务实验结果">7 文本任务实验结果<a class="anchor-link" href="#7-文本任务实验结果" title="Permanent link">&para;</a></h2>
<p>如下图4所示是 NLU 任务实验结果。预训练的数据集使用的是 English Wikipedia 和 BOOKCORPUS，微调时候的评估基准是 General Language Understanding Evaluation (GLUE)，以及两个不同的 Stanford Question Answering (SQuAD) 数据集。基线模型选择 ALBERT。</p>
<p>实验结果如下图4所示，可以看到 OneS 方法在所有任务上都优于基线方法 (即 Distill 和 Switch)。在四个任务上，OneS 平均超过 Switch 0.42。在 SQuAD1.1 和 SST-2 等少数任务中，OneS 甚至可以胜过教师 MoE 模型 WideNet。MoE 模型倾向于在小数据集上过拟合。OneS 具有 MoE 的知识，但是结构依然是密集的，因此预训练的优势可以更容易地迁移到下游任务中。</p>
<div align=center><img src="https://markdownimg-hw.oss-cn-beijing.aliyuncs.com/20241105104528.png" style="zoom: 60%;" /></div>

<p>与 MoE 模型相比，OneS 的另一个优点是推理速度。MoE 模型之所以慢的原因是：条件计算带来的门控函数，稀疏 einsum 算子，以上缺点会降低计算的效率。但是，OneS 模型可以实现 3.7 倍的推理速度。OneS 模型高效率的另一个重要原因是密集模型比稀疏 MoE 模型更硬件友好。</p>
<h2 id="8-消融实验结果">8 消融实验结果<a class="anchor-link" href="#8-消融实验结果" title="Permanent link">&para;</a></h2>
<p>为了进一步验证本文提出的知识聚合和知识蒸馏的有效性，本文进行了如下图所示的消融实验。可以看到，在没有知识聚合的情况下，性能会显著地下降，这表明预训练的稀疏模型中包含的知识对于提高学生模型的性能至关重要。在没有知识蒸馏的情况下，性能会略微下降，说明知识蒸馏有一定帮助，教师可以帮助学生挖掘收集到的知识。对于大模型，去除知识收集和知识蒸馏也会损害性能。</p>
<div align=center><img src="https://markdownimg-hw.oss-cn-beijing.aliyuncs.com/20241105145216.png" /></div>

<h2 id="references">References<a class="anchor-link" href="#references" title="Permanent link">&para;</a></h2>
<ol>
<li><a href="https://zhuanlan.zhihu.com/p/654089730">MoE 系列超详细解读 (四)：MoE 知识蒸馏：从稀疏教师模型到密集学生模型</a></li>
</ol>
<h2 id="kimi全文翻译-arrow_down">Kimi全文翻译 :arrow_down:<a class="anchor-link" href="#kimi全文翻译-arrow_down" title="Permanent link">&para;</a></h2>
<h2 id="0-摘要">0. 摘要<a class="anchor-link" href="#0-摘要" title="Permanent link">&para;</a></h2>
<p>人类教育系统通过多位专家训练一名学生。专家混合（MoE）是一种强大的稀疏架构，包括多个专家。然而，稀疏 MoE 模型容易过拟合，难以部署，对实践者来说不友好。在这项工作中，受人类教育模型的启发，我们提出了一个新任务，即知识整合，以获得一个与一个稀疏 MoE 一样知识渊博的密集学生模型（OneS）。我们通过提出一个包括知识收集和知识蒸馏的一般训练框架来研究这项任务。具体来说，为了从不同的预训练专家中收集关键知识，我们首先研究了四种不同可能的知识收集方法，即求和、平均、Top-K 知识收集（Top-KG）和本文提出的奇异值分解知识收集（SVD-KG）。然后，我们通过知识蒸馏来提炼密集学生模型，以抵消收集中的噪声。在 ImageNet 上，我们的 OneS 保留了 61.7% 的 MoE 好处，并以仅有 1500 万参数实现了 78.4% 的 top-1 准确率 ImageNet。在四个自然语言处理数据集上，OneS 获得了 88.2% 的 MoE 好处，并在使用相同架构和训练数据的情况下，以 51.7% 的优势超越了最佳基线。此外，与 MoE 对应物相比，由于计算更少和硬件友好的架构，OneS 可以实现 3.7 倍的推理加速。</p>
<h2 id="1-引言">1. 引言<a class="anchor-link" href="#1-引言" title="Permanent link">&para;</a></h2>
<p>回顾我们如何成为研究员，大多数人从多位老师（即专家）那里学习。教育领域的现有工作 [2] 也表明，来自不同学科的专家可以帮助学生深入理解和培养更多的人才。整合专家知识的学生可以快速变得和这些专家一样知识渊博。受这种人类教育模型的启发，这项工作专注于通过收集一组专家的知识来训练一个强大的深度学习模型。深度学习的最新研究提出了专家混合（MoE），这是一个具有多个专家的深度神经网络。</p>
<p>每个专家都是整个模型中的一个子神经网络。MoE 的关键思想是分而治之。MoE 鼓励每个专家从输入的特定子集中学习。对于输入的每个子集，只有一个子网络被激活。这种 MoE 的稀疏计算使我们能够将模型扩展到数万亿参数，同时保持可比的计算成本 [8]。由于其大而稀疏激活的模型容量，MoE 模型功能强大，并取得了有希望的结果。然而，MoE 容易过拟合。我们通常在大型数据集上预训练 MoE，然后对其进行各种下游任务的微调。在大多数情况下，这些下游任务是我们想要解决的目标问题。与密集模型相比，更多的可训练参数和稀疏条件计算在微调期间引入了过拟合 [14, 27]，特别是当数据集规模不够大时。此外，即使我们成功训练了 MoE 模型，也很难部署。对于数万亿参数的 MoE，我们需要在不同的设备上部署不同的专家以减少设备上的内存消耗（例如 GPU、TPU）。第三，MoE 模型对硬件不友好。专家并行性在通信上成本高昂。对于 GPU 集群，全对全操作扩展 MoE 模型的速度太慢。此外，门控函数包括许多操作，以创建令牌掩码、选择 top-k 专家，并执行累积和以找到每个令牌的 token-id，然后进行稀疏矩阵乘法 [16]。所有这些操作由于稀疏张量表示而浪费，并且由于许多内核调用而极其缓慢。总之，稀疏 MoE 模型功能强大，但在实践中相对难以使用。密集模型被广泛使用，但与具有可比计算成本的稀疏模型相比较弱。那么，是否可能结合稀疏和密集模型的优势来训练一个既有效又易于使用的模型呢？在这项工作中，受人类教育模型的启发，我们提出了一个新的任务，即知识整合。作为一个通用的训练框架，知识整合包括两个步骤，即知识收集和知识蒸馏。在知识收集中，我们将 MoE 中的每个专家视为人类教育中的专家。学生是一个密集模型，我们需要从所有专家那里收集知识并将其分配给学生。为了从专家那里收集知识，作为第一项专注于此任务的工作，我们研究了四种不同的可能解决方案，即求和、平均、Top-KG 和本文提出的 SVD-KG。对于 Top-KG 和 SVD-KG，我们使用 Top-K 选择或 SVD 从预训练的 MoE 的不同专家中提取关键知识，然后，我们初始化前馈网络（FFN）层以近似 MoE。为了进一步提炼模型，我们使用知识蒸馏 [9] 来微调学生。请注意，在知识蒸馏阶段，我们使用整个 MoE 模型来教导学生密集模型。最终的学生模型与标准密集模型的架构相同，但它将涵盖 MoE 的许多专家和更多的可训练参数。上述框架与人类教育模型非常匹配，一名学生整合了多位专家的知识，以便学生可以快速学习。我们的贡献总结如下：</p>
<ul>
<li>我们提出了一个新的任务，即知识整合。目标是结合稀疏 MoE 模型的有效性和密集模型的可用性。据我们所知，这是第一项专注于从预训练的 MoE 模型中学习密集模型的工作。</li>
<li>我们提出了分两步解决知识整合的方法，即知识收集和知识蒸馏。为了收集，我们首先研究了四种不同可能的知识收集方法，即求和、平均、Top-KG 和本文提出的 SVD-KG。Top-KG 和 SVD-KG 是提取和合并预训练 MoE 专家的关键知识的新方法。</li>
<li>我们在不同领域评估了我们的通用训练框架，即计算机视觉和自然语言处理。在 ImageNet 上，与基线相比，我们的 OneS 保留了 23.1% 的 MoE 好处。在自然语言处理基准测试中，我们仅使用 46% 的参数就实现了 88.2% 的 MoE 好处，并在使用几乎相同的架构和训练数据的情况下超越了基线（例如 Distill、Switch）。此外，由于硬件友好的模型架构，OneS 可以实现比 MoE 对应物快 3.7 倍的推理加速。</li>
</ul>
<h2 id="2-预备知识">2. 预备知识<a class="anchor-link" href="#2-预备知识" title="Permanent link">&para;</a></h2>
<h3 id="21-专家混合">2.1. 专家混合<a class="anchor-link" href="#21-专家混合" title="Permanent link">&para;</a></h3>
<p>专家混合是一个典型的条件计算模型。在这项工作中，我们使用一个预训练的 MoE 模型作为教师，一个密集模型作为学生来模仿人类教育模型。因此，我们首先简要回顾 MoE。</p>
<p>给定一个具有 <span class="math-inline">E</span> 个可训练专家的 MoE 模型和输入表示 <span class="math-inline">x \in \mathbb{R}^D</span>，MoE 模型的输出可以被公式化为 [21]：<br />
<div class="math-display"><br />
    \text{MoE}(x) = \sum_{i=1}^{E} G(x)i e_i(x)<br />
</div><br />
其中 <span class="math-inline">e_i(\cdot)</span> 是第 <span class="math-inline">i</span> 个专家的非线性变换 <span class="math-inline">\mathbb{R}^D \rightarrow \mathbb{R}^D</span>，<span class="math-inline">G(\cdot) : \mathbb{R}^D \rightarrow \mathbb{R}^E</span> 是门控网络，<span class="math-inline">G(x)i</span> 是 <span class="math-inline">x</span> 到第 <span class="math-inline">i</span> 个专家的路由权重。通常，<span class="math-inline">e(\cdot)</span> 和 <span class="math-inline">G(\cdot)</span> 都由神经网络参数化。请注意，<span class="math-inline">G(\cdot)</span> 的输出应该通过 softmax 函数激活：<br />
<div class="math-display"><br />
    G(x) = \text{topK}(\omega(h(x) + \epsilon))<br />
</div><br />
其中 <span class="math-inline">\omega</span> 是 softmax 函数，<span class="math-inline">h(\cdot)</span> 是从 <span class="math-inline">\mathbb{R}^D</span> 到 <span class="math-inline">\mathbb{R}^E</span> 的线性层映射，<span class="math-inline">\epsilon \sim \mathcal{N}(0, \frac{1}{E^2})</span> 是用于专家路由探索的高斯噪声。Top-K 选择是激活子网络稀疏的关键模块。我们通常将 <span class="math-inline">K</span> 设置为 1 或 2，以与相应的密集模型具有可比的计算成本。当训练 MoE 模型时，如果没有正则化，大多数令牌可能被派发到一小部分专家，而其他专家接收到的令牌很少。这种不平衡的分配会导致效率低下和准确性差 [8,12]。因此，为了实现不同专家之间的平衡工作负载，我们通常将路由器 <span class="math-inline">g(\cdot)</span> 与负载平衡损失 <span class="math-inline">L_{\text{balance}}</span> 结合起来 [12]：<br />
<div class="math-display"><br />
    L_{\text{balance}} = E \sum_{i=1}^{E} m_i \cdot P_i<br />
</div><br />
其中 <span class="math-inline">m</span> 是一个向量，其第 <span class="math-inline">i</span> 个元素表示派发到第 <span class="math-inline">i</span> 个专家的令牌的比例：<br />
<div class="math-display"><br />
    m_i = \frac{1}{N} \sum_{j=1}^{N} k(x_j)i<br />
</div><br />
其中 <span class="math-inline">N</span> 是要路由的令牌数量，<span class="math-inline">k(x_j)</span> 是来自 top-K 函数的索引向量。由于这里索引向量的生成是非可微的，我们定义 <span class="math-inline">P_i</span> 为：<br />
<div class="math-display"><br />
    P_i = \omega(h(x) + \epsilon)i<br />
</div><br />
其中 <span class="math-inline">P</span> 是不带 top-K 路由的 <span class="math-inline">g(x)</span>。当我们最小化 <span class="math-inline">L_{\text{balance}}</span> 时，我们可以看到 <span class="math-inline">m</span> 和 <span class="math-inline">P</span> 都会接近均匀分布。可训练的路由器这里也可以被非训练模块替换，例如 BASE 层 [13]。这项工作专注于从预训练的 MoE 中整合知识，而不是 MoE 变体。</p>
<h3 id="22-问题公式化">2.2. 问题公式化<a class="anchor-link" href="#22-问题公式化" title="Permanent link">&para;</a></h3>
<p>我们提出的工作有两个阶段：（1）从 MoE 中收集知识；（2）知识蒸馏以进一步提炼新的密集模型（即学生）。对于第一阶段，给定 <span class="math-inline">E</span> 个专家 <span class="math-inline">{e_1(\cdot), e_2(\cdot), \ldots, e_E(\cdot)}</span>，我们的目标是在密集模型 <span class="math-inline">s(\cdot)</span> 中最大化覆盖的知识。我们使用基于变换器的 MoE 来介绍我们的框架，因为它很受欢迎。给定输入表示 <span class="math-inline">x</span>，在变换器块中，每个专家都是一个 FFN，可以被公式化为：<br />
<div class="math-display"><br />
    e_i(x) = f_i^2(\sigma(f_i^1(x)))<br />
</div><br />
其中 <span class="math-inline">f_i^1(\cdot)</span> 和 <span class="math-inline">f_i^2(\cdot)</span> 是第 <span class="math-inline">i</span> 个专家的线性变换，<span class="math-inline">\sigma(\cdot)</span> 是激活函数。对于密集学生，我们有相同的架构，但有不同的可训练参数：<br />
<div class="math-display"><br />
    s(x) = g_2(\sigma(g_1(x)))<br />
</div><br />
其中 <span class="math-inline">\sigma(\cdot)</span> 将与专家相同的激活函数。唯一的区别是线性变换中的可训练参数。然后，我们的目标是近似 <span class="math-inline">g_1</span> 和 <span class="math-inline">g_2</span> 的可训练参数，分别根据 <span class="math-inline">{f_1^1, \ldots, f_E^1}</span> 和 <span class="math-inline">{f_1^2, \ldots, f_E^2}</span>。我们定义这个目标为从 MoE 中收集知识。第二阶段是微调密集学生，以最小化教师输出和学生输出之间的差异。我们可以很容易地发现这个任务更接近知识蒸馏 [9]，因此，在本文中，我们遵循典型的 KD 方法作为我们的解决方案。我们的目标是尽可能多地保留 MoE 的好处。因此，我们定义了一个度量，MoE 好处，来衡量密集学生整合 MoE 对应物知识的能力。MoE 好处可以写成：<br />
<div class="math-display"><br />
    \text{MoE 好处} = \frac{\text{score}<em>{\text{student}} - \text{score}</em>{\text{dense}}}{\text{score}<em>{\text{MoE}} - \text{score}</em>{\text{dense}}}<br />
</div><br />
其中分数可以是评估模型的任何指标。例如，对于图像分类，分数是准确率。这里的 <span class="math-inline">\text{score}_{\text{dense}}</span> 表示没有提出的知识整合的密集模型的性能。</p>
<h2 id="3-方法">3. 方法<a class="anchor-link" href="#3-方法" title="Permanent link">&para;</a></h2>
<h3 id="31-从-moe-中收集知识">3.1. 从 MoE 中收集知识<a class="anchor-link" href="#31-从-moe-中收集知识" title="Permanent link">&para;</a></h3>
<p>我们首先制定我们的 KG 任务。给定一个具有 <span class="math-inline">E</span> 个专家的 MoE 层，这里的目標是从所有专家那里收集知识，为一个密集学生服务。根据方程 6 和方程 7，每个专家包括两个线性层，学生与单个专家共享相同的模型结构。为了简洁，我们将每个专家视为一个线性变换来展示我们的想法，这可以轻松扩展到多个线性层。对于 <span class="math-inline">E</span> 个线性层 <span class="math-inline">{f_1, f_2, \ldots, f_E}</span>，每个线性层 <span class="math-inline">f_i(\cdot) : \mathbb{R}^{d_1} \rightarrow \mathbb{R}^{d_2}</span>，其权重 <span class="math-inline">W_i^f \in \mathbb{R}^{d_1 \times d_2}</span> 和偏置 <span class="math-inline">b_i^f \in \mathbb{R}^{d_2}</span>，知识收集（KG）可以表示为：<br />
<div class="math-display"><br />
    \text{KG}(f_1, f_2, \ldots, f_E) = \text{KG}(W_1^f, W_2^f, \ldots, W_E^f; b_1^f, b_2^f, \ldots, b_E^f) \approx (W_g; b_g) = g<br />
</div><br />
其中 <span class="math-inline">g(\cdot) : \mathbb{R}^{d_1} \rightarrow \mathbb{R}^{d_2}</span> 是一个线性层，其权重 <span class="math-inline">W_g \in \mathbb{R}^{d_1 \times d_2}</span> 和偏置 <span class="math-inline">b_g \in \mathbb{R}^{d_2}</span>。在合并权重之前，我们首先从不同专家那里初始化 <span class="math-inline">b_g</span>。由于它可训练的参数少得多，我们简单地平均不同专家的偏置向量：<br />
<div class="math-display"><br />
    b_g = \frac{1}{E} \sum_{i=1}^{E} b_i^f<br />
</div><br />
我们采用这种简单的策略，因为存储在偏置中的知识远少于权重中的知识，因为可训练的参数更少。我们通过实验在附录 E 中验证了这一假设。在复制完美匹配层的权重和平均 MoE 层的偏置之后，我们通过稀疏 MoE 初始化密集学生模型的权重。作为第一项专注于此任务的工作，我们研究了四种方法来收集知识，即求和、平均、Top-KG 和 SVD-KG。前两种是最直接的方法。我们还提出了两种新方法，Top-KG 和 SVD-KG，从预训练的 MoE 的不同专家中提取关键知识。</p>
<h4 id="311-求和与平均">3.1.1 求和与平均<a class="anchor-link" href="#311-求和与平均" title="Permanent link">&para;</a></h4>
<p>对于 MoE 中的权重，我们首先考虑两种简单的方法。第一种是求和：<br />
<div class="math-display"><br />
    W_g = \sum_{i=1}^{E} W_i^f<br />
</div><br />
第二个是平均：<br />
<div class="math-display"><br />
    W_g = \frac{1}{E} \sum_{i=1}^{E} W_i^f<br />
</div><br />
尽管这两种收集方法很简单，作为第一项专注于此任务的工作，我们研究它们为从 MoE 模型中收集知识铺平了道路。</p>
<h3 id="32-top-k-知识收集">3.2. Top-K 知识收集<a class="anchor-link" href="#32-top-k-知识收集" title="Permanent link">&para;</a></h3>
<p>我们还提出了两种新的方法来收集知识。对于权重，在 MoE 中，一个过度参数化的模型，拥有更多的可训练参数，覆盖所有知识在狭窄的密集模型中是具有挑战性的。因此，我们必须从每个专家中提取关键知识，然后将它们合并到一个小型的密集模型中。然后，问题来了，我们如何从每个可训练矩阵（即权重）中提取关键知识？我们首先提出 Top-K 知识收集来提取每个专家的子矩阵。对于第 <span class="math-inline">i</span> 个专家的权重矩阵 <span class="math-inline">W_i \in \mathbb{R}^{d_1 \times d_2}</span>，我们计算每个列的 l2 范数作为 <span class="math-inline">l_i \in \mathbb{R}^{d_1}</span>。然后我们使用 Top-K 选择根据 <span class="math-inline">l_i</span> 挑选 <span class="math-inline">W_i</span> 的 <span class="math-inline">K</span> 列，其中 <span class="math-inline">K = \frac{d_2}{E}</span>。提取的矩阵 <span class="math-inline">W_i^g \in \mathbb{R}^{d_1 \times K}</span>。然后我们将从所有专家那里提取的矩阵连接起来作为最终学生初始化 <span class="math-inline">W_g \in \mathbb{R}^{d_1 \times d_2}</span>。在实践中，由于每个专家有两个线性层 <span class="math-inline">W_i^1 \in \mathbb{R}^{d_1 \times d_2}</span> 和 <span class="math-inline">W_i^2 \in \mathbb{R}^{d_2 \times d_1}</span>，如果独立选择这两个矩阵的子矩阵，将存在列不匹配问题。为了缓解这个问题，我们计算 <span class="math-inline">W_i^1</span> 的每个列的 l2 范数和 <span class="math-inline">W_i^2</span> 的每个行的 l2 范数。这两个 l2 范数向量的和，即 <span class="math-inline">l_i \in \mathbb{R}^{d_1}</span>，输入到 Top-K 选择并提取子矩阵。</p>
<h4 id="321-svd-知识收集">3.2.1 SVD 知识收集<a class="anchor-link" href="#321-svd-知识收集" title="Permanent link">&para;</a></h4>
<p>我们研究了另一种从专家中提取关键知识的新方法。低秩压缩 [3] 在捕获关键知识方面显示出了有希望的结果，它被用来将非低秩矩阵转换为权重矩阵的秩 -k 分解。这样的低秩矩阵可以近似整个矩阵的知识。基于此，我们可以更容易地通过从多个低秩矩阵重构高秩矩阵来合并低秩矩阵。请注意，在这项工作中，获得秩 -k 分解并不是我们的目标。相反，秩 -k 分解只是我们分解和合并的中间步骤。在这项工作中，我们提出使用 SVD 来提取关键知识并将它们合并以初始化另一个密集矩阵：<br />
<div class="math-display"><br />
W_i^f = U_i^f S_i^f V_i^f^T \approx U_i^f K_i S_i^f K_i V_i^f^T<br />
</div><br />
其中 <span class="math-inline">U_i^f \in \mathbb{R}^{d_1 \times d_1}</span> 和 <span class="math-inline">V_i^f \in \mathbb{R}^{d_2 \times d_2}</span> 是酉矩阵，<span class="math-inline">S_i^f \in \mathbb{R}^{d_1 \times d_2}</span> 是对角矩阵。我们通常选择 <span class="math-inline">S_i^f</span> 中的前 <span class="math-inline">K_i</span> 个元素，然后构造 <span class="math-inline">U_i^f K_i \in \mathbb{R}^{d_1 \times K_i}</span>，<span class="math-inline">S_i^f K_i \in \mathbb{R}^{K_i \times K_i}</span> 和 <span class="math-inline">V_i^f K_i \in \mathbb{R}^{d_2 \times K_i}</span> 来近似 <span class="math-inline">W_i^f</span>。当 <span class="math-inline">k</span> 固定时，每个矩阵都有秩 -k 分解来近似原始矩阵。然而，我们不能保证每个专家的关键知识都能被固定的秩 -k 分解所覆盖。因此，我们定义了一个自适应 SVD 比率 <span class="math-inline">\lambda \in (0, 1]</span> 以确保：<br />
<div class="math-display"><br />
    \rho(S_i^f K_i) \approx \lambda \rho(S_i^f)<br />
</div><br />
其中 <span class="math-inline">\rho(S_i^f)</span> 表示 <span class="math-inline">S_i^f</span> 对角元素的和。如果 <span class="math-inline">\lambda = 1</span>，则所有秩都将被保留以形成全秩矩阵。然后我们收集每个专家的分解并将它们连接起来：<br />
<div class="math-display"><br />
    \Omega_{Ug}^T = \begin{bmatrix} U_1^f K_1 &amp; \cdots &amp; U_E^f K_E \end{bmatrix}, \quad [S_g] = \begin{bmatrix} S_1^f K_1 &amp; \cdots &amp; S_E^f K_E \end{bmatrix}, \quad [V_g] = \begin{bmatrix} V_1^f K_1 &amp; \cdots &amp; V_E^f K_E \end{bmatrix}<br />
</div><br />
然后我们可以得到 <span class="math-inline">W_g</span>：<br />
<div class="math-display"><br />
    W_g = U_g S_g V_g^T<br />
</div><br />
<span class="math-inline">W_g</span> 是一个秩 -<span class="math-inline">K_g</span> 矩阵，其中 <span class="math-inline">K_g = \sum_{i=1}^{E} K_i</span>，涵盖了每个专家的关键知识。经过 SVD-KG 后，知识已经从预训练的 MoE 中整合过来。然而，在知识收集过程中，不可避免地会在我们移除条件计算时引入噪声。关于收集过程中引入的噪声的详细分析可以在附录 A 中找到。</p>
<h3 id="33-知识蒸馏">3.3. 知识蒸馏<a class="anchor-link" href="#33-知识蒸馏" title="Permanent link">&para;</a></h3>
<p>为了从噪声中挖掘知识，我们采用软知识蒸馏 [9] 来微调密集学生。软蒸馏最小化教师和学生输出之间的 Kullback-Leibler 散度。相应的蒸馏损失可以写成：<br />
<div class="math-display"><br />
    L_{\text{soft distill}} = T^2 L_{KL}(\omega(z_s / T), \omega(z_t / T))<br />
</div><br />
其中 <span class="math-inline">\omega</span> 是 softmax 函数，<span class="math-inline">L_{KL}</span> 是 Kullback-Leibler 散度损失，<span class="math-inline">z_s</span> 和 <span class="math-inline">z_t</span> 分别是学生和教师的 logits，<span class="math-inline">T</span> 是 softmax 温度。我们还考虑了硬标签蒸馏 [24]，并比较了其性能与软蒸馏。详情请参见附录 C。</p>
<h3 id="34-优化">3.4. 优化<a class="anchor-link" href="#34-优化" title="Permanent link">&para;</a></h3>
<p>我们的最终损失函数很简单：<br />
<div class="math-display"><br />
    L_{\text{total}} = \alpha L_{\text{main}} + (1 - \alpha) L_{\text{distill}}<br />
</div><br />
其中 <span class="math-inline">\alpha</span> 用于平衡主要损失和蒸馏损失。主要损失取决于任务。例如，对图像进行分类时，它是交叉熵损失。对于 BERT 预训练，它应该是掩蔽语言建模损失和下一句预测损失。这里的蒸馏损失可以是软蒸馏损失或硬标签蒸馏损失。由于我们的预训练 MoE 在知识蒸馏阶段是固定的，我们不需要 MoE 基础变换器的负载平衡损失。</p>
<h2 id="4-实验">4. 实验<a class="anchor-link" href="#4-实验" title="Permanent link">&para;</a></h2>
<h3 id="41-计算机视觉">4.1. 计算机视觉<a class="anchor-link" href="#41-计算机视觉" title="Permanent link">&para;</a></h3>
<h4 id="实验设置">实验设置<a class="anchor-link" href="#实验设置" title="Permanent link">&para;</a></h4>
<p>为了评估我们的通用训练框架，我们在计算机视觉和自然语言处理两个不同领域进行实验。对于视觉，我们选择了两个广泛使用的图像分类基准，ILSVRC-2012 ImageNet[5] 和 Cifar10[10]，作为评估我们框架的平台。我们在此工作中使用的 ILSVRC-2012 ImageNet 数据集有 1k 个类别和 130 万张图像。为了简洁起见，我们在以下实验中将其称为 ImageNet。基线作为我们第一项专注于从预训练的 MoE 整合知识的工作中，据我们所知，只有两个现有的强大基线是 Meta AI MoE[1] 提出的知识蒸馏框架和 Switch Transformer[8]。第一个简单地随机初始化学生密集模型。第二个工作用非专家权重初始化密集模型。也就是说，他们简单地复制可以完美匹配的层到密集模型中。对于不能匹配的权重（即专家），他们跳过从 MoE 的初始化，而是从零开始训练这些层。在我们的工作中，为了简洁起见，我们将这两种方法分别称为 Distill 和 Switch。我们还报告了在相同设置下的 Vision Transformer (ViT) 的结果，以比较参数效率。教师在我们的训练框架中，我们需要一个 MoE 模型来初始化我们的密集学生模型（即知识收集）和执行知识蒸馏。在这项工作中，我们应用了预训练的 WideNet[27] 作为平台。WideNet 是一个基于 MoE 的变换器，只有一个可训练的变换器块。这个变换器块使用 MoE 而不是 FFN 层来学习局部表示。本文的主要焦点是验证预训练的 MoE 中的知识能否在密集学生中保留，因此我们使用 WideNet 作为我们的教师模型，以更直接的方式验证我们方法的有效性。超参数为了公平比较，我们遵循教师模型中使用的数据增强：Inception 风格的预处理，Mixup[30]，RandAugment[4] 和标签平滑 [23, 29]。我们使用 LAMB[28] 优化器。批量大小和学习率分别设置为 4096 和 0.004。对于教师模型，所有 WideNet[27] 的设置都与他们论文中报告的相同。请注意，我们在 OneS 的知识蒸馏阶段冻结了教师模型（即 WideNet）的所有可训练权重。对于蒸馏超参数，我们设置 <span class="math-inline">\alpha</span> 为 0.25，温度 <span class="math-inline">T</span> 为 1.0。应用线性学习率衰减。我们还在 Cifar10 上微调了预训练的学生模型。设置与 ViT 和 WideNet 相同。我们使用动量 SGD 优化器。遵循现有工作，移除了标签平滑和热身。其他训练细节请参见附录。</p>
<h4 id="411-imagenet-上的结果">4.1.1 ImageNet 上的结果<a class="anchor-link" href="#411-imagenet-上的结果" title="Permanent link">&para;</a></h4>
<p>我们在表 1 中报告了 ImageNet 上的 top-1 准确率和 MoE 好处。在这张表中，正如我们在方程 8 中定义的，MoE 好处意味着在知识整合后，密集模型保留了多少改进。首先，在研究了四种不同的 KG 方法后，基于 SVD 的整合方法表现最佳。因此，我们将基于 SVD 的方法设置为以下实验中的默认选择。基于 Top-K 的整合方法在大规模上与基于 SVD 的方法表现相当，但在基础级别上略差。我们建议的原因是大型模型具有更大的容量，对稀疏列丢弃更加鲁棒。此外，我们观察到 OneS-L-SVD 仅用 1500 万参数就在 ImageNet 上实现了 78.4% 的 top-1 准确率。与最强的 Switch-L 相比，我们的模型提高了 0.6 个百分点。与教师模型相比，OneS-L-SVD 以一半的参数超越了 WideNet-B 0.9%。最终，OneS-L-SVD 以仅 17% 的可训练参数实现了与 ViT-B 相当的性能。更重要的是，在 [27] 中，没有 MoE，WideNet-L 只能达到 76.9% 的 top-1 准确率。我们的 OneS 具有完全相同的架构，但我们可以实现 78.4% 的准确率。也就是说，我们的 OneS-L-SVD 保留了 61.7% 的改进（即 MoE 好处）。此外，我们的 OneS-B-SVD 实现了 57.7% 的 MoE 好处，超过了最强的基线（即 Switch）23.1 个百分点。这些结果表明了知识整合的有效性。</p>
<h4 id="412-cifar10-上的结果">4.1.2 Cifar10 上的结果<a class="anchor-link" href="#412-cifar10-上的结果" title="Permanent link">&para;</a></h4>
<p>我们进一步在 Cifar10 上微调了我们的密集学生模型 OneS。如表 2 所示，我们的 OneS-L 仍然优于我们的基线，Switch-B 和 Switch-L，分别提高了 0.3% 和 0.6%。OneS-L 甚至可以用 0.33×的可训练参数达到与 WideNet-B 相当的性能。OneS-B 也因为知识收集而优于 Switch-B。总之，Cifar10 上的结果表明，ImageNet 上的预训练改进可以传播到下游任务。</p>
<h3 id="42-自然语言处理">4.2. 自然语言处理<a class="anchor-link" href="#42-自然语言处理" title="Permanent link">&para;</a></h3>
<h4 id="实验设置_1">实验设置<a class="anchor-link" href="#实验设置_1" title="Permanent link">&para;</a></h4>
<p>与计算机视觉任务上的实验类似，我们仍然在自然语言处理上有两阶段的训练。不同之处在于，按照现有工作 [6, 11, 27]，我们关注下游任务的性能而不是预训练。数据集我们使用英文维基百科 [6] 和 BOOKCORPUS[33] 作为我们的预训练语料库。对于微调，我们在通用语言理解评估（GLUE）基准 [26] 上评估我们的工作，以及斯坦福问答（SQuAD）数据集 [17, 18] 的两个不同版本。对于 GLUE 实验，我们报告了 5 次运行的中位数，遵循现有工作 [11, 27]。基线与计算机视觉实验类似，我们仍然选择 Distill 和 Switch 作为我们的直接基线，尽管我们的工作是第一项专注于此任务。学生模型在这里与 ALBERT 的架构相同，除了个别层归一化 [27]。因此，另一个基线是 ALBERT。我们期望我们的 OneS 能在几乎相同的架构、相当数量的参数和相同的预训练数据集的情况下超越 ALBERT。超参数在初始化后，我们通过掩蔽语言建模损失、句子顺序预测损失和软知识蒸馏损失的线性组合进一步训练 OneS。按照 [20]，我们只将掩蔽语言建模损失的 logits 输入到 <span class="math-inline">L_{\text{distill}}</span>。我们仍然在 OneS 的训练阶段冻结教师 MoE 模型（WideNet）的所有可训练权重。<span class="math-inline">\alpha</span> 设置为 0.75，<span class="math-inline">\lambda</span> 设置为 0.25。这些设置的消融研究可以在附录 D 中找到。其他详细的超参数可以在附录 B.2 中找到。</p>
<h4 id="421-nlu-基准上的结果">4.2.1 NLU 基准上的结果<a class="anchor-link" href="#421-nlu-基准上的结果" title="Permanent link">&para;</a></h4>
<p>预训练后，我们在没有蒸馏损失的情况下微调我们的 OneS。这种设置与现有的语言模型蒸馏工作不同。原因是，我们的目标之一是获得一个易于使用的模型，而不需要专家路由。如果我们仍然有 MoE 教师，下游微调仍然需要复杂的硬件和软件协同设计。下游自然语言理解任务的结果如表 3 所示。总的来说，我们可以观察到 OneS 在所有任务上超越了 ALBERT 和基线（即 Distill 和 Switch），实现了 88.2% 的 MoE 好处。例如，在四项任务上，OneS 平均超过 Switch 0.42 个百分点。此外，我们在 Switch 和 Distill 上分别实现了 53.2% 和 51.7% 的 MoE 好处。在一些任务上，例如 SQuAD1.1 和 SST-2，OneS 甚至超越了教师 MoE 模型 WideNet。我们建议 MoE 模型倾向于在小数据集上过拟合。OneS 拥有 MoE 的知识，但结构密集，因此预训练的好处可以更容易地传播到下游任务。与 MoE 模型相比，OneS 的另一个优势是推理速度。MoE 之所以如此缓慢，是因为 MoE 模型由于条件计算而具有门控函数和稀疏 einsum 操作符，这会降低计算效率。然而，我们的模型可以实现 3.7 倍的推理加速。请注意，WideNet 仅在 MoE 层使用 2.4 倍 FLOPs。对于其他层，WideNet 与 OneS 或 ALBERT 具有相同的计算成本，因此全局 FLOPs 小于 OneS 的 2.4 倍。因此，OneS 能够实现如此高效率的一个原因是计算更少，另一个重要原因是，密集模型比稀疏 MoE 模型更受硬件欢迎。</p>
<h3 id="43-消融研究">4.3. 消融研究<a class="anchor-link" href="#43-消融研究" title="Permanent link">&para;</a></h3>
<p>我们在这工作中进行了四组消融研究。第一组是调查知识收集和知识蒸馏的贡献。如表 4 所示，没有知识收集，性能显著下降，表明预训练稀疏模型中包含的知识对提高学生模型的性能至关重要。对于没有 KD 的模型，在这次实验中，我们采用方程 18 中的 <span class="math-inline">L_{\text{main}}</span> 作为唯一的损失函数。我们可以看到知识蒸馏是有帮助的，因为教师的预测可以指导学生挖掘收集到的噪声权重中的知识。此外，当密集模型没有从 MoE 收集知识时，KD 可以使轻量级模型（即 OneS-B）的训练过程更加稳定。对于大型模型，同时移除知识收集和知识蒸馏也会损害性能。由于我们的框架中进行了两个阶段的训练，OneS 的总训练步骤超过了没有蒸馏的从零开始训练的密集模型。第二组消融研究是为了验证我们模型的改进是否来自于更多的训练迭代。为此，我们训练了没有 KG 和 KD 的 OneS，进行了可比的全局训练周期。我们使用 OneS-L 作为这组实验的平台，因为我们观察到没有 KG 和 KD 的 OneS-B 训练不稳定。如图 3 所示，当训练具有可比全局周期时，我们的 OneS 始终以较大优势超越基线。此外，当扩展到更多周期时，没有 MoE 的 WideNet 停止改进，但我们的 OneS 仍然可以从更多的训练中获益。我们还研究了两种类型的知识蒸馏方法，软蒸馏 [9] 和硬标签蒸馏 [24]。最后一组是消融 SVD 比率 <span class="math-inline">\lambda</span>。详情请参见附录 C 和附录 D。</p>
<h2 id="5-结论和未来工作">5. 结论和未来工作<a class="anchor-link" href="#5-结论和未来工作" title="Permanent link">&para;</a></h2>
<p>在这篇论文中，受人类教育模型的启发，我们提出了知识整合，一个新的任务，以结合 MoE 模型的有效性和密集模型的可用性。作为第一项专注于此任务的工作，我们的解决方案是分两步整合知识（即知识收集和知识蒸馏）。知识收集侧重于从预训练的 MoE 收集知识以初始化密集学生模型。知识蒸馏是进一步提炼密集模型。实验表明，我们的 OneS 在计算机视觉和自然语言处理任务上取得了出色的有效性和效率。值得注意的是，我们的 OneS 甚至可以在 0.42× FLOPs 每 MoE 或 FFN 层，3.7 倍推理加速和 46% 可训练参数的情况下保留 88.2% 的好处。未来，我们计划探索更先进的知识收集和蒸馏方法，以更好地将 MoE 的知识整合到密集学生中。此外，尽管大多数最近的基于 MoE 的变换器对不同专家使用相同的架构，但研究从具有不同架构的专家那里收集知识的方法是有价值的。最后，我们期望将我们的方法适应于像 GLaM[7] 这样的非常大的 MoE 模型。</p>
                </div>

                <!-- Comments Section (Giscus) -->
                <section class="comments-section">
                    <h3><i class="fas fa-comments"></i> 评论</h3>
                    <script src="https://giscus.app/client.js"
                        data-repo="Geeks-Z/Geeks-Z.github.io"
                        data-repo-id=""
                        data-category="Announcements"
                        data-category-id=""
                        data-mapping="pathname"
                        data-strict="0"
                        data-reactions-enabled="1"
                        data-emit-metadata="0"
                        data-input-position="bottom"
                        data-theme="preferred_color_scheme"
                        data-lang="zh-CN"
                        crossorigin="anonymous"
                        async>
                    </script>
                </section>
            </article>

            <footer class="post-footer">
                <p>© 2025 Hongwei Zhao. Built with ❤️</p>
            </footer>
        </main>
    </div>

    <!-- Theme Toggle Button -->
    <button class="theme-toggle" id="themeToggle" aria-label="切换主题">
        <i class="fas fa-moon"></i>
    </button>

    <script>
        // Theme Toggle
        const themeToggle = document.getElementById('themeToggle');
        const html = document.documentElement;
        const icon = themeToggle.querySelector('i');
        const hljsDark = document.getElementById('hljs-theme-dark');
        const hljsLight = document.getElementById('hljs-theme-light');
        
        // Check saved theme or system preference
        const savedTheme = localStorage.getItem('theme');
        const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
        
        if (savedTheme === 'dark' || (!savedTheme && prefersDark)) {
            html.setAttribute('data-theme', 'dark');
            icon.className = 'fas fa-sun';
            hljsDark.disabled = false;
            hljsLight.disabled = true;
        }
        
        themeToggle.addEventListener('click', () => {
            const isDark = html.getAttribute('data-theme') === 'dark';
            if (isDark) {
                html.removeAttribute('data-theme');
                icon.className = 'fas fa-moon';
                localStorage.setItem('theme', 'light');
                hljsDark.disabled = true;
                hljsLight.disabled = false;
            } else {
                html.setAttribute('data-theme', 'dark');
                icon.className = 'fas fa-sun';
                localStorage.setItem('theme', 'dark');
                hljsDark.disabled = false;
                hljsLight.disabled = true;
            }
            
            // Update Giscus theme
            const giscusFrame = document.querySelector('iframe.giscus-frame');
            if (giscusFrame) {
                giscusFrame.contentWindow.postMessage({
                    giscus: {
                        setConfig: {
                            theme: isDark ? 'light' : 'dark'
                        }
                    }
                }, 'https://giscus.app');
            }
        });
        
        // Highlight.js
        document.addEventListener('DOMContentLoaded', () => {
            hljs.highlightAll();
        });
        
        // KaTeX auto-render
        document.addEventListener('DOMContentLoaded', () => {
            if (typeof renderMathInElement !== 'undefined') {
                renderMathInElement(document.body, {
                    delimiters: [
                        {left: '$$', right: '$$', display: true},
                        {left: '$', right: '$', display: false},
                        {left: '\\[', right: '\\]', display: true},
                        {left: '\\(', right: '\\)', display: false}
                    ],
                    throwOnError: false
                });
            }
        });
        
        // TOC active state
        const tocLinks = document.querySelectorAll('.toc-container a');
        const headings = document.querySelectorAll('.post-content h2, .post-content h3, .post-content h4');
        
        function updateTocActive() {
            let current = '';
            headings.forEach(heading => {
                const rect = heading.getBoundingClientRect();
                if (rect.top <= 100) {
                    current = heading.getAttribute('id');
                }
            });
            
            tocLinks.forEach(link => {
                link.classList.remove('active');
                if (link.getAttribute('href') === '#' + current) {
                    link.classList.add('active');
                }
            });
        }
        
        window.addEventListener('scroll', updateTocActive);
        updateTocActive();
    </script>
</body>
</html>
