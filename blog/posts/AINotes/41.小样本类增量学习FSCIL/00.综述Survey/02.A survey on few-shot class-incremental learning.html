<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Untitled</title>
    <meta name="description" content="Untitled - Hongwei Zhao's Blog">
    <meta name="author" content="Hongwei Zhao">
    
    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Noto+Sans+SC:wght@300;400;500;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    
    <!-- Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <!-- Code Highlighting -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css" id="hljs-theme-dark">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css" id="hljs-theme-light" disabled>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    
    <!-- KaTeX for Math -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>
    
    <style>
        :root {
            /* Light Theme - 明亮清新配色 */
            --primary-color: #4A90D9;
            --primary-hover: #3678C2;
            --link-color: #E86B5F;
            --text-color: #2D2D2D;
            --text-light: #5A5A5A;
            --text-muted: #8A8A8A;
            --bg-color: #FFFFFF;
            --bg-secondary: #F5F7FA;
            --bg-code: #F8F9FC;
            --border-color: #E8ECF0;
            --shadow: 0 2px 8px rgba(0,0,0,0.06);
            --shadow-lg: 0 8px 24px rgba(0,0,0,0.08);
        }

        [data-theme="dark"] {
            --primary-color: #5dade2;
            --primary-hover: #85c1e9;
            --link-color: #e74c3c;
            --text-color: #e5e7eb;
            --text-light: #9ca3af;
            --text-muted: #6b7280;
            --bg-color: #1a1a2e;
            --bg-secondary: #16213e;
            --bg-code: #0f0f23;
            --border-color: #374151;
            --shadow: 0 1px 3px rgba(0,0,0,0.3);
            --shadow-lg: 0 4px 15px rgba(0,0,0,0.4);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            scroll-behavior: smooth;
        }

        body {
            font-family: 'Inter', 'Noto Sans SC', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            font-size: 16px;
            line-height: 1.8;
            color: var(--text-color);
            background: var(--bg-color);
            transition: background-color 0.3s, color 0.3s;
        }

        a {
            color: var(--primary-color);
            text-decoration: none;
            transition: color 0.2s;
        }

        a:hover {
            color: var(--primary-hover);
            text-decoration: underline;
        }

        /* Layout */
        .page-wrapper {
            display: flex;
            max-width: 1400px;
            margin: 0 auto;
            padding: 2rem;
            gap: 3rem;
        }

        /* Sidebar TOC */
        .toc-sidebar {
            width: 260px;
            flex-shrink: 0;
            position: sticky;
            top: 2rem;
            height: fit-content;
            max-height: calc(100vh - 4rem);
            overflow-y: auto;
        }

        .toc-container {
            background: var(--bg-secondary);
            border-radius: 12px;
            padding: 1.5rem;
            border: 1px solid var(--border-color);
        }

        .toc-container h3 {
            font-size: 0.85rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-muted);
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .toc-container ul {
            list-style: none;
        }

        .toc-container li {
            margin-bottom: 0.5rem;
        }

        .toc-container a {
            font-size: 0.9rem;
            color: var(--text-light);
            display: block;
            padding: 0.25rem 0;
            border-left: 2px solid transparent;
            padding-left: 0.75rem;
            transition: all 0.2s;
        }

        .toc-container a:hover,
        .toc-container a.active {
            color: var(--primary-color);
            border-left-color: var(--primary-color);
            text-decoration: none;
        }

        .toc-container ul ul {
            margin-left: 1rem;
        }

        /* Main Content */
        .main-content {
            flex: 1;
            min-width: 0;
            max-width: 800px;
        }

        /* Header */
        .post-header {
            margin-bottom: 2rem;
            padding-bottom: 1.5rem;
            border-bottom: 1px solid var(--border-color);
        }

        .back-link {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.9rem;
            color: var(--text-light);
            margin-bottom: 1.5rem;
        }

        .back-link:hover {
            color: var(--primary-color);
            text-decoration: none;
        }

        .post-header h1 {
            font-size: 2.25rem;
            font-weight: 700;
            line-height: 1.3;
            margin-bottom: 1rem;
            color: var(--text-color);
        }

        .post-meta {
            display: flex;
            flex-wrap: wrap;
            gap: 1.5rem;
            font-size: 0.9rem;
            color: var(--text-light);
        }

        .post-meta span {
            display: flex;
            align-items: center;
            gap: 0.4rem;
        }

        .post-meta i {
            color: var(--text-muted);
        }

        .tags {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-top: 1rem;
        }

        .tag {
            display: inline-block;
            font-size: 0.8rem;
            background: var(--bg-secondary);
            color: var(--text-light);
            padding: 0.25rem 0.75rem;
            border-radius: 20px;
            border: 1px solid var(--border-color);
            transition: all 0.2s;
        }

        .tag:hover {
            background: var(--primary-color);
            color: white;
            border-color: var(--primary-color);
        }

        /* Article Content */
        .post-content {
            font-size: 1rem;
            line-height: 1.9;
        }

        .post-content h1,
        .post-content h2,
        .post-content h3,
        .post-content h4,
        .post-content h5,
        .post-content h6 {
            margin-top: 2rem;
            margin-bottom: 1rem;
            font-weight: 600;
            line-height: 1.4;
            color: var(--text-color);
        }

        .post-content h1 { font-size: 1.875rem; }
        .post-content h2 { 
            font-size: 1.5rem; 
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--border-color);
        }
        .post-content h3 { font-size: 1.25rem; }
        .post-content h4 { font-size: 1.125rem; }

        .post-content p {
            margin-bottom: 1.25rem;
        }

        .post-content ul,
        .post-content ol {
            margin: 1.25rem 0;
            padding-left: 1.5rem;
        }

        .post-content li {
            margin-bottom: 0.5rem;
        }

        .post-content blockquote {
            margin: 1.5rem 0;
            padding: 1rem 1.5rem;
            background: var(--bg-secondary);
            border-left: 4px solid var(--primary-color);
            border-radius: 0 8px 8px 0;
            color: var(--text-light);
            font-style: italic;
        }

        .post-content blockquote p:last-child {
            margin-bottom: 0;
        }

        /* Code */
        .post-content code {
            font-family: 'JetBrains Mono', 'Fira Code', Consolas, monospace;
            font-size: 0.9em;
            background: var(--bg-code);
            padding: 0.2em 0.4em;
            border-radius: 4px;
            color: var(--link-color);
        }

        .post-content pre {
            margin: 1.5rem 0;
            padding: 1.25rem;
            background: var(--bg-code);
            border-radius: 10px;
            overflow-x: auto;
            border: 1px solid var(--border-color);
        }

        .post-content pre code {
            background: none;
            padding: 0;
            color: inherit;
            font-size: 0.875rem;
            line-height: 1.6;
        }

        /* Images */
        .post-content img {
            max-width: 100%;
            height: auto;
            border-radius: 10px;
            margin: 1.5rem 0;
            box-shadow: var(--shadow-lg);
        }

        /* Tables */
        .post-content table {
            width: 100%;
            margin: 1.5rem 0;
            border-collapse: collapse;
            font-size: 0.95rem;
        }

        .post-content th,
        .post-content td {
            padding: 0.75rem 1rem;
            border: 1px solid var(--border-color);
            text-align: left;
        }

        .post-content th {
            background: var(--bg-secondary);
            font-weight: 600;
        }

        .post-content tr:nth-child(even) {
            background: var(--bg-secondary);
        }

        /* Math */
        .math-display {
            margin: 1.5rem 0;
            overflow-x: auto;
            padding: 1rem;
            background: var(--bg-secondary);
            border-radius: 8px;
        }

        /* Anchor links */
        .anchor-link {
            opacity: 0;
            margin-left: 0.5rem;
            color: var(--text-muted);
            font-weight: 400;
            transition: opacity 0.2s;
        }

        .post-content h2:hover .anchor-link,
        .post-content h3:hover .anchor-link,
        .post-content h4:hover .anchor-link {
            opacity: 1;
        }

        /* Theme Toggle */
        .theme-toggle {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: var(--primary-color);
            color: white;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.25rem;
            box-shadow: var(--shadow-lg);
            transition: transform 0.2s, background 0.2s;
            z-index: 1000;
        }

        .theme-toggle:hover {
            transform: scale(1.1);
            background: var(--primary-hover);
        }

        /* Comments Section */
        .comments-section {
            margin-top: 3rem;
            padding-top: 2rem;
            border-top: 1px solid var(--border-color);
        }

        .comments-section h3 {
            font-size: 1.25rem;
            margin-bottom: 1.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        /* Footer */
        .post-footer {
            margin-top: 3rem;
            padding-top: 1.5rem;
            border-top: 1px solid var(--border-color);
            text-align: center;
            font-size: 0.9rem;
            color: var(--text-muted);
        }

        /* Responsive */
        @media (max-width: 1024px) {
            .toc-sidebar {
                display: none;
            }
            
            .page-wrapper {
                padding: 1.5rem;
            }
        }

        @media (max-width: 768px) {
            .post-header h1 {
                font-size: 1.75rem;
            }
            
            .post-meta {
                flex-direction: column;
                gap: 0.5rem;
            }
            
            .theme-toggle {
                bottom: 1rem;
                right: 1rem;
                width: 44px;
                height: 44px;
            }
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-secondary);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--text-muted);
        }
    </style>
</head>
<body>
    <div class="page-wrapper">
        <!-- TOC Sidebar -->
        <aside class="toc-sidebar">
            <div class="toc-container">
                <h3><i class="fas fa-list"></i> 目录</h3>
                <div class="toc">
<ul>
<li><a href="#a-survey-on-few-shot-class-incremental-learning">A survey on few-shot class-incremental learning</a></li>
<li><a href="#摘要">摘要</a></li>
<li><a href="#1-引言">1. 引言</a></li>
<li><a href="#2-问题定义">2. 问题定义</a><ul>
<li><a href="#21-问题形式化">2.1 问题形式化</a></li>
<li><a href="#22-相关学习问题">2.2 相关学习问题</a></li>
<li><a href="#23-少样本类别增量学习的变体">2.3 少样本类别增量学习的变体</a></li>
</ul>
</li>
<li><a href="#3-少样本学习方法">3. 少样本学习方法</a><ul>
<li><a href="#31-数据增强方法">3.1 数据增强方法</a></li>
<li><a href="#32-基于度量的方法">3.2 基于度量的方法</a></li>
<li><a href="#33-基于模型的方法">3.3 基于模型的方法</a></li>
<li><a href="#34-基于优化的方法">3.4 基于优化的方法</a></li>
</ul>
</li>
<li><a href="#4-少样本类别增量学习分类法">4. 少样本类别增量学习：分类法</a><ul>
<li><a href="#41-传统机器学习方法">4.1 传统机器学习方法</a><ul>
<li><a href="#411-监督学习策略">4.1.1 监督学习策略</a></li>
<li><a href="#412-统计分布">4.1.2 统计分布</a></li>
<li><a href="#413-函数优化">4.1.3 函数优化</a></li>
</ul>
</li>
<li><a href="#42-基于元学习的方法">4.2 基于元学习的方法</a><ul>
<li><a href="#421-原型学习">4.2.1 原型学习</a></li>
<li><a href="#422-元过程">4.2.2 元过程</a></li>
</ul>
</li>
<li><a href="#43-基于特征和特征空间的方法">4.3 基于特征和特征空间的方法</a></li>
<li><a href="#44-基于重放的方法">4.4 基于重放的方法</a></li>
<li><a href="#45-基于动态网络结构的方法">4.5 基于动态网络结构的方法</a></li>
</ul>
</li>
<li><a href="#5-实验结果与性能评估">5. 实验结果与性能评估</a></li>
<li><a href="#6-应用领域">6. 应用领域</a></li>
<li><a href="#7-未来研究方向">7. 未来研究方向</a></li>
<li><a href="#8-结论">8. 结论</a></li>
</ul>
</div>

            </div>
        </aside>

        <!-- Main Content -->
        <main class="main-content">
            <article>
                <header class="post-header">
                    <a href="../../../../index.html" class="back-link">
                        <i class="fas fa-arrow-left"></i> 返回博客列表
                    </a>
                    <h1>Untitled</h1>
                    <div class="post-meta">
                        <span><i class="fas fa-calendar-alt"></i> 2026-02-04</span>
                        <span><i class="fas fa-folder"></i> AINotes/41.小样本类增量学习FSCIL/00.综述Survey</span>
                        <span><i class="fas fa-user"></i> Hongwei Zhao</span>
                    </div>
                    <div class="tags">
                        
                    </div>
                </header>

                <div class="post-content">
                    <h2 id="a-survey-on-few-shot-class-incremental-learning"><a href="https://arxiv.org/abs/2304.08130">A survey on few-shot class-incremental learning</a><a class="anchor-link" href="#a-survey-on-few-shot-class-incremental-learning" title="Permanent link">&para;</a></h2>
<blockquote>
<p>Neural Networks 2024</p>
</blockquote>
<h2 id="摘要">摘要<a class="anchor-link" href="#摘要" title="Permanent link">&para;</a></h2>
<p>虽然大型深度学习模型表现出色，但在实时数据不可用时表现不佳。少样本类别增量学习（Few-shot Class-incremental Learning，FSCIL）对深度神经网络提出了重大挑战，要求其在不忘记之前学过的内容的情况下，仅通过少量标记样本学习新任务。这种设置容易导致<strong>灾难性遗忘</strong>和<strong>过拟合</strong>问题，严重影响模型性能。研究 FSCIL 有助于克服深度学习模型在数据量和获取时间方面的局限性，提高机器学习模型的实用性和适应性。本文对 FSCIL 进行了全面综述。与之前的综述不同，我们从两方面综合介绍了少样本学习和增量学习，回顾了 30 多项理论研究和 20 多项应用研究。从理论角度，我们提出了一种新的分类方法，将该领域分为五个子类：传统机器学习方法、基于元学习的方法、基于特征和特征空间的方法、基于重放的方法和基于动态网络结构的方法。我们还评估了近期理论研究在 FSCIL 基准数据集上的性能。从应用角度来看，FSCIL 在图像分类、目标检测和图像分割等计算机视觉领域，以及自然语言处理和图分析领域取得了显著成就。我们总结了重要的应用。最后，我们指出了未来研究的潜在方向，包括应用、问题设置和理论发展。总体而言，本文从方法、性能和应用角度对 FSCIL 的最新进展进行了全面分析。</p>
<h2 id="1-引言">1. 引言<a class="anchor-link" href="#1-引言" title="Permanent link">&para;</a></h2>
<p>近年来，计算技术的显著进步和大规模数据集的广泛可用，使深度神经网络（Deep Neural Networks，DNNs）在各种计算机视觉任务中取得了令人瞩目的进展。然而，许多这些成功依赖于理想化的假设和大量可用的训练数据，这可能无法准确反映高质量数据通常稀缺的现实场景。例如，在数据分批增量到达且新增加的类别包含很少样本的场景下，许多现有方法证明是无效的。</p>
<p>少样本类别增量学习（Few-shot Class-incremental Learning，FSCIL）的目标是赋予 AI 解决上述挑战的能力。这需要 DNN 模型从少量标记样本中逐步学习新任务而不忘记先前学习的内容（Tao 等，2020）。自 Tao 等在 2020 年首次提出 FSCIL 的概念以来，许多学者将其扩展到视觉任务以外的各种应用场景，因为它符合人类学习模式并适用于现实应用。</p>
<p>FSCIL 的一个直观方法是对基础模型进行微调，以适应新的训练集。然而，这会导致灾难性遗忘（McCloskey &amp; Cohen，1989）和过拟合，对应两个核心挑战：稳定性-可塑性困境和不可靠的经验风险最小化。</p>
<ul>
<li>
<p>稳定性-可塑性困境<br />
  稳定性-可塑性困境反映了稳定性与可塑性之间的矛盾。稳定性意味着神经网络应保持其学到的知识并抵抗新输入引起的变化。相反，可塑性意味着网络应具备适应新输入或任务的能力。灾难性遗忘可以被视为稳定性-可塑性困境的表现。在增量学习（Incremental Learning，IL）中，过于稳定的模型可能无法有效地学习新任务或数据。相反，过于可塑的模型可能会迅速丧失先前学习的任务或数据的信息。详见图 1(a)。</p>
</li>
<li>
<p>不可靠的经验风险最小化<br />
  在传统机器学习框架中，经验风险最小化（Empirical Risk Minimization，ERM）旨在优化训练数据上的平均损失。这种策略在大规模数据环境中效果良好，因样本量足以确保训练期间的统计一致性。然而，在少样本学习（Few-shot Learning，FSL）背景下，这种策略面临称为不可靠的经验风险最小化问题（Wang, Yao, Kwok, &amp; Ni，2020）。该问题的核心在于，当训练样本数量有限或样本中存在噪声时，ERM 策略可能导致过拟合。过拟合意味着模型在训练数据上表现良好，但在新、未见过的数据上泛化性能差。这种缺陷的产生是因为有限的数据可能无法完全代表整个数据生成过程的真实分布，导致模型捕捉到数据中的随机噪声而非潜在的真实模式。详见图 1(b)。</p>
</li>
</ul>
<div align=center><img src="https://markdownimg-hw.oss-cn-beijing.aliyuncs.com/20240803120540.png" style="zoom: 60%;" /></div>

<p>FSCIL 需要克服这两个挑战，难度更大。除了上述挑战外，由于新旧类别之间的样本数量差异很大，模型在训练或预测过程中往往倾向于旧类别的较大训练样本集，且基础类和新类样本之间的不平衡也使得模型难以学习新类别（Chen &amp; Lee，2021；Hou 等，2019；Tao 等，2020）。</p>
<p>尽管 FSCIL 在现实应用中具有巨大潜力并获得了研究人员的高度关注，但它仍然是一个相对未被充分探索的领域，缺乏全面的综述。现有的综述主要集中于 FSL 或 IL，而非 FSCIL。例如，Parisi 等（2019）关注终身学习，虽然内容丰富，但未能反映最新进展。Wang, Yao, 等（2020）介绍了 FSL 的理论基础，并从不同角度分类 FSL 方法。Belouadah 等（2021）总结了视觉任务中的类别 IL。Zhou 等（2023）从数据、模型和算法三个方面总结了深度类别 IL 的最新进展。</p>
<p>我们的 FSCIL 领域贡献如下：</p>
<ol>
<li>深入分析了 FSCIL 的基础和应用研究。我们的全面综述探讨了各种 FSCIL 方法，突出了它们的优势、局限性及其在基准数据集上的表现。</li>
<li>重新审视了各种 FSCIL 方法的理论基础和实际实现，并提出了一种基于方法或技术的分类框架。这一框架为研究人员和从业者提供了有用的指南。</li>
<li>评估了各种 FSCIL 方法在基准数据集上的表现，提供了不同方法的优劣势洞见。</li>
<li>讨论了 FSCIL 在计算机视觉、自然语言处理和图分析等领域的应用，突显了 FSCIL 广泛的应用范围及其潜在影响。</li>
<li>识别了 FSCIL 领域未来工作的开放研究挑战和机会，为未来研究提供了路线图。</li>
</ol>
<p>本文其余部分组织如下。第 2 节介绍 FSCIL 的问题定义及相关研究背景。第 3 节回顾 FSL 中的方法和显著架构。第 4 节总结现有的 FSCIL 方法，包括传统机器学习方法、基于元学习的方法、基于特征和特征空间的方法、基于重放的方法和基于动态网络结构的方法。第 5 节展示了不同 FSCIL 方法在基准数据集上的表现。第 6 节讨论了 FSCIL 在不同领域的应用。第 7 节概述了 FSCIL 领域的未来研究方向。最后，第 8 节总结全文。</p>
<h2 id="2-问题定义">2. 问题定义<a class="anchor-link" href="#2-问题定义" title="Permanent link">&para;</a></h2>
<p>在监督学习中，我们希望学习一个函数 <span class="math-inline">f \in \mathcal{F} : \mathcal{X} \to \mathcal{Y}</span>，能够预测目标向量 <span class="math-inline">y \in \mathcal{Y}</span>，对于给定的输入样本 <span class="math-inline">x \in \mathcal{X}</span>。为此，模型需要使用充足实例的训练数据进行训练：</p>
<p><div class="math-display">D = {(x_i, y_i)}_{i=1}^N</div></p>
<p>该数据集包含来自分布 <span class="math-inline">P(\mathcal{X}, \mathcal{Y})</span> 的独立同分布样本。通过最小化期望风险来训练此函数 <span class="math-inline">f</span>：</p>
<p><div class="math-display">\varepsilon_{\text{ex}} = \mathbb{E}_{(x,y) \sim P(\mathcal{X}, \mathcal{Y})} [\ell(f(x), y)]</div></p>
<p>其中，<span class="math-inline">\ell(\cdot, \cdot)</span> 表示预测值与实际标签之间的差异。然而，由于联合分布 <span class="math-inline">P</span> 是未知的，实际的学习算法旨在最小化经验风险：</p>
<p><div class="math-display">\varepsilon_{\text{em}} = \mathbb{E}*{(x,y) \sim D} [\ell(f(x), y)]</div></p>
<h3 id="21-问题形式化">2.1 问题形式化<a class="anchor-link" href="#21-问题形式化" title="Permanent link">&para;</a></h3>
<div align=center><img src="https://markdownimg-hw.oss-cn-beijing.aliyuncs.com/20240803120730.png"  /></div>

<p>图 2 展示了数据集划分形式和 FSCIL 实验设置。FSCIL 任务包括一个具有充足训练数据的基础阶段和多个具有有限训练数据的增量阶段。每个阶段的学习过程仅涉及当前任务相关的数据，同时模型还需要在获取新任务时保留先前任务的知识。任务是从连续数据流中以类别增量形式训练模型。</p>
<p>FSCIL 问题定义如下。假设有一个 <span class="math-inline">m</span> 步的 FSCIL 任务。令：</p>
<p><div class="math-display">{ D_{\text{train}}^{(0)}, D_{\text{train}}^{(1)}, \ldots, D_{\text{train}}^{(m)} }</div></p>
<p>和</p>
<p><div class="math-display">{ D_{\text{test}}^{(0)}, D_{\text{test}}^{(1)}, \ldots, D_{\text{test}}^{(m)} }</div></p>
<p>分别表示阶段<span class="math-inline">{0, 1, ..., m}</span> 训练和测试数据。对于第 <span class="math-inline">j</span> 阶段，其训练数据 <span class="math-inline">D_{\text{train}}^{(j)}</span> 的标签空间为 <span class="math-inline">\mathcal{Y}<em>j</span>。不同阶段的训练数据是互不重叠的，即 <span class="math-inline">\mathcal{Y}_a \cap \mathcal{Y}_b = \varnothing</span>（当 <span class="math-inline">a \neq b</span> 时）。训练数据中有限的实例可以组织成 <span class="math-inline">N</span>-way <span class="math-inline">K</span>-shot 数据格式，即数据集中有 <span class="math-inline">N</span> 个类别，每个类别有 <span class="math-inline">K</span> 个训练图像。面对新数据集 <span class="math-inline">D</em>{\text{train}}^{(j)}</span>，模型应学习新类别，同时在旧类别上保持性能，即最小化所有已见类别的期望风险：</p>
<p><div class="math-display">\mathbb{E}<em>{(x,y) \sim D</em>{\text{train}}^{(0)} \cup D_{\text{train}}^{(1)} \cup \ldots \cup D_{\text{train}}^{(j)}} [\ell(f(x; D_{\text{train}}^{(j)}, W_{j-1}), y)]</div></p>
<p>其中，学习算法 <span class="math-inline">f</span> 应基于新数据集 <span class="math-inline">D_{\text{train}}^{(j)}</span> 和当前旧模型 <span class="math-inline">W_{j-1}</span> 构建新模型，并最小化所有已见类别的损失。在测试期间，模型将在迄今为止所有已见类别上进行评估。对于第 <span class="math-inline">j</span> 阶段，其测试数据 <span class="math-inline">D_{\text{test}}^{(j)}</span> 的标签空间为 <span class="math-inline">\mathcal{Y}_0 \cup \mathcal{Y}_1 \cup \ldots \cup \mathcal{Y}_j</span>。</p>
<h3 id="22-相关学习问题">2.2 相关学习问题<a class="anchor-link" href="#22-相关学习问题" title="Permanent link">&para;</a></h3>
<p><strong>少样本学习</strong>（Few-shot Learning, FSL）。人类非常擅长通过少量样本识别新对象。例如，孩子可以通过书中的几张图片认出“斑马”或“犀牛”。受人类快速学习能力的启发，研究人员希望机器学习模型在学习大量数据后，能够仅通过少量样本快速学习新类别。这是 FSL 要解决的问题。近年来，FSL 概念受到广泛关注，在图像分类领域涌现了许多优秀的算法模型（Finn 等，2017；Snell 等，2017；Zhang 等，2018）。FSL 方法主要分为三类<strong>：基于微调、基于数据增强和基于迁移学习的方法。</strong></p>
<p>考虑一个学习任务 <span class="math-inline">T</span>，FSL 处理一个数据集 <span class="math-inline">D = {D_{\text{train}}, D_{\text{test}}}</span>。它包括一个训练集 <span class="math-inline">D_{\text{train}} = {(x_i, y_i)}<em>{i=1}^I</span>，其中样本量很小，以及一个测试集 <span class="math-inline">D</em>{\text{test}} = {x_{\text{test}}}</span>。通常，一个 <span class="math-inline">N</span>-way <span class="math-inline">K</span>-shot 分类任务中，<span class="math-inline">D_{\text{train}}</span> 包含 <span class="math-inline">I = KN</span> 个来自 <span class="math-inline">N</span> 个类别、每类 <span class="math-inline">K</span> 个样本的实例。FSL 主要是一个监督学习问题（Wang, Yao, 等，2020）。由于训练集样本量小，模型偏差 <span class="math-inline">\varepsilon = |\varepsilon_{\text{ex}} - \varepsilon_{\text{em}}|</span> 很大，难以学习到高质量的预测函数 <span class="math-inline">f \in \mathcal{F} : \mathcal{X} \to \mathcal{Y}</span>。</p>
<p><strong>一样本学习</strong>（One-shot Learning）。20 世纪 80 年代末和 90 年代初，一些研究人员已经注意到一样本学习的问题。直到 2003 年，Fe-Fei 等正式提出了这一概念。他们认为，当一个新类别只有一个或少量标记样本时，先前学到的旧类别可以帮助预测新类别（Fei-Fei 等，2006）。在 <span class="math-inline">N</span>-way <span class="math-inline">K</span>-shot 范式中，当 <span class="math-inline">N=1</span> 时，FSL 被称为一样本学习问题。由于设置相似，在大多数情况下无需区分这两个概念。</p>
<p><strong>零样本学习</strong>（Zero-shot Learning, ZSL）。在 <span class="math-inline">N</span>-way <span class="math-inline">K</span>-shot 范式中，当 <span class="math-inline">N=0</span> 时，FSL 成为零样本学习问题（Palatucci 等，2009）。由于 ZSL 不包含带有监督信息的样本，它通过利用语义标签属性信息在没有训练样本的情况下识别新样本类别。这种方法受人类学习和推理能力的启发，使计算机具备迁移和推理能力。具体来说，ZSL 的训练数据表示为 <span class="math-inline">S = {(x, y, a(y)) | x \in \mathcal{X}_S, y \in \mathcal{Y}_S, a(y) \in \mathcal{A}}</span>，其中 <span class="math-inline">\mathcal{X}_S</span> 是已见类别的图像/特征集，<span class="math-inline">\mathcal{Y}_S</span> 是已见类别标签集，<span class="math-inline">a(y)</span> 是类别 <span class="math-inline">y</span> 的语义嵌入。测试集表示为 <span class="math-inline">U = {(x, y, a(y)) | x \in \mathcal{X}_U, y \in \mathcal{Y}_U, a(y) \in \mathcal{A}}</span>，其中 <span class="math-inline">\mathcal{X}_U</span> 是未见类别的图像/特征集，<span class="math-inline">\mathcal{Y}_U</span> 是未见类别标签集，<span class="math-inline">\mathcal{Y}_U</span> 和 <span class="math-inline">\mathcal{Y}_C</span> 互不相交。</p>
<p><strong>元学习</strong>（Meta Learning）。元学习通常被理解为学习如何学习。它是从多个学习阶段中提取经验，并使用这些经验来改进未来学习性能的过程（Hospedales 等，2022）。元学习通常分为两个阶段。在元训练阶段，模型使用多个源（或训练）任务进行训练，以获得具有强泛化能力的初始网络参数。在元测试阶段，新任务的设置与源任务相同，但这些样本在训练过程中未曾见过。训练任务或测试任务中的每个任务被划分为支持集和查询集。元学习在计算机视觉、强化学习和架构搜索领域有广泛应用。元学习自然适用于 FSL，许多研究使用元学习作为 FSL 的手段，使模型能够从少量新任务样本中学习（Elsken 等，2020；Jamal &amp; Qi，2019；Ren 等，2018）。</p>
<p>迁移学习（Transfer Learning）。迁移学习（Zhuang 等，2020）关注知识在不同领域之间的转移，使知识从训练数据丰富的领域/任务转移到训练数据稀缺的新领域/任务。其定义如下：</p>
<p><strong>定义 1（迁移学习）。</strong> 给定源领域 <span class="math-inline">D_S</span> 和对应任务 <span class="math-inline">T_S</span>，目标领域 <span class="math-inline">D_T</span> 和对应任务 <span class="math-inline">T_T</span>。迁移学习的主要目的是利用从 <span class="math-inline">D_S</span> 和 <span class="math-inline">T_S</span> 中获得的知识，提高 <span class="math-inline">D_T</span> 和 <span class="math-inline">T_T</span> 的学习性能，其中 <span class="math-inline">D_S \neq D_T</span> 或 <span class="math-inline">T_S \neq T_T</span>（Pan &amp; Yang，2010）。</p>
<p>成功知识转移的关键在于两个学习活动之间的联系。如果领域之间的共同点很少，知识转移可能会失败，并对新任务产生负面影响。在日常生活中，人们进行许多迁移学习的实例，例如学习骑自行车，这使得学习骑摩托车变得更容易。迁移学习可以减少在构建学习机器时对大量目标领域数据的依赖，因此在零样本和少样本领域具有广泛应用，包括风格迁移、用于数据增强的特征空间迁移和跨领域的标签高效学习（Azadi 等，2018；Liu 等，2018；Luo 等，2018）。</p>
<p><strong>增量学习</strong>（Incremental Learning，IL）。IL 的定义也可以通过公式（3）表达，但与 FSCIL 的区别在于每个增量类别都有充足的样本。IL 也称为连续学习、终身学习或永无止境的学习，是一个日益受到关注的机器学习领域。它通常用于解决灾难性遗忘问题，即在学习新任务后先前学过的任务表现急剧下降。IL 的能力在于不断处理来自现实世界的信息流，同时保留、整合和优化旧知识。IL 提出的方法大致分为三类：基于重放的方法（replay-based methods）, 基于正则化的方法（regularizationbased methods）和参数隔离方法（parameter isolation methods）（De Lange 等，2021）。Van de Ven 和 Tolias（2019）提出了 IL 的三种场景：任务增量学习（Task-IL）、领域增量学习（Domain-IL）和类别增量学习（Class-IL）。类别增量学习被认为是最困难的，因为新增加的类别通常与已经学过的类别具有高度相似性。目前，只有基于重放的方法在类别增量学习中产生了可接受的结果。</p>
<h3 id="23-少样本类别增量学习的变体">2.3 少样本类别增量学习的变体<a class="anchor-link" href="#23-少样本类别增量学习的变体" title="Permanent link">&para;</a></h3>
<p><strong>广义少样本增量学习</strong>。在 FSCIL 出现之前，先前研究中已经提出了类似的设置，例如 Gidaris 和 Komodakis（2018）、Qi 等（2018）、Xie 等（2019）、Yoon 等（2020）提出的广义少样本增量学习（Generalized Few-shot Incremental Learning，GFSIL）。具体来说，预训练模型将通过少量实例学习新类别。GFSIL 的目标是保持旧类别和新类别的分类性能。然而，GFSIL 只有一个增量阶段，其数据划分格式与 FSCIL 不同。例如，CIFAR-100 随机分为 40、10 和 50 个类别，分别作为元训练集、元验证集和元测试集。GFSIL 被认为比 FSCIL 更具挑战性。为了应对 GFSIL 的挑战，Qi 等（2018）提出了一种利用少样本平均特征初始化方法，以少样本初始化新类别表示的方法。Gidaris 和 Komodakis（2018）引入了动态少样本学习，通过少样本分类器避免遗忘，使用基于注意力的权重生成器进行少样本分类。Ren 等（2019）提出了一种注意力吸引网络来调节新类别的学习。此外，Yoon 等（2020）提出了一种融合基础特征的方法，Ye 等（2021）提出了使用共享神经字典合成少样本分类器的想法。Xie 等（2019）引入了元模块生成（Meta Module Generation，MetaMG），利用元学习学习一组元模块，这些元模块是可以快速适应新任务的小型神经网络。在 IL 过程中，MetaMG 方法使用学习到的元模块生成新类别的任务特定模块。</p>
<p><strong>少样本增量学习</strong>。与 FSCIL 相似，Ayub 和 Wagner（2020a）研究了少样本增量学习（Few-shot Incremental Learning，FSIL）问题，并提出了一种认知启发的方法。他们将每个图像类别表示为质心。在 FSIL 的实验设置中，基础类别和增量类别的数量相同，这与 FSCIL 中基础数据丰富的设置不同。此外，为了解决 ZSL 中无法从数据流中学习的问题，Wei 等（2021）提出了增量零样本学习（Incremental Zero-shot Learning，IZSL）的概念。与传统 ZSL 不同，IZSL 涉及多个新类别的学习阶段。</p>
<p><strong>增量少样本目标检测</strong>。在增量少样本目标检测（Incremental Few-shot Object Detection，iFSD）设置中，丰富的基础类别样本和少量新类别样本是可用的。模型可以利用所有基础类别样本进行引导，因为模型学习新类别需要先验知识。配备了基础类别数据的先验知识后，模型在学习新类别知识时无法再次访问基础类别样本。换句话说，具备先验知识的模型应能够从未见类别的少量样本中学习，而无需重新学习基础知识，这与实际应用场景一致，其中预训练模型应能够逐步适应新信息。</p>
<p>尽管许多研究具有类似的 FSCIL 设置，但学术界当前的主流仍然集中在 FSCIL。因此，本综述主要关注更具挑战性的 FSCIL 研究。</p>
<h2 id="3-少样本学习方法">3. 少样本学习方法<a class="anchor-link" href="#3-少样本学习方法" title="Permanent link">&para;</a></h2>
<p>对于 FSL 任务，通常需要专门的网络架构或技巧来处理有限的标注数据。在 FSCIL 研究中，许多方法基于 FSL 的进展。在本节中，我们将重点介绍常用的 FSL 网络架构，不讨论方法的新颖性或有效性，它们可能不代表最新研究。</p>
<p>许多综述已经对 FSL 主题进行了研究，提出了各种分类方法（Jadon，2020；Song 等，2023；Wang, Yao, 等，2020）。一种直接的方法是将 FSL 分类为四类：数据增强方法、基于度量的方法、基于模型的方法和基于优化的方法（Jadon，2020）。接下来，我们将简要介绍这四类常用的网络架构。</p>
<h3 id="31-数据增强方法">3.1 数据增强方法<a class="anchor-link" href="#31-数据增强方法" title="Permanent link">&para;</a></h3>
<p>在 FSL 中，数据增强是一种重要策略。它通过增加现有数据的多样性来缓解数据稀缺问题，而不是收集新数据。数据增强显著减少了过拟合的风险，有效提高了模型的泛化能力。数据增强可以根据其来源分类：从训练集中变换样本，从弱标注或未标注数据集中变换样本，或从相似数据集中变换样本（Wang, Yao, 等，2020）。除了直接增强数据，还可以训练模型生成新样本或特征（Kong 等，2022），如 VAE 或 GAN，实现数据增强的目标。</p>
<h3 id="32-基于度量的方法">3.2 基于度量的方法<a class="anchor-link" href="#32-基于度量的方法" title="Permanent link">&para;</a></h3>
<p>基于度量的方法通过计算支持集和查询集中样本在嵌入空间中的相似性或距离来分类对象。例如，通过计算测试样本与支持集中每个类别之间的欧几里得距离，将测试样本分配给最近的支持集样本类别。在 FSL 中，常用的度量学习方法包括 Siamese Network（Koch 等，2015）、Matching Network（Vinyals 等，2016）和 Prototypical Network（Snell 等，2017）。图 3 展示了这三种方法的网络结构差异。这些方法不需要大量数据，而是优化度量以确保相似样本接近，不同类别样本远离。</p>
<div align=center><img src="https://markdownimg-hw.oss-cn-beijing.aliyuncs.com/20240805144211.png"/></div>

<h3 id="33-基于模型的方法">3.3 基于模型的方法<a class="anchor-link" href="#33-基于模型的方法" title="Permanent link">&para;</a></h3>
<p>基于模型的方法主要是设计或使用特定网络架构来应对 FSL 挑战。例如，记忆增强神经网络（Memory-Augmented Neural Networks，MANN）（Santoro 等，2016）使用外部存储空间显式存储类别信息，从而利用神经网络固有的长期记忆能力来执行 FSL 任务。元网络（Meta Networks）（Munkhdalai &amp; Yu，2017）通过快速参数化调整其归纳偏差以实现快速泛化，学习跨任务的元层知识。这些网络结构高效地利用有限数量的标注样本进行快速学习和适应。</p>
<h3 id="34-基于优化的方法">3.4 基于优化的方法<a class="anchor-link" href="#34-基于优化的方法" title="Permanent link">&para;</a></h3>
<p>基于优化的方法侧重于调整模型的训练策略，以适应有限标注数据的情况。它通常涉及修改损失函数、正则项或优化算法本身，以确保模型能在少样本数据上快速收敛而不过拟合。例如，模型无关的元学习（Model-Agnostic Meta-Learning，MAML）（Finn 等，2017）是一种常见的优化技术，可以从有限的新数据中快速学习知识。它使用各种数据集训练模型的初始参数，以确保在处理新任务时的最佳性能。在 MAML 的基础上，Reptile（Nichol &amp; Schulman，2018）通过将梯度计算从两步简化为一步来减少计算复杂度，从而提高计算速度。</p>
<h2 id="4-少样本类别增量学习分类法">4. 少样本类别增量学习：分类法<a class="anchor-link" href="#4-少样本类别增量学习分类法" title="Permanent link">&para;</a></h2>
<p>对于 FSCIL 的基础研究，目前没有统一的分类标准。Zou 等（2022）将 FSCIL 分为基于度量和基于微调的方法。基于度量的方法类似于 FSL（Snell 等，2017；Vinyals 等，2016）的概念，其关键问题在于原型表示和相似性度量。在 FSCIL 中，基于微调的方法被广泛使用，我们将其称为基础类预训练和新类微调（Base Classes Pretraining and Novel Classes Fine-tuning，BPNF）。</p>
<p><strong>定义 2（基础类预训练和新类微调）。</strong> BPNF 是一种常见的 FSCIL 方法，通过在数据丰富的基础数据上进行预训练，并在增量阶段微调模型以更好地适应新类别。该方法利用基础类学到的知识提高模型在新类别上的性能。</p>
<p>然而，上述分类方法过于宽泛，不适用于许多 FSCIL 研究。在本文中，我们总结了 33 项先进研究，并根据 FSCIL 中的关键点或技术将其分为五大类：</p>
<ul>
<li>传统机器学习方法</li>
<li>基于元学习的方法</li>
<li>基于特征和特征空间的方法</li>
<li>基于重放的方法</li>
<li>基于动态网络结构的方法</li>
</ul>
<p>图 4 按时间顺序显示了方法分类图。值得注意的是，虽然 FSCIL 的实验设置经常涉及元学习的思想，但这些方法未被归类为基于元学习的方法，因为所使用方法的关键点不是基于元学习技术。</p>
<div align=center><img src="https://markdownimg-hw.oss-cn-beijing.aliyuncs.com/20240805145108.png"/></div>

<h3 id="41-传统机器学习方法">4.1 传统机器学习方法<a class="anchor-link" href="#41-传统机器学习方法" title="Permanent link">&para;</a></h3>
<h4 id="411-监督学习策略">4.1.1 监督学习策略<a class="anchor-link" href="#411-监督学习策略" title="Permanent link">&para;</a></h4>
<p>通过增量过程微调的模型能力受到新类别样本数据量的限制。为缓解这一限制，除了依赖标注的监督数据外，一些研究引入了额外的半监督或无监督数据，以优化监督方法。</p>
<p>在 Cui 等（2021）中，将半监督学习引入 FSCIL，并基于 Tao 等（2020）的设置，在每个增量阶段引入 50 个未标注的数据。在训练过程中，未标注数据与标注数据结合，以增强 FSCIL 的性能。Ahmad 等（2022）提出利用自监督学习来缓解过拟合和灾难性遗忘。具体来说，除了用基础类数据训练 ResNet-18 模型外，还用自监督方法在大型数据集上训练更深的 ResNet-50 网络。然后冻结这两个网络，以拥有两个强大的特征提取器。两个特征向量集输入到高斯生成器中，以学习新类的模型并传递其特征。随后，通过特征融合加分类器，有效对抗遗忘，并适应新类的出现。Kalla 和 Biswas（2022）首次提出自监督随机分类器（Self-supervised Stochastic Classifier，S3C）来解决 FSCIL。分类器的随机性避免了对少样本新类的过拟合，同时结合自监督训练可更好地保留基础类知识。</p>
<h4 id="412-统计分布">4.1.2 统计分布<a class="anchor-link" href="#412-统计分布" title="Permanent link">&para;</a></h4>
<p>从统计分布角度来看，解决 FSCIL 问题涉及拟合现有数据集的模型，并预测类别的数据分布，这具有出色的模型可解释性。为了应对大规模类别分类任务中常见高斯过程分类的局限性，Achituve 等（2021）提出了 GP-Tree。GP-Tree 是一种基于树的层次模型，使用 Polya-Gamma 数据增强将数据拟合到高斯过程中，能够很好地适应类别数量和数据规模。Liu 等（2022）提出了可学习分布校准（Learnable Distribution Calibration，LDC）方法，基于参数化校准单元（PCU）。PCU 使用由均值向量和存储的协方差矩阵定义的高斯采样器初始化每个类别的特征分布，以生成一组特征样本。具体来说，IL 期间，高斯采样器生成足够的特征样本，形成旧类和新类的偏置分布。PCU 循环更新生成的特征样本，从而恢复旧类分布并校准新类分布。由于协方差矩阵的固定大小，该方法的内存消耗较低。两种方法在 FSCIL 中都取得了良好效果，但缺点是建模过程复杂。</p>
<h4 id="413-函数优化">4.1.3 函数优化<a class="anchor-link" href="#413-函数优化" title="Permanent link">&para;</a></h4>
<p>现有方法专注于在学习新任务时克服灾难性遗忘，而 Shi 等（2021）从函数优化角度分析了这一问题，发现基础类训练过程中获得的平坦局部最小值比尖锐最小值具有更好的泛化能力。平坦最小值是机器学习和优化理论中的一个重要概念（Hochreiter &amp; Schmidhuber，1997）。在平坦最小值附近，参数的微小变化不会显著影响损失函数，导致模型具有鲁棒性。此外，平坦最小值作为一种自然正则化形式，通常可以防止模型过拟合，提高泛化能力。具体来说，Shi 等（2021）建议在基础训练目标函数中寻找平坦局部最小值，然后在新任务上在平坦区域内微调模型参数，大幅减少灾难性遗忘。</p>
<h3 id="42-基于元学习的方法">4.2 基于元学习的方法<a class="anchor-link" href="#42-基于元学习的方法" title="Permanent link">&para;</a></h3>
<p>在 FSL 或 IL 领域，元学习可以利用现有知识来解决当前的学习问题，并通过持续的知识积累提高系统的稳定性和可靠性。在 FSL 中，元学习利用其他相关任务的数据增强当前任务的学习效果（Finn 等，2017；Liu 等，2020；Rusu 等，2019；Snell 等，2017）。在 IL 中，元学习可以用来减少对新数据的依赖，从而避免过拟合（Riemer 等，2019）。将元学习应用于 FSCIL 是自然的。</p>
<p>在此，我们将基于元学习的 FSCIL 方法分为两类：基于原型学习的方法和基于元过程的方法。</p>
<h4 id="421-原型学习">4.2.1 原型学习<a class="anchor-link" href="#421-原型学习" title="Permanent link">&para;</a></h4>
<p>原型学习旨在识别一小部分能够准确代表给定数据集的示例，然后利用数据点与原型之间的相似性来分类新数据点或完成其他视觉任务。常用的类别原型定义如下：</p>
<p><div class="math-display">\mu<em>c = \frac{1}{|S_c|} \sum</em>{x \in S<em>c} f</em>\theta (x)</div></p>
<p>其中，<span class="math-inline">S<em>c</span> 是类别 <span class="math-inline">c</span> 的所有样本集合；<span class="math-inline">f</em>\theta</span> 是由 <span class="math-inline">\theta</span> 参数化的嵌入网络。与传统监督学习方法相比，原型学习需要较少的标注数据，并且具有更强的泛化能力。</p>
<p>然而，简单地使用传统原型方法聚合所有学习到的类别原型，可能导致某些原型无法区分。为了解决这个问题，Zheng 和 Zhang（2021）引入了类别结构正则化器，以调节 FSCIL 嵌入空间中学习到的类别的分布。通过使用类别分布作为先验知识来正则化新类的学习，这种方法确保来自同一或不同阶段的类别能够相互区分。</p>
<p>在 FSL 中，基于原型的方法在 IL 场景中面临挑战，主要由于两个问题：（i）随着数据量的增加，样本特征或标签分布可能由于潜在的概念漂移或数据分布漂移而变化，使得原型样本无法准确代表最新数据分布；（ii）后续任务引入的新类在概念上可能与早期类不同，导致原型空间内的冲突，从而影响原型距离测量的有效性，并进而影响分类准确性。为了解决这些问题，Zhu 等（2021）提出了一种增量原型学习方案，包括随机情节选择和动态关系投影。随机情节选择通过适应不同随机生成的增量过程的梯度来提高特征表示的可扩展性。动态关系投影利用新类样本与旧类原型之间的关系矩阵来更新现有原型。</p>
<p>学习向量量化（Learning Vector Quantization，LVQ）是一种基于距离选择向量点作为原型的聚类方法。Chen 和 Lee（2021）在深度嵌入空间中使用基于 LVQ 的非参数方法。他们将学习任务的信息压缩成少量量化的参考向量。这些向量包括类内变异、减少遗忘正则化和校准参考向量，以缓解灾难性遗忘。基于 CIL 算法的思想，Mazumder 等（2021）提出了少样本终身学习（Few-shot Lifelong Learning，FSLL）。该算法在每个增量阶段选择一些参数进行更新以抵抗过拟合。同时，最小化新类原型与旧类原型之间的余弦相似性，以最大化它们的分离，从而提高分类性能。</p>
<p>根据 Hersche 等（2022），从超维计算的角度将输入图像映射到准正交原型。提出的 C-FSIL 包括一个冻结的元学习特征提取器、一个可训练的固定大小全连接层和一个可重写的动态增长的内存。提供的三种参数更新形式有效地平衡了准确性和计算内存成本。在 Yao 等（2022）中，提出了一种人类认知启发的原型表示增强方案用于 FSCIL。该方法使用原型表示，通过探索与先前学过类别的相似性关联，迭代学习新类知识。Yang 等（2023）认为，由于微调骨干或先前分类器原型导致的旧类特征与分类器的不对齐是遗忘的原因。受神经塌缩理论的启发，他们在神经塌缩期间对齐了一组原型与 FSL 所需的原型，从而提高了分类器的性能。</p>
<p>上述方法在算法上表现简洁，但少样本类原型与真实数据分布之间的语义差距是提高原型方法准确性的主要障碍。</p>
<h4 id="422-元过程">4.2.2 元过程<a class="anchor-link" href="#422-元过程" title="Permanent link">&para;</a></h4>
<p>受多任务优化方法 MAXL（Liu 等，2019）的启发，Chi 等（2022）提出了 MetaFSCIL，将适应新知识和保留旧知识直接转化为元目标。他们通过从基础类中抽样一系列增量任务来模拟元测试期间的场景。此外，他们提出了一种基于元学习的双向引导调制，自动适应新知识。在元学习背景下的度量学习基础上，Zou 等（2022）发现使用大间隔分类提高了基础类的性能，但在学习新类时性能下降，这种现象称为类级过拟合。作者解释这是由于学习共享或类特定模式的约束容易满足。随后，他们提出了基于边界的 CLOM 框架，引入了额外的约束，有效解决了上述问题。</p>
<h3 id="43-基于特征和特征空间的方法">4.3 基于特征和特征空间的方法<a class="anchor-link" href="#43-基于特征和特征空间的方法" title="Permanent link">&para;</a></h3>
<p>这类方法旨在利用有限的少样本训练数据，提升特征学习和特征空间建模的质量。</p>
<p>在 Hou 等（2019）中，首先通过学习特征提取器以获取类分离度良好的特征表示，然后提出了基于特征的正则化和基于特征的记忆重放策略，用于稳定地扩展类别集合。此外，张等（2020）提出了分布自适应嵌入（DAE）框架，该框架在基础类和增量类之间实现了特征分布对齐，从而增强了新类的泛化能力。Yoon 等（2021）引入了一种基于图结构的对比学习方法，通过构建增量样本间的相似性图，保持新旧类别间的特征一致性。金等（2022）提出了一种基于扰动对抗训练的方法，通过引入随机噪声和对抗样本，提升特征学习的鲁棒性。</p>
<h3 id="44-基于重放的方法">4.4 基于重放的方法<a class="anchor-link" href="#44-基于重放的方法" title="Permanent link">&para;</a></h3>
<p>这类方法通过记忆旧类别的数据样本或生成旧类别的样本来解决灾难性遗忘问题。与传统 IL 中的重放方法类似，这些方法在 FSCIL 中通过少量旧类数据或生成旧类样本的方式来稳定模型性能。例如，Li 等（2021）提出了一种基于 GAN 的生成模型，通过生成与旧类数据相似的样本，缓解灾难性遗忘。邵等（2022）提出了一种基于变分自编码器（VAE）的重放策略，通过重建旧类数据来保持旧类知识。</p>
<h3 id="45-基于动态网络结构的方法">4.5 基于动态网络结构的方法<a class="anchor-link" href="#45-基于动态网络结构的方法" title="Permanent link">&para;</a></h3>
<p>这类方法通过动态调整网络结构以适应新的少样本类别。例如，崔等（2020）提出了一种基于神经结构搜索（NAS）的动态网络，通过搜索最优的网络结构来适应新类的学习。高等（2021）提出了一种基于模块化网络的方法，通过动态调整网络模块来适应新类的学习需求。</p>
<h2 id="5-实验结果与性能评估">5. 实验结果与性能评估<a class="anchor-link" href="#5-实验结果与性能评估" title="Permanent link">&para;</a></h2>
<p>在本节中，我们总结了现有 FSCIL 方法在常用基准数据集上的实验结果。表 1 展示了不同方法在 CIFAR-100、miniImageNet 和 TieredImageNet 数据集上的性能对比。通过这些实验结果，可以看到不同方法在处理少样本类别增量学习时的优劣。</p>
<h2 id="6-应用领域">6. 应用领域<a class="anchor-link" href="#6-应用领域" title="Permanent link">&para;</a></h2>
<p>FSCIL 在计算机视觉、自然语言处理和图分析等领域取得了显著的应用成就。在图像分类方面，FSCIL 方法被广泛应用于目标检测、图像分割和视频分析等任务中。在自然语言处理领域，FSCIL 方法用于文本分类、序列标注和对话系统等任务。在图分析领域，FSCIL 方法被应用于节点分类、链接预测和图生成等任务。</p>
<h2 id="7-未来研究方向">7. 未来研究方向<a class="anchor-link" href="#7-未来研究方向" title="Permanent link">&para;</a></h2>
<p>尽管 FSCIL 在过去几年取得了显著进展，但仍有许多未解决的问题和研究挑战。未来的研究可以从以下几个方面展开：</p>
<ol>
<li>增强少样本学习的鲁棒性，减少对样本数量和质量的依赖。</li>
<li>提高模型的泛化能力，使其能够更好地适应不同领域和任务。</li>
<li>开发更高效的算法，以减少训练和推理的计算成本。</li>
<li>探索 FSCIL 在更多实际应用中的潜力，推动其在工业界的广泛应用。</li>
</ol>
<h2 id="8-结论">8. 结论<a class="anchor-link" href="#8-结论" title="Permanent link">&para;</a></h2>
<p>本文对少样本类别增量学习进行了全面综述，回顾了现有的研究方法和应用，并总结了当前的研究进展。通过对不同方法的分类和性能评估，我们展示了 FSCIL 领域的最新进展和未来研究方向。希望本文的综述能够为研究人员和从业者提供有价值的参考，推动 FSCIL 领域的发展。</p>
                </div>

                <!-- Comments Section (Giscus) -->
                <section class="comments-section">
                    <h3><i class="fas fa-comments"></i> 评论</h3>
                    <script src="https://giscus.app/client.js"
                        data-repo="Geeks-Z/Geeks-Z.github.io"
                        data-repo-id=""
                        data-category="Announcements"
                        data-category-id=""
                        data-mapping="pathname"
                        data-strict="0"
                        data-reactions-enabled="1"
                        data-emit-metadata="0"
                        data-input-position="bottom"
                        data-theme="preferred_color_scheme"
                        data-lang="zh-CN"
                        crossorigin="anonymous"
                        async>
                    </script>
                </section>
            </article>

            <footer class="post-footer">
                <p>© 2025 Hongwei Zhao. Built with ❤️</p>
            </footer>
        </main>
    </div>

    <!-- Theme Toggle Button -->
    <button class="theme-toggle" id="themeToggle" aria-label="切换主题">
        <i class="fas fa-moon"></i>
    </button>

    <script>
        // Theme Toggle
        const themeToggle = document.getElementById('themeToggle');
        const html = document.documentElement;
        const icon = themeToggle.querySelector('i');
        const hljsDark = document.getElementById('hljs-theme-dark');
        const hljsLight = document.getElementById('hljs-theme-light');
        
        // Check saved theme or system preference
        const savedTheme = localStorage.getItem('theme');
        const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
        
        if (savedTheme === 'dark' || (!savedTheme && prefersDark)) {
            html.setAttribute('data-theme', 'dark');
            icon.className = 'fas fa-sun';
            hljsDark.disabled = false;
            hljsLight.disabled = true;
        }
        
        themeToggle.addEventListener('click', () => {
            const isDark = html.getAttribute('data-theme') === 'dark';
            if (isDark) {
                html.removeAttribute('data-theme');
                icon.className = 'fas fa-moon';
                localStorage.setItem('theme', 'light');
                hljsDark.disabled = true;
                hljsLight.disabled = false;
            } else {
                html.setAttribute('data-theme', 'dark');
                icon.className = 'fas fa-sun';
                localStorage.setItem('theme', 'dark');
                hljsDark.disabled = false;
                hljsLight.disabled = true;
            }
            
            // Update Giscus theme
            const giscusFrame = document.querySelector('iframe.giscus-frame');
            if (giscusFrame) {
                giscusFrame.contentWindow.postMessage({
                    giscus: {
                        setConfig: {
                            theme: isDark ? 'light' : 'dark'
                        }
                    }
                }, 'https://giscus.app');
            }
        });
        
        // Highlight.js
        document.addEventListener('DOMContentLoaded', () => {
            hljs.highlightAll();
        });
        
        // KaTeX auto-render
        document.addEventListener('DOMContentLoaded', () => {
            if (typeof renderMathInElement !== 'undefined') {
                renderMathInElement(document.body, {
                    delimiters: [
                        {left: '$$', right: '$$', display: true},
                        {left: '$', right: '$', display: false},
                        {left: '\\[', right: '\\]', display: true},
                        {left: '\\(', right: '\\)', display: false}
                    ],
                    throwOnError: false
                });
            }
        });
        
        // TOC active state
        const tocLinks = document.querySelectorAll('.toc-container a');
        const headings = document.querySelectorAll('.post-content h2, .post-content h3, .post-content h4');
        
        function updateTocActive() {
            let current = '';
            headings.forEach(heading => {
                const rect = heading.getBoundingClientRect();
                if (rect.top <= 100) {
                    current = heading.getAttribute('id');
                }
            });
            
            tocLinks.forEach(link => {
                link.classList.remove('active');
                if (link.getAttribute('href') === '#' + current) {
                    link.classList.add('active');
                }
            });
        }
        
        window.addEventListener('scroll', updateTocActive);
        updateTocActive();
    </script>
</body>
</html>
