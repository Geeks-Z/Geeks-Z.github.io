<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Untitled</title>
    <meta name="description" content="Untitled - Hongwei Zhao's Blog">
    <meta name="author" content="Hongwei Zhao">
    
    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Noto+Sans+SC:wght@300;400;500;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    
    <!-- Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <!-- Code Highlighting -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css" id="hljs-theme-dark">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css" id="hljs-theme-light" disabled>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    
    <!-- KaTeX for Math -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>
    
    <style>
        :root {
            /* Light Theme - 明亮清新配色 */
            --primary-color: #4A90D9;
            --primary-hover: #3678C2;
            --link-color: #E86B5F;
            --text-color: #2D2D2D;
            --text-light: #5A5A5A;
            --text-muted: #8A8A8A;
            --bg-color: #FFFFFF;
            --bg-secondary: #F5F7FA;
            --bg-code: #F8F9FC;
            --border-color: #E8ECF0;
            --shadow: 0 2px 8px rgba(0,0,0,0.06);
            --shadow-lg: 0 8px 24px rgba(0,0,0,0.08);
        }

        [data-theme="dark"] {
            --primary-color: #5dade2;
            --primary-hover: #85c1e9;
            --link-color: #e74c3c;
            --text-color: #e5e7eb;
            --text-light: #9ca3af;
            --text-muted: #6b7280;
            --bg-color: #1a1a2e;
            --bg-secondary: #16213e;
            --bg-code: #0f0f23;
            --border-color: #374151;
            --shadow: 0 1px 3px rgba(0,0,0,0.3);
            --shadow-lg: 0 4px 15px rgba(0,0,0,0.4);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            scroll-behavior: smooth;
        }

        body {
            font-family: 'Inter', 'Noto Sans SC', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            font-size: 16px;
            line-height: 1.8;
            color: var(--text-color);
            background: var(--bg-color);
            transition: background-color 0.3s, color 0.3s;
        }

        a {
            color: var(--primary-color);
            text-decoration: none;
            transition: color 0.2s;
        }

        a:hover {
            color: var(--primary-hover);
            text-decoration: underline;
        }

        /* Layout */
        .page-wrapper {
            display: flex;
            max-width: 1400px;
            margin: 0 auto;
            padding: 2rem;
            gap: 3rem;
        }

        /* Sidebar TOC */
        .toc-sidebar {
            width: 260px;
            flex-shrink: 0;
            position: sticky;
            top: 2rem;
            height: fit-content;
            max-height: calc(100vh - 4rem);
            overflow-y: auto;
        }

        .toc-container {
            background: var(--bg-secondary);
            border-radius: 12px;
            padding: 1.5rem;
            border: 1px solid var(--border-color);
        }

        .toc-container h3 {
            font-size: 0.85rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-muted);
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .toc-container ul {
            list-style: none;
        }

        .toc-container li {
            margin-bottom: 0.5rem;
        }

        .toc-container a {
            font-size: 0.9rem;
            color: var(--text-light);
            display: block;
            padding: 0.25rem 0;
            border-left: 2px solid transparent;
            padding-left: 0.75rem;
            transition: all 0.2s;
        }

        .toc-container a:hover,
        .toc-container a.active {
            color: var(--primary-color);
            border-left-color: var(--primary-color);
            text-decoration: none;
        }

        .toc-container ul ul {
            margin-left: 1rem;
        }

        /* Main Content */
        .main-content {
            flex: 1;
            min-width: 0;
            max-width: 800px;
        }

        /* Header */
        .post-header {
            margin-bottom: 2rem;
            padding-bottom: 1.5rem;
            border-bottom: 1px solid var(--border-color);
        }

        .back-link {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.9rem;
            color: var(--text-light);
            margin-bottom: 1.5rem;
        }

        .back-link:hover {
            color: var(--primary-color);
            text-decoration: none;
        }

        .post-header h1 {
            font-size: 2.25rem;
            font-weight: 700;
            line-height: 1.3;
            margin-bottom: 1rem;
            color: var(--text-color);
        }

        .post-meta {
            display: flex;
            flex-wrap: wrap;
            gap: 1.5rem;
            font-size: 0.9rem;
            color: var(--text-light);
        }

        .post-meta span {
            display: flex;
            align-items: center;
            gap: 0.4rem;
        }

        .post-meta i {
            color: var(--text-muted);
        }

        .tags {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-top: 1rem;
        }

        .tag {
            display: inline-block;
            font-size: 0.8rem;
            background: var(--bg-secondary);
            color: var(--text-light);
            padding: 0.25rem 0.75rem;
            border-radius: 20px;
            border: 1px solid var(--border-color);
            transition: all 0.2s;
        }

        .tag:hover {
            background: var(--primary-color);
            color: white;
            border-color: var(--primary-color);
        }

        /* Article Content */
        .post-content {
            font-size: 1rem;
            line-height: 1.9;
        }

        .post-content h1,
        .post-content h2,
        .post-content h3,
        .post-content h4,
        .post-content h5,
        .post-content h6 {
            margin-top: 2rem;
            margin-bottom: 1rem;
            font-weight: 600;
            line-height: 1.4;
            color: var(--text-color);
        }

        .post-content h1 { font-size: 1.875rem; }
        .post-content h2 { 
            font-size: 1.5rem; 
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--border-color);
        }
        .post-content h3 { font-size: 1.25rem; }
        .post-content h4 { font-size: 1.125rem; }

        .post-content p {
            margin-bottom: 1.25rem;
        }

        .post-content ul,
        .post-content ol {
            margin: 1.25rem 0;
            padding-left: 1.5rem;
        }

        .post-content li {
            margin-bottom: 0.5rem;
        }

        .post-content blockquote {
            margin: 1.5rem 0;
            padding: 1rem 1.5rem;
            background: var(--bg-secondary);
            border-left: 4px solid var(--primary-color);
            border-radius: 0 8px 8px 0;
            color: var(--text-light);
            font-style: italic;
        }

        .post-content blockquote p:last-child {
            margin-bottom: 0;
        }

        /* Code */
        .post-content code {
            font-family: 'JetBrains Mono', 'Fira Code', Consolas, monospace;
            font-size: 0.9em;
            background: var(--bg-code);
            padding: 0.2em 0.4em;
            border-radius: 4px;
            color: var(--link-color);
        }

        .post-content pre {
            margin: 1.5rem 0;
            padding: 1.25rem;
            background: var(--bg-code);
            border-radius: 10px;
            overflow-x: auto;
            border: 1px solid var(--border-color);
        }

        .post-content pre code {
            background: none;
            padding: 0;
            color: inherit;
            font-size: 0.875rem;
            line-height: 1.6;
        }

        /* Images */
        .post-content img {
            max-width: 100%;
            height: auto;
            border-radius: 10px;
            margin: 1.5rem 0;
            box-shadow: var(--shadow-lg);
        }

        /* Tables */
        .post-content table {
            width: 100%;
            margin: 1.5rem 0;
            border-collapse: collapse;
            font-size: 0.95rem;
        }

        .post-content th,
        .post-content td {
            padding: 0.75rem 1rem;
            border: 1px solid var(--border-color);
            text-align: left;
        }

        .post-content th {
            background: var(--bg-secondary);
            font-weight: 600;
        }

        .post-content tr:nth-child(even) {
            background: var(--bg-secondary);
        }

        /* Math */
        .math-display {
            margin: 1.5rem 0;
            overflow-x: auto;
            padding: 1rem;
            background: var(--bg-secondary);
            border-radius: 8px;
        }

        /* Anchor links */
        .anchor-link {
            opacity: 0;
            margin-left: 0.5rem;
            color: var(--text-muted);
            font-weight: 400;
            transition: opacity 0.2s;
        }

        .post-content h2:hover .anchor-link,
        .post-content h3:hover .anchor-link,
        .post-content h4:hover .anchor-link {
            opacity: 1;
        }

        /* Theme Toggle */
        .theme-toggle {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: var(--primary-color);
            color: white;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.25rem;
            box-shadow: var(--shadow-lg);
            transition: transform 0.2s, background 0.2s;
            z-index: 1000;
        }

        .theme-toggle:hover {
            transform: scale(1.1);
            background: var(--primary-hover);
        }

        /* Comments Section */
        .comments-section {
            margin-top: 3rem;
            padding-top: 2rem;
            border-top: 1px solid var(--border-color);
        }

        .comments-section h3 {
            font-size: 1.25rem;
            margin-bottom: 1.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        /* Footer */
        .post-footer {
            margin-top: 3rem;
            padding-top: 1.5rem;
            border-top: 1px solid var(--border-color);
            text-align: center;
            font-size: 0.9rem;
            color: var(--text-muted);
        }

        /* Responsive */
        @media (max-width: 1024px) {
            .toc-sidebar {
                display: none;
            }
            
            .page-wrapper {
                padding: 1.5rem;
            }
        }

        @media (max-width: 768px) {
            .post-header h1 {
                font-size: 1.75rem;
            }
            
            .post-meta {
                flex-direction: column;
                gap: 0.5rem;
            }
            
            .theme-toggle {
                bottom: 1rem;
                right: 1rem;
                width: 44px;
                height: 44px;
            }
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-secondary);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--text-muted);
        }
    </style>
</head>
<body>
    <div class="page-wrapper">
        <!-- TOC Sidebar -->
        <aside class="toc-sidebar">
            <div class="toc-container">
                <h3><i class="fas fa-list"></i> 目录</h3>
                <div class="toc">
<ul>
<li><a href="#few-shot-tuning-of-foundation-models-for-class-incremental-learning">Few-shot Tuning of Foundation Models for Class-incremental Learning</a></li>
<li><a href="#0-摘要">0. 摘要</a></li>
<li><a href="#1-引言">1. 引言</a></li>
<li><a href="#2-相关工作">2. 相关工作</a><ul>
<li><a href="#21-少样本类增量学习">2.1 少样本类增量学习</a></li>
<li><a href="#22-基础模型微调">2.2 基础模型微调</a></li>
</ul>
</li>
<li><a href="#3-方法">3. 方法</a><ul>
<li><a href="#31-问题阐述">3.1 问题阐述</a></li>
<li><a href="#32-一致性引导的异步对比调整-coact">3.2 一致性引导的异步对比调整 (CoACT)</a><ul>
<li><a href="#321-异步对比调整">3.2.1 异步对比调整</a></li>
<li><a href="#322-控制的微调">3.2.2 控制的微调</a></li>
<li><a href="#323-一致性引导的增量调整">3.2.3 一致性引导的增量调整</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#4-实验">4. 实验</a><ul>
<li><a href="#41-基线">4.1 基线</a></li>
<li><a href="#42-实验设置">4.2 实验设置</a></li>
<li><a href="#43-结果">4.3 结果</a></li>
</ul>
</li>
<li><a href="#5-结论">5. 结论</a></li>
</ul>
</div>

            </div>
        </aside>

        <!-- Main Content -->
        <main class="main-content">
            <article>
                <header class="post-header">
                    <a href="../../../index.html" class="back-link">
                        <i class="fas fa-arrow-left"></i> 返回博客列表
                    </a>
                    <h1>Untitled</h1>
                    <div class="post-meta">
                        <span><i class="fas fa-calendar-alt"></i> 2026-02-04</span>
                        <span><i class="fas fa-folder"></i> AINotes/41.小样本类增量学习FSCIL</span>
                        <span><i class="fas fa-user"></i> Hongwei Zhao</span>
                    </div>
                    <div class="tags">
                        
                    </div>
                </header>

                <div class="post-content">
                    <h2 id="few-shot-tuning-of-foundation-models-for-class-incremental-learning"><a href="https://arxiv.org/abs/2405.16625">Few-shot Tuning of Foundation Models for Class-incremental Learning</a><a class="anchor-link" href="#few-shot-tuning-of-foundation-models-for-class-incremental-learning" title="Permanent link">&para;</a></h2>
<h2 id="0-摘要">0. 摘要<a class="anchor-link" href="#0-摘要" title="Permanent link">&para;</a></h2>
<p>首次探索了针对类别增量学习的少量样本调整视觉基础模型。与现有的少量样本类别增量学习（FSCIL）方法不同，这些方法在基础会话上训练一个编码器，以确保对未来持续学习的前向兼容性，而基础模型通常在大量未标记数据上训练，没有此类考虑。这使得传统FSCIL的方法不适用于与基础模型的FSCIL。为此，我们提出了一种新方法——一致性引导的异步对比调整（CoACT），用于在少量样本设置中不断调整基础模型以学习新类别。CoACT包括三个组成部分：(i) 异步对比调整，通过在预训练编码器中包含LoRA模块来学习新类别，同时强制两个异步编码器之间的一致性；(ii) 控制的微调，有助于有效调整基础模型的一个子集；以及 (iii) 一致性引导的增量调整，通过在后续会话中增加额外的正则化来减少对已学类别的遗忘。我们在16个不同的数据集上进行了广泛的研究，并证明了CoACT的有效性，平均超过最佳基线方法2.47%，在个别数据集上高达12.52%。此外，CoACT在低样本实验中显示出减少的遗忘和鲁棒性。作为额外的好处，CoACT在标准FSCIL上的改进高达13.5%，超过了当前的最佳基准。我们在 https://github.com/ShuvenduRoy/CoACT-FSCIL 上公开了我们的代码。</p>
<h2 id="1-引言">1. 引言<a class="anchor-link" href="#1-引言" title="Permanent link">&para;</a></h2>
<p>少样本类别增量学习（FSCIL）是一种持续学习范式，它涉及到顺序学习一组新类别，每个类别只有有限数量的样本可用[51, 44, 39]。这项任务特别具有挑战性，但同时也非常重要，因为它模仿了现实世界的场景，其中新类别可能随时间出现，而且为这些新类别收集大量训练集可能是困难的。在实践中，FSCIL假设有一个大型基础会话可用，其中类别的数量和每个类别的样本数量通常是较大的[51]。基础会话之后是增量学习会话，这些会话引入了每个类别只有有限数量样本的新类别。在传统的FSCIL范式中，模型通常在基础会话上使用全监督学习进行训练，同时为学习未来的增量类别提供前向兼容性[42, 21]。在基础训练期间实现前向兼容性的技术包括在嵌入空间中分配空间[42]或识别编码器的特定参数，认为有必要在新会话学习时保持冻结[21]。</p>
<p>随着大型基础模型的出现，这些模型具有出色的泛化能力和在不同领域内的卓越性能，能够使用极少的数据持续学习新类别，这可以进一步增强它们在现实世界应用中的适应性和有效性。然而，基础模型通常在没有对未来持续学习有任何了解或兼容性的网络规模未标记数据上进行训练。这反过来使得现有的FSCIL解决方案在与基础模型结合使用时变得不切实际，需要一种新的方法，我们旨在调整现成的基础模型，以便在不丢失先前学习知识的情况下学习新类别（见图1）。据我们所知，通过调整大型基础模型来实现FSCIL的功能在以往的工作中尚未被探索。</p>
<p>调整基础模型也带来了自身的挑战，尤其是在处理有限的标记数据时。尽管在参数高效调整[23, 13]和正则化技术[38]方面取得了进展，但在少样本设置中对基础模型进行微调通常会导致泛化能力下降，这可能导致在持续学习的背景下发生灾难性遗忘。</p>
<p>为了解决这一挑战，我们提出了一种名为一致性引导的异步对比调整（CoACT）的新框架，用于在少样本设置中对基础模型进行类别增量学习。CoACT包括三个组成部分：(i) 异步对比调整，(ii) 控制的微调，以及 (iii) 一致性引导的增量调整。异步对比调整使用一种新颖的异步对比方法从第一个增量会话中学习，这种方法在适应新类别和保留预训练基础模型的泛化知识之间取得了平衡。为了适应第一个新会话，我们在预训练编码器中整合了可学习的LoRA模块，并通过在两个异步编码器之间强制执行一致性来确保泛化：一个包含可学习模块的学生编码器，以及一个与预训练编码器相同的教师编码器，后者根据学生编码器的指数移动平均值（EMA）进行更新。这种设计防止了教师输出分布的快速变化，有助于减少学生编码器在学习有效表示时的过拟合。此外，为了进一步提高适应性，我们引入了控制的微调，它采用两步训练协议用于第一个增量会话。首先，我们用高学习率训练新添加的LoRA模块一定数量的周期，然后使用相对较低的学习率微调预训练参数的最后几层。这有助于在适应性与泛化能力之间取得平衡。最后，一致性引导的增量调整是一种新颖的正则化技术，确保在随后的增量会话中有效学习类别，同时防止遗忘之前学习的类别，并保留基础模型的泛化能力。为此，我们在增量会话中强制执行可学习编码器的预测与第一个增量会话中冻结编码器之间的一致性。</p>
<p>我们在16个不同的图像识别数据集上进行了全面的研究，以调查我们方法的有效性。这些数据集包括通用对象、细粒度对象、场景、卫星图像和纹理识别。鉴于传统的FSCIL方法不适用于与基础模型的FSCIL，我们首先基于少样本学习文献建立了一组基线，即原型学习[42]、线性调整和LoRA调整[19]。我们的综合实验表明，CoACT在平均上比最佳基线方法提高了2.47%，在个别数据集上达到了12.79%的性能提升（见图2）。更重要的是，CoACT在类别数量增加时表现出对已学习类别的遗忘减少。我们还评估了CoACT在传统FSCIL设置中的有效性，其中第一个增量会话相当大。按照既定协议，我们在CIFAR-100、CUB-200和miniImageNet数据集上报告了这些结果。我们的方法达到了最先进的性能（见表1），分别在这三个数据集上超过了现有方法4.11%、5.02%和13.47%。我们提供了详细的消融研究，展示了我们方法中每个组成部分的有效性。总的来说，我们做出了以下贡献：</p>
<ul>
<li>我们首次探索了使用基础模型的FSCIL，以实现在少样本设置中持续调整模型以学习新类别。</li>
<li>我们提出了CoACT，这是一种新的方法，可以有效地使用基础模型进行FSCIL，而不会失去其泛化能力或遗忘已学习的类别。我们的方法由三个关键组成部分组成，这些组成部分丰富了我们对基础模型调整的策略，以适应更动态的现实世界环境。</li>
<li>我们的综合实验表明，我们的方法在传统FSCIL和基础模型FSCIL上都实现了最先进的性能。我们还展示了在极低样本设置中的减少遗忘和有效性。广泛的消融和敏感性研究显示了我们提出的每个组成部分及其最佳设置的有效性。我们公开了我们的代码：https://github.com/ShuvenduRoy/CoACT-FSCIL。</li>
</ul>
<h2 id="2-相关工作">2. 相关工作<a class="anchor-link" href="#2-相关工作" title="Permanent link">&para;</a></h2>
<h3 id="21-少样本类增量学习">2.1 少样本类增量学习<a class="anchor-link" href="#21-少样本类增量学习" title="Permanent link">&para;</a></h3>
<p>类增量学习是一种持续学习过程，专注于在保留已学习类别知识的同时，不断学习新类别[30]。在实践中，机器学习模型通常需要从每个类别的少量标记样本中学习新类别[51]，同时无法访问已学习类别的样本。这种场景催生了一种新的学习任务，即少样本类增量学习（FSCIL）[44]。现有的FSCIL文献主要可以分为两大类：一类是在每个增量会话中持续训练编码器和分类器的方法[43, 6, 10, 49]；另一类是在增量学习会话中保持编码器冻结的方法[52, 41, 48]。以下是对这两类方法的简要概述。</p>
<p>作为第一类FSCIL方法的一个例子，MgSvF[49]采用了组件更新策略，以确保在适应新类别的同时保留对现有类别的知识。示例关系蒸馏框架[10]构建并更新了一个示例关系图，以促进新类别的整合。SoftNet[21]引入了一种新方法，用于识别并冻结前一阶段的关键参数子网络，并在增量会话中训练剩余参数。尽管第一类方法通常比第二类方法提供更大的新类别适应性：(a) 它们需要额外的约束以避免对新类别的过拟合，从而避免灾难性遗忘；(b) 它们通常在基础模型的背景下不可行，因为编码器非常大，导致在少样本设置中容易过拟合。</p>
<p>在第二类FSCIL方法中，FACT[50]引入了虚拟原型以最大化类别嵌入的分离，同时保留它们的相对位置。SAVC[42]在基础会话训练期间生成虚拟类别，以最大化可分性。类似地，NC-FSCIL[47]为每个基础类别预先分配了最优间隔的原型，以促进多样化和独特的类别表示。第二类方法通常专注于通过在基础类别的学习嵌入空间内保持可分性，确保有效整合新类别而不干扰现有类别[52, 41, 48]。尽管第二类方法通常提供对已学习类别的更大稳定性：(a) 稳定性往往以牺牲对新类别学习的适应性为代价；(b) 这些方法通常与基础模型不兼容，因为缺乏对这些现成模型的基础训练的控制。</p>
<h3 id="22-基础模型微调">2.2 基础模型微调<a class="anchor-link" href="#22-基础模型微调" title="Permanent link">&para;</a></h3>
<p>最近提出了一些技术，可以在不需要从头开始重新训练的情况下调整基础模型。Adapter tuning[18]通过在预训练模型内部插入新的可学习层来微调大型预训练模型，以适应下游任务。Prompt-tuning[27]和prefix-tuning[28]在输入嵌入中添加可学习的提示，以便在不调整模型的预训练参数的情况下学习新任务。Low-rank adapters[19, 22]被引入以减少额外参数的计算成本。VPT[20]和AdapterFormer[4]在视觉变换器的背景下探索了参数高效的微调。然而，这些方法并不是为持续调整基础模型而设计的，因为它们没有内在的机制来防止泛化能力的丧失和灾难性遗忘。</p>
<h2 id="3-方法">3. 方法<a class="anchor-link" href="#3-方法" title="Permanent link">&para;</a></h2>
<h3 id="31-问题阐述">3.1 问题阐述<a class="anchor-link" href="#31-问题阐述" title="Permanent link">&para;</a></h3>
<p>在 FSCIL 中，模型 <span class="math-inline">\phi(x)</span> 在连续的 <span class="math-inline">T</span> 个新类别会话上进行训练。每个会话遵循 <span class="math-inline">n</span>-way <span class="math-inline">k</span>-shot 样本设置，其中 <span class="math-inline">n</span> 代表每个会话中的类别数量，<span class="math-inline">k</span> 是每个类别的样本数量。因此，每个会话 <span class="math-inline">t \in T</span> 的训练数据可以表示为 <span class="math-inline">\mathcal{D}^t_{train} = { (x_i, y_i) }^{N_t}<em>{i=1}</span>，其中 <span class="math-inline">x_i</span> 和 <span class="math-inline">y_i</span> 分别表示第 <span class="math-inline">i</span> 个样本及其对应的标签，<span class="math-inline">N_t</span> 表示会话 <span class="math-inline">t</span> 中的样本数量。我们可以表示 <span class="math-inline">\phi(x) = W^T f</em>\theta(x)</span>，其中 <span class="math-inline">f_\theta</span> 是编码器，<span class="math-inline">W</span> 是线性分类器。在 FSCIL 的传统设置中，<span class="math-inline">f_\theta</span> 通常在大型标记基础会话 <span class="math-inline">\mathcal{D}<em>{train}^{0}</span> 上训练，同时确保对学习新类别的前向兼容性，并且在增量会话中保持冻结。如果我们假设 <span class="math-inline">f</em>\theta</span> 是一个在大量网络规模数据上预训练的基础模型，对将来的持续学习没有任何了解，那么标准的 FSCIL 技术就变得不兼容，因为它们需要一个标记的基础会话。在这项工作中，我们的目标是设计一种方法，用于调整现成的预训练基础模型，以在少样本学习设置中不断学习新类别。</p>
<h3 id="32-一致性引导的异步对比调整-coact">3.2 一致性引导的异步对比调整 (CoACT)<a class="anchor-link" href="#32-一致性引导的异步对比调整-coact" title="Permanent link">&para;</a></h3>
<p>在本节中，我们将讨论我们提出方法的三个组成部分的细节：异步对比调整、控制的微调和一致性引导的增量调整。这里，异步对比调整和控制的微调有助于学习第一个会话（见图 3（左）），而一致性引导的增量调整则学习剩余的增量会话，同时不忘学习过的类别（见图 3（右））。</p>
<div align=center><img src="https://markdownimg-hw.oss-cn-beijing.aliyuncs.com/20240823174849.png" /></div>

<h4 id="321-异步对比调整">3.2.1 异步对比调整<a class="anchor-link" href="#321-异步对比调整" title="Permanent link">&para;</a></h4>
<p>为了在适应新类别和保留基础模型的泛化知识之间取得平衡，我们引入了异步对比调整作为我们框架中的第一个组成部分。这涉及到使用我们的新颖异步对比学习方法（ACL）微调预训练模型，同时将 LoRA 模块整合到基础模型中。设 <span class="math-inline">h_i = f^{(i)}<em>\theta(h</em>{i-1})</span> 为预训练编码器第 <span class="math-inline">i</span> 层的输出，<span class="math-inline">h_{i-1}</span> 为编码器第 <span class="math-inline">(i-1)</span> 个隐藏层的输出，<span class="math-inline">f^{(i)}<em>\theta</span> 为编码器的第 <span class="math-inline">i</span> 层。通过新增的可学习 LoRA 层，网络第 <span class="math-inline">i</span> 层的输出可以表示为 <span class="math-inline">h_i = f^{(i)}</em>\theta(h_{i-1}) + f^{(i)}<em>{\text{LoRA}}(h</em>{i-1})</span>，其中 <span class="math-inline">f^{(i)}<em>{\text{LoRA}}</span> 是添加到预训练编码器中的第 <span class="math-inline">i</span> 个 LoRA 层。为了简洁起见，我们将带有可学习 LoRA 层的编码器表示为 <span class="math-inline">f'</em>\theta</span>。我们可以在 <span class="math-inline">\mathcal{D}<em>{train}^{1}</span> 上训练 <span class="math-inline">f'</em>\theta</span> 来学习第一个增量会话，如下所示：<br />
<div class="math-display"><br />
    L_{\text{sup}} = L_{\text{ce}}(W^T f'<em>\theta(x), y).<br />
</div><br />
然而，先前的研究表明，仅使用交叉熵并不能学习到一个良好可分的嵌入空间 [42]，并且在少样本设置中具有更高的过拟合倾向 [38]。为了减少过拟合的可能性并保留可学习编码器 <span class="math-inline">f'</em>\theta</span> 中的泛化能力，我们通过一个教师编码器来规范其输出分布，最大化它们在嵌入空间中的一致性。这里，教师编码器与预训练模型相同（不包含 LoRA 模块），并通过学生 <span class="math-inline">f'_\theta</span> 的指数移动平均值（EMA）学习，即 <span class="math-inline">\theta'' = m \cdot \theta'' + (1 - m) \cdot \theta</span>，其中 <span class="math-inline">\theta</span> 和 <span class="math-inline">\theta''</span> 分别是学生（无 LoRA）和教师编码器的参数，<span class="math-inline">m</span> 是动量参数。由于教师和学生编码器在架构上由于学生添加了 LoRA 而不同，学习是异步进行的。这种异步编码器设计和教师通过 EMA 的缓慢更新确保了教师的预测不会波动。由于教师编码器也是从基础模型初始化的，与教师的一致性有效地规范了学生编码器的过拟合。</p>
<p>在实践中，我们通过以下方式最大化学生和教师编码器在每个类别的所有样本上的嵌入之间的一致性：<br />
<div class="math-display"><br />
    L_{\text{ACL}} = -\sum_i^{|C_i|} \sum_{j \in C_i} \log \frac{e^{\langle q_i, k_j \rangle / \tau}}{\sum_{l=i}^{|C_i|} e^{\langle q_i, k_l \rangle / \tau}},<br />
</div><br />
其中 <span class="math-inline">C_i</span> 定义为 <span class="math-inline">{j : y_j = y_i}</span>，<span class="math-inline">\langle \cdot, \cdot \rangle</span> 表示内积，<span class="math-inline">q_i = f'<em>\theta(A_1(x_i))</span> 和 <span class="math-inline">k_j = f''</em>\theta(A_2(x_j))</span> 分别是来自学生和教师编码器的增强 <span class="math-inline">x_i</span> 和 <span class="math-inline">x_j</span> 的在线嵌入和动量嵌入，<span class="math-inline">A_1</span> 和 <span class="math-inline">A_2</span> 是随机增强。最后，我们训练模型使用 <span class="math-inline">L_{\text{ACL}}</span> 和 <span class="math-inline">L_{\text{sup}}</span> 如下：<br />
<div class="math-display"><br />
    L_{\text{ACL}} + \lambda \cdot L_{\text{sup}},<br />
</div><br />
其中 <span class="math-inline">\lambda</span> 控制 ACL 损失的影响。</p>
<h4 id="322-控制的微调">3.2.2 控制的微调<a class="anchor-link" href="#322-控制的微调" title="Permanent link">&para;</a></h4>
<p>为了进一步提高模型的适应性，我们实现了对编码器的一些预训练层的控制微调。由于新添加的 LoRA 模块是随机初始化的，我们首先只训练学生编码器的 LoRA 模块，在初始的 <span class="math-inline">E_c</span> 个训练周期中使用较高的学习率。随后是微调阶段，其中预训练编码器的最后 <span class="math-inline">C_l</span> 层使用降低的学习率（乘以因子 <span class="math-inline">C_f</span> ）进行微调。我们只关注最后 <span class="math-inline">C_l</span> 层的微调，因为预训练模型的后几层负责学习特定领域的细粒度特征，而前几层更通用，可以转移到广泛的任务上 [32]。</p>
<h4 id="323-一致性引导的增量调整">3.2.3 一致性引导的增量调整<a class="anchor-link" href="#323-一致性引导的增量调整" title="Permanent link">&para;</a></h4>
<p>虽然前两个模块促进了基础模型（<span class="math-inline">f_\theta</span>）在第一个会话期间的调整，但后续会话也需要保留以前学习的类别。为了实现这一点，我们提出了一致性引导的增量调整，通过规范学生 <span class="math-inline">f_\theta</span> 在增量会话期间的输出分布来防止遗忘。更具体地说，我们强制学生编码器的预测与第一个会话后冻结的编码器之间的一致性，有效地阻止了学生学习表示的实质性变化。设 <span class="math-inline">f_\theta^\beta</span> 为第一个会话后冻结的编码器，该编码器的冻结嵌入为 <span class="math-inline">p_i = f_\theta^\beta(A(x_i))</span>。我们定义我们的一致性正则化项为：<br />
<div class="math-display"><br />
    L_{\text{CR}} = -\sum_i^{|C_i|} \sum_{j \in C_i} \log \frac{e^{\langle q_i, p_j \rangle / \tau}}{\sum_{l=i}^{|C_i|} e^{\langle q_i, p_l \rangle / \tau}}.<br />
</div><br />
最后，在第一个会话之后，我们按以下方式训练模型：<br />
<div class="math-display"><br />
    L_{\text{CR}} + \gamma L_{\text{ACL}} + \lambda L_{\text{sup}},<br />
</div><br />
其中 <span class="math-inline">\gamma</span> 和 <span class="math-inline">\lambda</span> 控制损失函数的相对重要性。我们在增量训练期间调整 LoRA 模块和分类器，同时保持编码器冻结。</p>
<h2 id="4-实验">4. 实验<a class="anchor-link" href="#4-实验" title="Permanent link">&para;</a></h2>
<h3 id="41-基线">4.1 基线<a class="anchor-link" href="#41-基线" title="Permanent link">&para;</a></h3>
<p>由于目前还没有针对基础模型的 FSCIL，我们首先建立了几个基线，以更好地评估我们提出的框架。为此，我们采用了三种著名方法来构建这些基线。首先，我们使用了原型学习，这种方法已被证明在传统 FSCIL 中学习增量类别时表现良好 [42]。将这种方法应用于基础模型 <span class="math-inline">f_\theta(x)</span>，我们在增量学习会话中保持编码器冻结，同时使用新类别的原型 [42] 学习分类器 <span class="math-inline">W</span>：<span class="math-inline">W = { w_{0}^0, w_{0}^1, \ldots, w_{0}^{|c_0|} } \cup { w_{T}^0, w_{T}^1, \ldots, w_{T}^{|c_T|} }</span>。这里，来自会话 <span class="math-inline">t</span> 的类别 <span class="math-inline">c</span> 的原型 <span class="math-inline">w_{t}^c</span> 定义为该类别所有样本嵌入的平均值：<span class="math-inline">w_{t}^c = \frac{1}{|P|} \sum_{j \in P_i} f_\theta(x_j)</span>，其中 <span class="math-inline">P_i</span> 定义为 <span class="math-inline">{j : y_j = i}</span>。接下来，我们考虑线性调整作为基线，在增量冻结方法中训练模型，编码器仅在第一次会话上训练，随后的会话使用原型学习 [50]。最后，我们使用参数高效微调作为第三个基线，我们在预训练编码器的不同层添加 LoRA，并在保持编码器冻结的同时训练新添加的 LoRA。</p>
<h3 id="42-实验设置">4.2 实验设置<a class="anchor-link" href="#42-实验设置" title="Permanent link">&para;</a></h3>
<p><strong>数据集</strong>。我们在 16 个不同的数据集上全面评估了我们提出的方法的性能，包括通用对象检测（Caltech101 [12], CIFAR-100 [26], CUB-200 [45], MiniImageNet [40], VOC 2007 [11]），细粒度识别（OxfordPets [34], StanfordCars [25], Flower102 [33], Food101 [1], FGVCAircraft [29]），场景识别（SUN397 [46], Country211 [36]），卫星图像（EuroSAT [14], Resisc-45 [5]），纹理识别（DTD [8]）和交通标志识别（GTSRB [17]）。</p>
<p><strong>实现细节</strong>。默认情况下，我们将类别分成 10 个（或 9 个；见附录详情）会话，并执行 10 次连续训练，每次会话的类别数量相等，遵循 FSCIL 文献 [50, 51]。每个会话后的准确率计算为到目前为止所有类别的平均准确率。除非另有说明，否则准确率是指最后一次会话后的平均准确率，即所有类别的平均准确率。我们还在传统的 FSCIL 设置中评估了 CoACT，其中初始训练是使用与增量会话相同的分布的大型标记集进行的，然后对少样本增量会话进行调整。我们使用 ViT-B/16 作为大多数实验的骨干网络，同时我们也展示了使用 ViT-B/32 和 ViT-L/16 作为骨干网络的详细每个数据集结果。编码器在 ImageNet-21K [40] 上预训练。该框架在 PyTorch 上实现，实验在 Nvidia V100 GPU 上进行，训练大约需要 6 个小时。有关超参数的更多详细信息，请参见附录 A.2。</p>
<h3 id="43-结果">4.3 结果<a class="anchor-link" href="#43-结果" title="Permanent link">&para;</a></h3>
<p>我们在表 2 中展示了我们方法在 16 个数据集上的平均准确率和标准差（3 次运行的平均值），并与前述基线进行了比较。从表中我们可以看到，CoACT 在 16 个数据集上实现了 61.43% 的平均准确率，比其他方法平均高出 2.47%。在基线中，LoRA 以 58.96% 的准确率排名第二。其他两个基线显示出与 LoRA 相对相似的平均准确率。请注意，基线中，使用冻结编码器的原型学习是一个确定性过程，因此标准差为 0。请注意，正如我们稍后在表 4 中展示的，标准 FSCIL 设置中的最先进方法比之前的作品实现了约 1% 的增益。</p>
<p>接下来，我们在图 4（左）中报告了每种方法学习到的类别的遗忘情况，以第一次会话的准确率下降来衡量。从这个图中我们观察到，CoACT 的遗忘量最少，与基线相比大约有 1.5% 的遗忘，比 LoRA 和线性调整少，比原型学习少 3.2%。我们还展示了一个准确率的细分，包括第一次增量会话、剩余增量会话和所有会话的准确率，在图 4（右）。在这里，所有方法的第一次会话都显示出比其他会话更高的准确率，因为还没有其他类别的干扰（或遗忘）。虽然 LoRA 和线性调整的总体准确率高于原型调整，但提高主要来自于第一次会话的更高准确率。然而，所有基线在剩余会话中的表现都相对相似。相比之下，CoACT 在第一次和剩余会话中都显示出更高的改进。</p>
<p>为了进一步评估 CoACT 的有效性，我们研究了不同类别样本数量下的性能，包括 1、2、4、8 和 16。如图 5 所示，CoACT 在所有设置中都优于其他方法，并在极低样本设置中显示出鲁棒性。基线在不同样本数量下的效果各不相同。例如，在 1 次和 2 次拍摄设置中，原型学习比线性调整和 LoRA 表现更好，而随着样本数量的增加，其他两种方法表现更好。这些结果表明，与我们的方法和原型学习相比，线性调整和 LoRA 在极低样本设置中没有学习到非常有效的表示。</p>
<p>最后，在表 3 中，我们使用三种不同的编码器骨干网络展示了每个数据集的详细结果。以 ViT-B/16 为骨干网络时，CoACT 在原型学习、线性调整和 LoRA 上分别平均提高了 2.66%、2.54% 和 2.47%。值得注意的是，在一些个别数据集上，如 Resisc45，它显示出高达 12.79% 的改进。总体而言，我们发现对于更具挑战性的数据集，改进相对较大。例如，在准确率最低的 5 个数据集（Country211、FGVCAircraft、GTSRB、Resisc-45 和 StanfordCars）上，CoACT 比最佳基线方法（LoRA）平均提高了 6.14%。我们发现使用其他两种编码器（ViT-B/32 和 ViT-L/16）的性能也有类似的改进，其中 CoACT 分别以平均准确率 2.08% 和 1.67% 超过了最佳基线（LoRA）。</p>
<p>为了进一步评估我们方法的有效性，我们还研究了其在传统 FSCIL 设置中的性能。按照现有文献，我们在 CIFAR-100、CUB-200 和 miniImageNet 数据集上展示了这些结果。在表 4 中，我们将 CoACT 的性能与现有方法进行了比较，这些方法分为两组：第一组训练随机初始化的模型，第二组使用预训练的编码器。这个表的扩展版本，包括更多现有方法，在附录 A.3 中展示。如表中所示，CoACT 在没有预训练编码器的情况下，比之前的最佳方法（BOT [39]）提高了 25.88%，在有预训练编码器的情况下（CPE-CLIP [9]）提高了 4.11%。为了与现有方法进行公平比较，我们使用与 CoACT 相同的预训练编码器（ViT-B/16）评估了 SAVC [42] 和 BOT [39]，这两种方法的性能都明显低于 CoACT。CUB-200 和 miniImageNet 数据集上的结果在图 6 中展示（见附录 A.3）。对于 CUB-200 数据集，我们提出的方法分别超过了 BOT 和 CPE-CLIP 17.44% 和 5.02%，而在 miniImageNet 数据集上，与这两种最佳方法相比，改进分别为 36.67% 和 13.47%。</p>
<p>接下来，我们研究了 CoACT 与之前的最佳方法（BOT 和 CPE-CLIP）在遗忘已学习类别方面的比较。从图 7 中我们发现，CoACT 在增量会话中的遗忘量低于之前的最佳方法。具体来说，CoACT 的遗忘量为 5.8%，而 CPE-CLIP 为 7.3%，BOT 为 21.5%。这进一步展示了 CoACT 在增量学习会话中对遗忘的鲁棒性。</p>
<h2 id="5-结论">5. 结论<a class="anchor-link" href="#5-结论" title="Permanent link">&para;</a></h2>
<p>为了使用预训练的大型视觉模型实现少样本类别增量学习，我们提出了CoACT方法。我们的方法能够有效地调整基础模型，以便在不丢失预训练泛化能力或遗忘之前学习过的类别的情况下学习新类别。广泛的研究表明了我们方法的有效性，实现了更高的准确率、更低的遗忘率，并且在低样本设置中表现出鲁棒性。CoACT在标准FSCIL设置中也大幅度超越了之前的最佳方法。我们对CoACT的不同组成部分进行了全面的实验，并提供了我们的代码，以促进该领域的快速发展。</p>
<p><strong>局限性</strong>。我们的研究仅关注类别增量学习，但调整基础模型的概念也可以探索用于其他形式的持续学习，例如任务增量学习。此外，CoACT的一个局限性是它包含一些超参数，尽管我们的研究显示这些参数在我们的16个数据集的研究中对性能的影响很小。</p>
<p><strong>更广泛的影响</strong>。我们的工作集中在少样本调整基础模型上，这些模型具有令人印象深刻的泛化能力，可以有效地使用有限的数据学习新类别。虽然我们的方法没有任何直接的负面影响，但它具有与任何调整方法相同的潜在风险，即模型可能被调整以学习不想要的用例。另一方面，我们提出的解决方案可能具有巨大的积极影响，因为这项工作中提出的概念可以探索用于更新基础模型以学习新类别，而无需从头开始训练，从而节省计算和其他资源。</p>
                </div>

                <!-- Comments Section (Giscus) -->
                <section class="comments-section">
                    <h3><i class="fas fa-comments"></i> 评论</h3>
                    <script src="https://giscus.app/client.js"
                        data-repo="Geeks-Z/Geeks-Z.github.io"
                        data-repo-id=""
                        data-category="Announcements"
                        data-category-id=""
                        data-mapping="pathname"
                        data-strict="0"
                        data-reactions-enabled="1"
                        data-emit-metadata="0"
                        data-input-position="bottom"
                        data-theme="preferred_color_scheme"
                        data-lang="zh-CN"
                        crossorigin="anonymous"
                        async>
                    </script>
                </section>
            </article>

            <footer class="post-footer">
                <p>© 2025 Hongwei Zhao. Built with ❤️</p>
            </footer>
        </main>
    </div>

    <!-- Theme Toggle Button -->
    <button class="theme-toggle" id="themeToggle" aria-label="切换主题">
        <i class="fas fa-moon"></i>
    </button>

    <script>
        // Theme Toggle
        const themeToggle = document.getElementById('themeToggle');
        const html = document.documentElement;
        const icon = themeToggle.querySelector('i');
        const hljsDark = document.getElementById('hljs-theme-dark');
        const hljsLight = document.getElementById('hljs-theme-light');
        
        // Check saved theme or system preference
        const savedTheme = localStorage.getItem('theme');
        const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
        
        if (savedTheme === 'dark' || (!savedTheme && prefersDark)) {
            html.setAttribute('data-theme', 'dark');
            icon.className = 'fas fa-sun';
            hljsDark.disabled = false;
            hljsLight.disabled = true;
        }
        
        themeToggle.addEventListener('click', () => {
            const isDark = html.getAttribute('data-theme') === 'dark';
            if (isDark) {
                html.removeAttribute('data-theme');
                icon.className = 'fas fa-moon';
                localStorage.setItem('theme', 'light');
                hljsDark.disabled = true;
                hljsLight.disabled = false;
            } else {
                html.setAttribute('data-theme', 'dark');
                icon.className = 'fas fa-sun';
                localStorage.setItem('theme', 'dark');
                hljsDark.disabled = false;
                hljsLight.disabled = true;
            }
            
            // Update Giscus theme
            const giscusFrame = document.querySelector('iframe.giscus-frame');
            if (giscusFrame) {
                giscusFrame.contentWindow.postMessage({
                    giscus: {
                        setConfig: {
                            theme: isDark ? 'light' : 'dark'
                        }
                    }
                }, 'https://giscus.app');
            }
        });
        
        // Highlight.js
        document.addEventListener('DOMContentLoaded', () => {
            hljs.highlightAll();
        });
        
        // KaTeX auto-render
        document.addEventListener('DOMContentLoaded', () => {
            if (typeof renderMathInElement !== 'undefined') {
                renderMathInElement(document.body, {
                    delimiters: [
                        {left: '$$', right: '$$', display: true},
                        {left: '$', right: '$', display: false},
                        {left: '\\[', right: '\\]', display: true},
                        {left: '\\(', right: '\\)', display: false}
                    ],
                    throwOnError: false
                });
            }
        });
        
        // TOC active state
        const tocLinks = document.querySelectorAll('.toc-container a');
        const headings = document.querySelectorAll('.post-content h2, .post-content h3, .post-content h4');
        
        function updateTocActive() {
            let current = '';
            headings.forEach(heading => {
                const rect = heading.getBoundingClientRect();
                if (rect.top <= 100) {
                    current = heading.getAttribute('id');
                }
            });
            
            tocLinks.forEach(link => {
                link.classList.remove('active');
                if (link.getAttribute('href') === '#' + current) {
                    link.classList.add('active');
                }
            });
        }
        
        window.addEventListener('scroll', updateTocActive);
        updateTocActive();
    </script>
</body>
</html>
