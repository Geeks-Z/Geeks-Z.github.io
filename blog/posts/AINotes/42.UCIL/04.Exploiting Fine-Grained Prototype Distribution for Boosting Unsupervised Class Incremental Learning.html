<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Untitled</title>
    <meta name="description" content="Untitled - Hongwei Zhao's Blog">
    <meta name="author" content="Hongwei Zhao">
    
    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Noto+Sans+SC:wght@300;400;500;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    
    <!-- Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <!-- Code Highlighting -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css" id="hljs-theme-dark">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css" id="hljs-theme-light" disabled>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    
    <!-- KaTeX for Math -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>
    
    <style>
        :root {
            /* Light Theme */
            --primary-color: #2980b9;
            --primary-hover: #1a5276;
            --link-color: #c0392b;
            --text-color: #333;
            --text-light: #666;
            --text-muted: #999;
            --bg-color: #fff;
            --bg-secondary: #f8f9fa;
            --bg-code: #f5f5f5;
            --border-color: #e5e7eb;
            --shadow: 0 1px 3px rgba(0,0,0,0.1);
            --shadow-lg: 0 4px 15px rgba(0,0,0,0.1);
        }

        [data-theme="dark"] {
            --primary-color: #5dade2;
            --primary-hover: #85c1e9;
            --link-color: #e74c3c;
            --text-color: #e5e7eb;
            --text-light: #9ca3af;
            --text-muted: #6b7280;
            --bg-color: #1a1a2e;
            --bg-secondary: #16213e;
            --bg-code: #0f0f23;
            --border-color: #374151;
            --shadow: 0 1px 3px rgba(0,0,0,0.3);
            --shadow-lg: 0 4px 15px rgba(0,0,0,0.4);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            scroll-behavior: smooth;
        }

        body {
            font-family: 'Inter', 'Noto Sans SC', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            font-size: 16px;
            line-height: 1.8;
            color: var(--text-color);
            background: var(--bg-color);
            transition: background-color 0.3s, color 0.3s;
        }

        a {
            color: var(--primary-color);
            text-decoration: none;
            transition: color 0.2s;
        }

        a:hover {
            color: var(--primary-hover);
            text-decoration: underline;
        }

        /* Layout */
        .page-wrapper {
            display: flex;
            max-width: 1400px;
            margin: 0 auto;
            padding: 2rem;
            gap: 3rem;
        }

        /* Sidebar TOC */
        .toc-sidebar {
            width: 260px;
            flex-shrink: 0;
            position: sticky;
            top: 2rem;
            height: fit-content;
            max-height: calc(100vh - 4rem);
            overflow-y: auto;
        }

        .toc-container {
            background: var(--bg-secondary);
            border-radius: 12px;
            padding: 1.5rem;
            border: 1px solid var(--border-color);
        }

        .toc-container h3 {
            font-size: 0.85rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-muted);
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .toc-container ul {
            list-style: none;
        }

        .toc-container li {
            margin-bottom: 0.5rem;
        }

        .toc-container a {
            font-size: 0.9rem;
            color: var(--text-light);
            display: block;
            padding: 0.25rem 0;
            border-left: 2px solid transparent;
            padding-left: 0.75rem;
            transition: all 0.2s;
        }

        .toc-container a:hover,
        .toc-container a.active {
            color: var(--primary-color);
            border-left-color: var(--primary-color);
            text-decoration: none;
        }

        .toc-container ul ul {
            margin-left: 1rem;
        }

        /* Main Content */
        .main-content {
            flex: 1;
            min-width: 0;
            max-width: 800px;
        }

        /* Header */
        .post-header {
            margin-bottom: 2rem;
            padding-bottom: 1.5rem;
            border-bottom: 1px solid var(--border-color);
        }

        .back-link {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.9rem;
            color: var(--text-light);
            margin-bottom: 1.5rem;
        }

        .back-link:hover {
            color: var(--primary-color);
            text-decoration: none;
        }

        .post-header h1 {
            font-size: 2.25rem;
            font-weight: 700;
            line-height: 1.3;
            margin-bottom: 1rem;
            color: var(--text-color);
        }

        .post-meta {
            display: flex;
            flex-wrap: wrap;
            gap: 1.5rem;
            font-size: 0.9rem;
            color: var(--text-light);
        }

        .post-meta span {
            display: flex;
            align-items: center;
            gap: 0.4rem;
        }

        .post-meta i {
            color: var(--text-muted);
        }

        .tags {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-top: 1rem;
        }

        .tag {
            display: inline-block;
            font-size: 0.8rem;
            background: var(--bg-secondary);
            color: var(--text-light);
            padding: 0.25rem 0.75rem;
            border-radius: 20px;
            border: 1px solid var(--border-color);
            transition: all 0.2s;
        }

        .tag:hover {
            background: var(--primary-color);
            color: white;
            border-color: var(--primary-color);
        }

        /* Article Content */
        .post-content {
            font-size: 1rem;
            line-height: 1.9;
        }

        .post-content h1,
        .post-content h2,
        .post-content h3,
        .post-content h4,
        .post-content h5,
        .post-content h6 {
            margin-top: 2rem;
            margin-bottom: 1rem;
            font-weight: 600;
            line-height: 1.4;
            color: var(--text-color);
        }

        .post-content h1 { font-size: 1.875rem; }
        .post-content h2 { 
            font-size: 1.5rem; 
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--border-color);
        }
        .post-content h3 { font-size: 1.25rem; }
        .post-content h4 { font-size: 1.125rem; }

        .post-content p {
            margin-bottom: 1.25rem;
        }

        .post-content ul,
        .post-content ol {
            margin: 1.25rem 0;
            padding-left: 1.5rem;
        }

        .post-content li {
            margin-bottom: 0.5rem;
        }

        .post-content blockquote {
            margin: 1.5rem 0;
            padding: 1rem 1.5rem;
            background: var(--bg-secondary);
            border-left: 4px solid var(--primary-color);
            border-radius: 0 8px 8px 0;
            color: var(--text-light);
            font-style: italic;
        }

        .post-content blockquote p:last-child {
            margin-bottom: 0;
        }

        /* Code */
        .post-content code {
            font-family: 'JetBrains Mono', 'Fira Code', Consolas, monospace;
            font-size: 0.9em;
            background: var(--bg-code);
            padding: 0.2em 0.4em;
            border-radius: 4px;
            color: var(--link-color);
        }

        .post-content pre {
            margin: 1.5rem 0;
            padding: 1.25rem;
            background: var(--bg-code);
            border-radius: 10px;
            overflow-x: auto;
            border: 1px solid var(--border-color);
        }

        .post-content pre code {
            background: none;
            padding: 0;
            color: inherit;
            font-size: 0.875rem;
            line-height: 1.6;
        }

        /* Images */
        .post-content img {
            max-width: 100%;
            height: auto;
            border-radius: 10px;
            margin: 1.5rem 0;
            box-shadow: var(--shadow-lg);
        }

        /* Tables */
        .post-content table {
            width: 100%;
            margin: 1.5rem 0;
            border-collapse: collapse;
            font-size: 0.95rem;
        }

        .post-content th,
        .post-content td {
            padding: 0.75rem 1rem;
            border: 1px solid var(--border-color);
            text-align: left;
        }

        .post-content th {
            background: var(--bg-secondary);
            font-weight: 600;
        }

        .post-content tr:nth-child(even) {
            background: var(--bg-secondary);
        }

        /* Math */
        .math-display {
            margin: 1.5rem 0;
            overflow-x: auto;
            padding: 1rem;
            background: var(--bg-secondary);
            border-radius: 8px;
        }

        /* Anchor links */
        .anchor-link {
            opacity: 0;
            margin-left: 0.5rem;
            color: var(--text-muted);
            font-weight: 400;
            transition: opacity 0.2s;
        }

        .post-content h2:hover .anchor-link,
        .post-content h3:hover .anchor-link,
        .post-content h4:hover .anchor-link {
            opacity: 1;
        }

        /* Theme Toggle */
        .theme-toggle {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: var(--primary-color);
            color: white;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.25rem;
            box-shadow: var(--shadow-lg);
            transition: transform 0.2s, background 0.2s;
            z-index: 1000;
        }

        .theme-toggle:hover {
            transform: scale(1.1);
            background: var(--primary-hover);
        }

        /* Comments Section */
        .comments-section {
            margin-top: 3rem;
            padding-top: 2rem;
            border-top: 1px solid var(--border-color);
        }

        .comments-section h3 {
            font-size: 1.25rem;
            margin-bottom: 1.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        /* Footer */
        .post-footer {
            margin-top: 3rem;
            padding-top: 1.5rem;
            border-top: 1px solid var(--border-color);
            text-align: center;
            font-size: 0.9rem;
            color: var(--text-muted);
        }

        /* Responsive */
        @media (max-width: 1024px) {
            .toc-sidebar {
                display: none;
            }
            
            .page-wrapper {
                padding: 1.5rem;
            }
        }

        @media (max-width: 768px) {
            .post-header h1 {
                font-size: 1.75rem;
            }
            
            .post-meta {
                flex-direction: column;
                gap: 0.5rem;
            }
            
            .theme-toggle {
                bottom: 1rem;
                right: 1rem;
                width: 44px;
                height: 44px;
            }
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-secondary);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--text-muted);
        }
    </style>
</head>
<body>
    <div class="page-wrapper">
        <!-- TOC Sidebar -->
        <aside class="toc-sidebar">
            <div class="toc-container">
                <h3><i class="fas fa-list"></i> 目录</h3>
                <div class="toc">
<ul>
<li><a href="#kimi全文翻译-arrow_down">Kimi全文翻译 :arrow_down:</a></li>
<li><a href="#0-摘要">0. 摘要</a></li>
<li><a href="#1-引言">1. 引言</a></li>
<li><a href="#2-相关工作">2. 相关工作</a><ul>
<li><a href="#21-类别增量学习">2.1 类别增量学习</a></li>
<li><a href="#22-新类别发现">2.2 新类别发现</a></li>
</ul>
</li>
<li><a href="#3-提出的方法">3. 提出的方法</a><ul>
<li><a href="#31-问题定义">3.1 问题定义</a></li>
<li><a href="#32-框架概述">3.2 框架概述</a></li>
<li><a href="#33-细粒度原型的分布建模">3.3 细粒度原型的分布建模</a></li>
<li><a href="#34-通过粒度对齐进行无监督类别发现">3.4 通过粒度对齐进行无监督类别发现</a></li>
<li><a href="#35-通过重叠减少的知识保留">3.5 通过重叠减少的知识保留</a></li>
<li><a href="#36-训练过程">3.6 训练过程</a></li>
</ul>
</li>
<li><a href="#4-实验">4. 实验</a><ul>
<li><a href="#41-实验设置">4.1 实验设置</a></li>
<li><a href="#42-与领先方法的比较">4.2 与领先方法的比较</a></li>
<li><a href="#43-各组件的案例研究">4.3 各组件的案例研究</a></li>
<li><a href="#44-超参数分析">4.4 超参数分析</a></li>
</ul>
</li>
<li><a href="#5-结论和讨论">5. 结论和讨论</a></li>
</ul>
</div>

            </div>
        </aside>

        <!-- Main Content -->
        <main class="main-content">
            <article>
                <header class="post-header">
                    <a href="../../../index.html" class="back-link">
                        <i class="fas fa-arrow-left"></i> 返回博客列表
                    </a>
                    <h1>Untitled</h1>
                    <div class="post-meta">
                        <span><i class="fas fa-calendar-alt"></i> 2026-01-28</span>
                        <span><i class="fas fa-folder"></i> AINotes/42.UCIL</span>
                        <span><i class="fas fa-user"></i> Hongwei Zhao</span>
                    </div>
                    <div class="tags">
                        
                    </div>
                </header>

                <div class="post-content">
                    <h2 id="kimi全文翻译-arrow_down">Kimi全文翻译 :arrow_down:<a class="anchor-link" href="#kimi全文翻译-arrow_down" title="Permanent link">&para;</a></h2>
<h2 id="0-摘要">0. 摘要<a class="anchor-link" href="#0-摘要" title="Permanent link">&para;</a></h2>
<p>开放世界场景的动态特性吸引了越来越多的关注于类别增量学习（Class Incremental Learning, CIL）。然而，现有的CIL方法通常假设在整个训练过程中都有完整的真实标签可用，这在实际应用中很少见。因此，本文探索了一个更具挑战性的问题——无监督类别增量学习（Unsupervised Class Incremental Learning, UCIL）。解决这个问题的关键在于有效捕获全面的特征表示，并发现未知的新类别。为了实现这一点，我们首先通过利用细粒度原型对类分布知识进行建模。随后，引入了一种粒度对齐技术来增强无监督类别发现。此外，我们提出了一种策略，以最小化新旧类别之间的重叠，从而保留历史知识并减轻灾难性遗忘现象。在五个数据集上的广泛实验表明，我们的方法显著优于当前的最先进方法，证明了所提方法的有效性。</p>
<h2 id="1-引言">1. 引言<a class="anchor-link" href="#1-引言" title="Permanent link">&para;</a></h2>
<p>现实世界环境的动态性使得类别增量学习（Class Incremental Learning, CIL）越来越受到关注，CIL的目标是使模型能够随时间适应并整合新类别。然而，现有的CIL方法[28; 45; 10; 40]通常假定在训练过程中可以获得所有真实标签，这在许多真实场景中是不现实的。随着新类别数据的出现，及时获取完整的真实标签可能变得不切实际。在更现实的场景中，可能只有少数标签甚至没有标签可用。因此，本文专注于一个更现实且具有挑战性的问题——无监督类别增量学习（Unsupervised Class Incremental Learning, UCIL），旨在解决没有任何标签信息的CIL问题。</p>
<p>CIL和UCIL问题的最大挑战是如何捕获全面的特征表示，这些表示能有效地对现有和即将到来的未知类别的分布进行建模。这种能力对于保留历史知识以防止灾难性遗忘以及同时发现和学习新类别至关重要。现有的CIL方法通常依赖于包括正则化[14; 13]、动态结构[18; 32]或知识复现[11; 30]的策略。这些方法使用有监督数据来学习数据表示和类别决策边界，随着标签空间的扩展。然而，这些方法在同时整合新概念和保留现有知识方面存在权衡[43]，尤其是在无监督方式下。在这种情况下，现有类别和新类别之间的特征重叠为这个问题增加了额外的复杂性[41]。因此，本文的主要目标是有效地对无监督建模知识表示进行研究。</p>
<p>此外，由于UCIL中没有真实标签可用，这带来了另一个挑战，即更好地发现并有效分类未知的新类别。为此，关键是发现特征空间中的潜在聚类结构，并利用这些结构来学习分类器。现有方法经常使用k-Means聚类[1]、对比学习[36; 19]或基于最优传输的技术[25; 44; 20]进行无监督学习。然而，这些方法通过类别级别的伪标签引导分类器的学习，并可能引入偏差和偏差。因此，本文的另一个目标是提出一种新策略，用于捕获特征空间中的聚类结构，以促进潜在未标记类别的发现和识别。</p>
<p>本文中，我们引入了一个新颖的框架，利用细粒度原型分布来增强UCIL。为了以无监督的方式捕获更全面的类别表征，我们采用了大量预训练的ViT[3]。ViT被用作特征编码器，并在训练期间保持冻结状态。此外，我们利用细粒度原型分布来捕获特征空间中的更详细信息。为了更准确地发现未标记的类别，我们提出了一种新颖的粒度对齐方法，通过更细粒度的分配分布引导分类器的训练。此外，通过捕获原型内部的类别分布，我们开发了一种减少新旧类别之间重叠的策略，从而保留历史知识并减轻遗忘现象。大量的实验结果表明，与现有的最先进方法相比，我们的方法有显著的改进，在CIFAR100和CUB数据集上分别提高了9.1%和9.0%。我们的贡献总结如下：</p>
<ul>
<li>我们考虑了一种更现实的无监督类别增量学习场景，并提出了一种有效的方法。</li>
<li>我们提出了一种新策略，使用细粒度原型对详细类别分布进行建模，并通过粒度对齐提高更准确类别发现的能力。</li>
<li>我们在五个基准数据集上取得了显著的性能提升，与现有最先进方法相比有大幅度的提高。广泛的案例研究从不同角度证明了所提方法的有效性。</li>
</ul>
<h2 id="2-相关工作">2. 相关工作<a class="anchor-link" href="#2-相关工作" title="Permanent link">&para;</a></h2>
<h3 id="21-类别增量学习">2.1 类别增量学习<a class="anchor-link" href="#21-类别增量学习" title="Permanent link">&para;</a></h3>
<p>在类别增量学习领域，面临的主要挑战是在保留先前学习的知识的同时学习新类别，这些任务的类别集合是不重叠的。为应对这一挑战，已出现了三种主要策略：基于复演的方法[28; 30; 21; 11]、基于正则化的方法[14; 35; 45; 13]和动态架构方法[18; 32; 43; 10]。近期CIL研究的一个显著趋势是将预训练的变换器网络集成作为特征提取器[40; 23; 47]，这有助于获取更好的表征并减少遗忘。然而，这些现有方法需要在每个增量步骤中都有标签信息，这在现实场景中是不可行的。因此，一个新的挑战在于如何在连续的未标记数据流中有效发现类别。最近的一项解决方案是Msc-iNCD[20]，它利用了分类器权重的余弦归一化和冻结特征机制。基于此基础，我们的方法引入了一种新方法，为无标签的CIL问题提供了新的视角。</p>
<h3 id="22-新类别发现">2.2 新类别发现<a class="anchor-link" href="#22-新类别发现" title="Permanent link">&para;</a></h3>
<p>新类别发现（Novel Class Discovery, NCD）任务专注于在未标记数据集中识别未知类别，同时利用已知的标记数据集。传统的NCD方法[8; 7; 9]通常在不现实的假设下运作，即未标记集合仅从未知新类别中采样。为了改进，广义类别发现（Generalized Class Discovery, GCD）[36; 27; 19]解决了一个更复杂的场景，其中测试集由已知和未知的类别组成，所有这些类别都需要同时被识别。一些最近的进展集中在以顺序方式逐步发现和学习类别[42; 31; 12; 22]。然而，这些方法受到几个因素的限制，这些因素限制了增量学习会话的数量[12]，需要每个任务的标识符（task-id）[22]，并且每次会话都需要访问标记数据。这些限制限制了它们在动态现实环境中的适用性，这些环境中未知类别在持续演变。我们提出的方法旨在提供一种更适应性和现实的方法来处理未标记的连续类别序列中的NCD。</p>
<h2 id="3-提出的方法">3. 提出的方法<a class="anchor-link" href="#3-提出的方法" title="Permanent link">&para;</a></h2>
<h3 id="31-问题定义">3.1 问题定义<a class="anchor-link" href="#31-问题定义" title="Permanent link">&para;</a></h3>
<p>在无监督类别增量学习（UCIL）的设置中，模型连续观察到 T 个顺序的任务，每个任务都呈现出数据集 <span class="math-inline">D_t</span>，其中只包含未标记的样本 <span class="math-inline">x_{ti} \in X_t</span>。在训练期间无法评估对应的标签集合 <span class="math-inline">Y_t</span>。按照 CIL 领域的常见设置 [28; 20]，不同任务的类别是互不相交的，即 <span class="math-inline">Y[i] \cap Y[j] = \emptyset</span>，并且模型只能获取当前任务的类别。我们假设新类别的数量 <span class="math-inline">cNum = |Y_t|</span> 是预先知道的。在每个任务 t 中，我们的目标是发现 <span class="math-inline">D_t</span> 中的未知类别，并将实例准确识别到相应的发现的类别中，同时保持对之前任务 <span class="math-inline">D_1</span> 到 <span class="math-inline">D_{t-1}</span> 中的类别的性能。换句话说，我们提出的方法旨在增量地学习一个分类器，它可以将任何测试实例 x 分到从未标记数据流 <span class="math-inline">D = {D_1, D_2, \ldots, D_T}</span> 中发现的类别 <span class="math-inline">X \rightarrow \bigcup_{t=1}^{T} Y_t</span>，无需任务标识符的帮助。</p>
<h3 id="32-框架概述">3.2 框架概述<a class="anchor-link" href="#32-框架概述" title="Permanent link">&para;</a></h3>
<div align=center><img src="https://markdownimg-hw.oss-cn-beijing.aliyuncs.com/20240824135100.png" style="zoom: 60%;" /></div>

<p>在介绍详细方法之前，我们首先介绍我们方法的网络架构，如图 1 所示。我们的方法采用预训练的视觉变换器 ViT-B/16 [3] 作为特征提取器 f 以获取更多语义特征 z。在所有训练阶段，f 的参数都被冻结，以避免遗忘并减少参数计算量。在特征提取器之后，使用可训练的原型 w 用于对特征空间中的细粒度分布进行建模。另一个分支包含一个由投影器 g(·) 和类别中心 c 组成的分类器，用于类别识别和预测。使用这些原型可以存储历史类别的知识，然后采样以减少与新类别的重叠。</p>
<h3 id="33-细粒度原型的分布建模">3.3 细粒度原型的分布建模<a class="anchor-link" href="#33-细粒度原型的分布建模" title="Permanent link">&para;</a></h3>
<p>UCIL 的主要目标是捕获全面的特征表示。先前的方法 [20; 31] 通常使用每个类别的一个原型，并基于单一高斯类分布的假设存储示例以保留知识。与此相反，本文通过利用细粒度原型来捕获特征空间中的详细分布。通过有效地建模现有和即将到来的类别的分布，这种方法不仅减轻了知识遗忘，还增强了新类别的发现和学习。</p>
<p>为了提供更直观的理解，我们在图 2 中提供了这些原型在特征空间中的可视化。在该图中，三角形代表细粒度原型，上面和下面的数字分别有 20 和 40 个真实类别。我们可以看到学习到的原型可以捕获全面的特征表示，并模仿特征分布的密度，捕获特征分布的子簇结构。</p>
<p>更具体地说，细粒度原型可以基于高斯混合方式进行探索和优化。正式地，对于任务 t 中的输入数据 <span class="math-inline">x_i \in D_t</span>，我们可以通过 <span class="math-inline">z_i = f(x_i)</span> 获得特征。此外，我们的方法在特征空间中采用一组高斯原型 W，其中 <span class="math-inline">w \sim N(\mu_w, \sigma_w^2 I)</span>。这里，<span class="math-inline">\mu_w</span> 和 <span class="math-inline">\sigma_w</span> 是可训练的参数。为了在细粒度级别上模拟特征空间中未定义的分布，我们将每个特征 <span class="math-inline">z_i</span> 与这些细粒度高斯原型关联，以指示 <span class="math-inline">z_i</span> 属于哪个细粒度子类。假设 <span class="math-inline">r = pNumt</span> 是任务 t 中的原型数量，这是预先定义的并且远大于潜在的类别数量。假设 <span class="math-inline">w_i</span> 和 <span class="math-inline">z_i</span> 都是 l2 标准化的，则后验概率 <span class="math-inline">p(w_i | z_i)</span> 由下式给出：<br />
<div class="math-display"><br />
    p(w_i | z_i) = \frac{\exp\left(\frac{2(z_i^\top \mu_{w_i} - 1)}{\sigma_{w_i}^2}\right)}{\sum_{w' \in W} \exp\left(\frac{2(z_i^\top \mu_{w'} - 1)}{\sigma_{w'}^2}\right) \pi_{w'} }<br />
</div><br />
其中 <span class="math-inline">\pi_{w_i}</span> 是高斯原型的权重，<span class="math-inline">\sigma_{w_i}</span> 是简化起见采用对角形式。然而，直接通过最小化 n 个观测特征上的负对数似然来优化是困难的，因此我们采用变分近似 <span class="math-inline">q(w|z)</span> 来逼近真实分布 <span class="math-inline">p(w|z)</span>。这个问题的证据下界（ELBO）如下：<br />
<div class="math-display"><br />
    \text{ELBO} = \frac{1}{n} \sum_{i=1}^{n} \log \left( \sum_{w} p(w | z_i) \right) = \frac{1}{n} \sum_{i=1}^{n} \log \left( \sum_{w} q(w | z_i) \frac{p(w | z_i)}{q(w | z_i)} \right) \geq \frac{1}{n} \sum_{i=1}^{n} \left( \sum_{w} q(w | z_i) \log \frac{p(w | z_i)}{q(w | z_i)} \right)<br />
</div><br />
这可以通过交替推断后验 <span class="math-inline">q(w|z)</span> 来最大化。受到 [24] 的启发，这个问题可以通过期望最大化（EM）算法来解决。</p>
<p>E 步骤。给定某个 <span class="math-inline">p(w|z)</span>，为了推断 <span class="math-inline">q(w|z)</span>，设 <span class="math-inline">Q_{w_i,i} = q(w_i | z_i)</span> 和 <span class="math-inline">P_{w_i,i} = p(w_i | z_i)</span> 为两个 <span class="math-inline">r \times n</span> 矩阵。为了增加多样性并避免退化，我们强制要求每个细粒度高斯分量被分配相同数量的样本，其中 <span class="math-inline">\pi_{w_i}</span> 对所有 i 都是相等的。然后我们可以将 E 步骤转化为一个最优传输问题，如下所示：<br />
<div class="math-display"><br />
    \min_Q \text{Tr}(Q^\top \log P) - \epsilon H(Q)<br />
</div></p>
<p><div class="math-display"><br />
    Q \in \mathbb{R}^{r \times n}_+<br />
</div></p>
<p><div class="math-display"><br />
    \sum_{j=1}^{n} Q_{ij} = \frac{1}{r}, \sum_{i=1}^{r} Q_{ij} = \frac{1}{n}<br />
</div><br />
其中 <span class="math-inline">H(Q) = -\sum_{i,j} Q_{ij} \log Q_{ij}</span> 是熵函数，<span class="math-inline">\mathbf{1}_n</span> 是维度为 n 的全一矢量。<span class="math-inline">\epsilon</span> 是控制分配平滑度的比例参数。</p>
<p>上述方程的最优解可以写成 <span class="math-inline">Q^* = \text{Diag}(u) P^\lambda \text{Diag}(v)</span>，其中 <span class="math-inline">u \in \mathbb{R}^r</span> 和 <span class="math-inline">v \in \mathbb{R}^n</span> 是重新归一化的矢量。在实践中，该问题可以通过少量（我们设为 3）矩阵乘法，使用 Sinkhorn-Knopp[5] 算法高效解决。</p>
<p>M 步骤。在 E 步骤获得最优 <span class="math-inline">q^<em>(w|z)</span> 后，我们可以通过梯度方法优化可训练的 <span class="math-inline">\mu</span> 和 <span class="math-inline">\sigma</span>，如下所示：<br />
<div class="math-display"><br />
    L_{\text{proto}} = -\frac{1}{n} \sum_{i=1}^{n} q^</em>(w_i | z_i) \log p(w_i | z_i)<br />
</div><br />
讨论：方程 5 与原型对比学习方法（如 SwAV[2]）有相似的公式。然而，这些方法主要关注于学习表征，而我们的方法在理论上强调这些细粒度原型，它们是作为高斯而不是单一向量形成的。实验部分将对此进行案例研究。细粒度原型建模提供了两个关键好处：首先，它帮助保留特定任务的知识，以减少现有和新类别之间的重叠，从而防止遗忘。其次，这种方法使捕获更精细的特征分布成为可能，这将增强无监督类别发现，并将在以下部分讨论。</p>
<h3 id="34-通过粒度对齐进行无监督类别发现">3.4 通过粒度对齐进行无监督类别发现<a class="anchor-link" href="#34-通过粒度对齐进行无监督类别发现" title="Permanent link">&para;</a></h3>
<p>在本节中，我们将介绍一种新的粒度对齐策略，以通过探索的细粒度高斯原型来发现未知类别。首先，给定提取的特征 <span class="math-inline">z = f(x)</span>，分类器定义为：<br />
<div class="math-display"><br />
    Y = p(y|z) = \frac{\exp \langle c_y \circ g(z) / \tau \rangle}{\sum_{c' \in C_t} \exp \langle c' \circ g(z) / \tau \rangle},<br />
</div><br />
其中 <span class="math-inline">C_t = {c_t^1, ..., c_t^k}</span> 是每个已发现类别的可训练类别中心，k 是当前任务中的类别数量。τ 是温度参数。<span class="math-inline">g(z)</span> 是投影器，将 z 转换为一个降维空间，专注于粗粒度的聚类发现任务。按照先前的方法，<span class="math-inline">\langle \circ \rangle</span> 是通过每个 c 和 <span class="math-inline">g(z)</span> 的 l2 标准化后的余弦距离。</p>
<p>前一节已经获得了细粒度特征分配概率在多个高斯 <span class="math-inline">W = p(w|z)</span> 上。然后在无监督方式下学习分类器，之前优化的细粒度分配概率 Q 可以被视为学习分类器的指导。在实现中，我们通过最大化类级别分配概率 Y 和细粒度原型分配概率 W 之间的互信息来对齐粒度：<br />
<div class="math-display"><br />
    L_{\text{align}} = -I(W; Y) = \mathbb{E}<em>{(w,y) \sim p(w, y)} \left[ \log \frac{p(w, y)}{p(w) p(y)} \right] - \lambda</em>{\text{GA}} \mathbb{E}<em>y p(y) \log(p(y)),<br />
</div><br />
其中 <span class="math-inline">\lambda</em>{\text{GA}}</span> 是正则化权重，<span class="math-inline">p(w, y)</span> 是联合概率，<span class="math-inline">p(w)</span> 和 <span class="math-inline">p(y)</span> 是边缘项。命题 3.1 <span class="math-inline">p(w, y)</span> 等于矩阵乘法 <span class="math-inline">W^\top \cdot Y</span> ∈ <span class="math-inline">\mathbb{R}^{r \times k}</span>。</p>
<p>证明。<span class="math-inline">W = p(w|z)</span> ∈ <span class="math-inline">\mathbb{R}^{n \times r}</span> 和 <span class="math-inline">Y = p(y|z)</span> ∈ <span class="math-inline">\mathbb{R}^{n \times k}</span> 在 z 上条件独立，因为它们由独立的网络参数计算，那么<br />
<div class="math-display"><br />
    p(w_j, y_i) \approx \int p(w_j, y_i | z) dz = \int p(w_j | z) \cdot p(y_i | z) dz = \left[ W^\top \cdot Y \right]_{ij}.<br />
</div><br />
基于证明，我们还可以近似每个高斯原型到类别中心的条件分配关系 <span class="math-inline">p(y|w)</span> 如下：<br />
<div class="math-display"><br />
    p(y|w) = \frac{p(w, y)}{\sum_y p(w, y)},<br />
</div><br />
这可以用于增量学习期间的细粒度类别分布的知识保留，后续部分将提供更多细节。</p>
<p>讨论：大多数现有方法 [20; 29] 主要通过在相同粗粒度类别级别上使用伪标签来指导类别发现或聚类预测器的无监督学习。通过在 Y 和 W 之间进行粒度对齐，聚类模型被鼓励学习更丰富的特征表示，并将这些捕获的更详细特征与细粒度分配分布 W 结合起来。这种方法导致更有信息量的聚类决策，从而提高粗粒度类别级别 Y 上的无监督类别发现性能。这种方法的好处将在实验部分展示。</p>
<h3 id="35-通过重叠减少的知识保留">3.5 通过重叠减少的知识保留<a class="anchor-link" href="#35-通过重叠减少的知识保留" title="Permanent link">&para;</a></h3>
<p>在前一节中，我们专注于特定任务 t 内的无监督类别发现。没有历史知识，这种方法可能会冒着旧类别中心 <span class="math-inline">C_{\text{old}} = {C_1 \ldots C_{t-1}}</span> 和当前类别中心 <span class="math-inline">C_t</span> 之间特征重叠的风险，可能导致遗忘。为了缓解这个问题，本节介绍了一种重叠减少技术，用于微调分类器，使其能够在没有任务标识符信息的情况下识别当前和历史类别，同时不遗忘。</p>
<p>在每个任务结束时，当前任务的知识可以通过细粒度高斯原型集合 W 来建模和存储。具体来说，首先，通过方程 9 获得每个高斯原型对应的类别标签。然后，通过方程 1 派生出每个特征的分配概率 <span class="math-inline">p(w|z)</span>。因此，我们可以通过分配给每个 w 的样本特征计算统计信息，包括计数 <span class="math-inline">n_w</span>、均值 <span class="math-inline">\mu_w</span> 和方差 <span class="math-inline">\sigma_w^2 I</span>。我们还可以计算纯度 <span class="math-inline">PUR_w</span>，即分配给每个高斯的最大类别样本大小与总样本大小的比率。重新计算的每个高斯的参数可以更好地适应当前的特征分布。</p>
<p>因此，对于新任务，我们可以通过从记忆中采样特征来推导旧类别的知识：<br />
<div class="math-display"><br />
    D_{\text{old}} = {z, y} \sim \sum_{w \in W_y} \pi_w \mathcal{N} \left( \mu_w, \sigma_w^2 I \right),<br />
</div><br />
其中 <span class="math-inline">\pi_w = \frac{n_w \times PUR_w}{\sum_{w' \in W_y} n_{w'} \times PUR_{w'}}</span> 是每个 w 的权重项。我们为每个类别 y 采样等量的特征，以确保类别平衡。</p>
<p>为了避免遗忘，我们的目标是在当前分类器中保持对旧类别的辨别能力，联合使用类别中心 <span class="math-inline">c \in C_{\text{old}} \cup C_t</span> 通过类似交叉熵的目标函数：<br />
<div class="math-display"><br />
    L_{\text{old}} = \frac{1}{|D_{\text{old}}|} \sum_{(z, \hat{y}) \in D_{\text{old}}} \sum_{c \in C_{\text{old}}} \exp \left \langle c \circ g(z) / \tau \right \rangle \Bigg/ \sum_{c' \in C_{\text{old}} \cup C_t} \exp \left \langle c' \circ g(z) / \tau \right \rangle.<br />
</div><br />
此外，为了解决当前类别和旧类别之间的特征重叠问题，我们提出了一种分离损失，使可训练的类别中心和当前任务的特征与旧任务的中心远离：<br />
<div class="math-display"><br />
    L_{\text{sep}} = \frac{1}{|D_t|} \sum_{z \in D_t} \frac{\exp \left \langle c \circ g(z) / \tau \right \rangle}{\sum_{c' \in C_{\text{old}} \cup C_t} \exp \left \langle c' \circ g(z) / \tau \right \rangle},<br />
</div><br />
其中 <span class="math-inline">c \in C_t</span> 是当前任务的类别中心，而 <span class="math-inline">C_{\text{old}}</span> 是旧任务的类别中心集合。然后最终的重叠减少目标形成为：<br />
<div class="math-display"><br />
    L_{\text{reduct}} = \lambda_{\text{old}} L_{\text{old}} + L_{\text{sep}}.<br />
</div></p>
<h3 id="36-训练过程">3.6 训练过程<a class="anchor-link" href="#36-训练过程" title="Permanent link">&para;</a></h3>
<p>算法 1 每个任务的训练过程。<br />
输入：<span class="math-inline">{D_t}<em>{t=1}^T</span>，高斯原型数量 <span class="math-inline">pNum</span>，类别数量 <span class="math-inline">cNum</span>，记忆 <span class="math-inline">M</span>。<br />
1. 对于 <span class="math-inline">D_t</span> 中的每个小批量，执行以下操作：<br />
2. 通过方程 3 获得 <span class="math-inline">Q</span>。<br />
3. 使用获得的 <span class="math-inline">Q</span> 计算 <span class="math-inline">L</em>{\text{proto}}</span> 和 <span class="math-inline">L_{\text{align}}</span>。<br />
4. 通过方程 10 从记忆 <span class="math-inline">M</span> 中采样 <span class="math-inline">D_{\text{old}}</span>。<br />
5. 通过方程 14 计算 <span class="math-inline">L_{\text{reduct}}</span>。<br />
6. <span class="math-inline">L \leftarrow L_{\text{proto}} + L_{\text{align}} + L_{\text{reduct}}</span>。<br />
7. 使用 Adam 优化器更新 <span class="math-inline">W_t, C_t, g_t</span>。<br />
8. 结束小批量处理。<br />
9. 通过更新的 <span class="math-inline">W, C, g</span> 检索 <span class="math-inline">M_t</span>。<br />
10. <span class="math-inline">M \leftarrow M \cup M_t</span>。</p>
<p>整体训练目标函数为：<span class="math-inline">L = L_{\text{proto}} + L_{\text{align}} + L_{\text{reduct}}</span>。具体来说，如图 1 和算法 1 所示，训练学习过程可以解耦为以下部分：<br />
1. 细粒度原型建模。使用细粒度高斯原型建模捕获详细的特征分布，其中高斯原型的数量 <span class="math-inline">pNum</span> 显著超过类别数量 <span class="math-inline">cNum</span>。<br />
2. 无监督类别发现。通过最大化细粒度原型分配 <span class="math-inline">p(w|z)</span> 和类级别分配 <span class="math-inline">p(y|z)</span> 之间的粒度对齐来指导分类器的训练。<br />
3. 保留历史知识。在学会的高斯原型 <span class="math-inline">w</span> 上存储特征 z 的丰富统计信息。从未标记数据流 <span class="math-inline">D</span> 中采样旧数据 <span class="math-inline">D_{\text{old}}</span> 并将其与当前数据 <span class="math-inline">D_t</span> 连接，微调分类器，从而避免特征重叠并防止遗忘。</p>
<p>整体的训练目标函数是 <span class="math-inline">L = L_{\text{proto}} + L_{\text{align}} + L_{\text{reduct}}</span>。具体来说，如图 1 和算法 1 所示，训练学习过程可以解耦为以下几个部分：</p>
<ol>
<li><strong>细粒度原型建模</strong>。利用细粒度高斯原型建模捕获详细的特征分布，其中高斯原型的数量 <span class="math-inline">pNum</span> 显著超过类别数量 <span class="math-inline">cNum</span>。</li>
<li><strong>无监督类别发现</strong>。通过最大化细粒度原型分配 <span class="math-inline">p(w|z)</span> 与类级别分配 <span class="math-inline">p(y|z)</span> 之间的粒度对齐来指导分类器的训练。</li>
<li><strong>保留历史知识</strong>。在学会的高斯原型 <span class="math-inline">w</span> 上存储特征 <span class="math-inline">z</span> 的丰富统计信息。从存储的细粒度原型中采样旧数据 <span class="math-inline">D_{\text{old}}</span> 并与当前数据 <span class="math-inline">D_t</span> 连接，微调分类器，以避免特征重叠并防止遗忘。</li>
</ol>
<h2 id="4-实验">4. 实验<a class="anchor-link" href="#4-实验" title="Permanent link">&para;</a></h2>
<h3 id="41-实验设置">4.1 实验设置<a class="anchor-link" href="#41-实验设置" title="Permanent link">&para;</a></h3>
<p><strong>数据集和分割</strong>。为了证明我们方法的有效性，我们在五个基准数据集上进行了实验：CIFAR-10 (C10) [15]、CIFAR-100 (C100) [15]、Tiny ImageNet (T200) [17]、CUB200-2011 [37] 和 Herbarium-683 (H683) [34]。值得注意的是，每个基准训练数据集被分割成两步或五步设置，具有不重叠的标签空间。例如，在五步设置中，CIFAR-100 被划分为 5 个任务，每个任务包含 20 个类别。评估在测试数据集上执行。</p>
<p><strong>评估协议</strong>。我们遵循 Msc-iNCD [20] 中概述的评估协议。我们主要报告的指标是在最终持续学习会话后的聚类准确率，称为整体发现准确率 <span class="math-inline">A</span>。这个指标是在包含所有以前遇到的类别的实例的测试集上评估的，分配是使用匈牙利算法 [16] 确定的。此外，我们还通过遗忘得分 <span class="math-inline">F</span> 来衡量遗忘程度，它量化了在第一次会话 <span class="math-inline">T1</span> 和最后一次会话 <span class="math-inline">T_{\text{end}}</span> 之间聚类准确率的下降，特别是对于在初始会话 <span class="math-inline">T1</span> 中发现的类别 <span class="math-inline">Y1</span>。重要的是要注意，在推理过程中，所有方法中的任务 ID 仍然未知。在某些特定实验中，我们还使用特定任务的发现准确率来评估在单个会话中发现新类别的性能。</p>
<p><strong>实现细节</strong>。我们使用 ViT-B/16 [6] 作为主干 <span class="math-inline">g</span>，利用 DINO [3] 的预训练权重，这些权重在所有实验中都保持冻结。768 维的输出 [CLS] 标记作为特征向量表示为 <span class="math-inline">z</span>。细粒度原型的数量设置为 <span class="math-inline">pNum = 1000</span>。对于投影，我们使用一个 2 层 MLP，有 768 个隐藏单元和 128 维的输出。我们使用 Sinkhorn-Knopp 算法 [5] 的默认超参数，将 <span class="math-inline">\epsilon</span> 设置为 0.05，迭代次数 <span class="math-inline">niter</span> 设置为 3。每个会话进行 200 次训练，批量大小设置为 512。使用 Adam 作为优化器，默认学习率为 <span class="math-inline">1e-3</span>。此外，我们为旧损失 <span class="math-inline">\lambda_{\text{old}}</span> 分配权重 10，为粒度对齐正则化项 <span class="math-inline">\lambda_{\text{GA}}</span> 分配权重 4。默认温度参数 <span class="math-inline">\tau</span> 保持在 0.1。我们稍后将在实验中探讨这些超参数的敏感性。实验在一台装有 Intel(R) Xeon(R) E5-2678 2.50GHz CPU、NVIDIA GeForce RTX 3090 GPU 和 32GB 内存的服务器上进行。</p>
<h3 id="42-与领先方法的比较">4.2 与领先方法的比较<a class="anchor-link" href="#42-与领先方法的比较" title="Permanent link">&para;</a></h3>
<p><strong>比较基线</strong>。为了进行比较分析，我们选择了七种基线方法：前五种是扩展的基线方法。其中两个是相关的增量新类别发现（iNCD）方法，包括 ResTune [22] 和 FRoST [31]。ResTune 可以在没有标签但有任务标识符的情况下发现新类别，而 FRoST 需要有监督信息来增量地发现类别。此外，还包括几种代表性的 CIL 方法进行比较，包括两种基于正则化的方法 EwC [14]、LwF [18]，以及一种基于复演的方法 DER [43]。虽然讨论的方法最初是在完全监督条件下开发的，但我们已经将它们适应到我们的方法中的 UCIL 框架。在这种适应中，真实标签被替换为伪标签，通过与 Msc-iNCD 中使用的相同的自训练策略获得。所有适应的方法都使用 DINO 预训练的 ViT-B/16 [3] 作为主干。在评估中，我们遵循相同的协议，主要将我们的方法与 Msc-iNCD [20] 及其高级版本 Msc-iNCD++ [20] 进行比较。尽管没有 MSc-iNCD 的公开代码，我们通过遵循他们论文中提供的伪代码简单地复制了他们的方法，达到了报告的性能水平。我们将其余基线方法的结果报告为 MSc-iNCD 论文中概述的内容，因为我们保持了相同的实验设置。</p>
<p><strong>结果</strong>。表 1 展示了与经过调整的基线方法的比较结果。可以观察到，扩展的基线方法在 UCIL 任务中表现不佳。例如，DER 由于从错误的伪标签中累积错误而表现出不稳定性，而 ResTune 在这项任务中挣扎，因为它依赖于任务标识符信息。这些结果突显了与 UCIL 任务相关联的挑战。此外，我们的方法在不同数据集上一致地大幅度超越了协议方法 Msc-iNCD 和 Msc-iNCD++。在更具挑战性的五步设置中，我们的方法与其他方法之间的性能差距逐渐扩大，表明我们的方法在具有更长步骤的挑战性场景中表现出色。值得注意的是，在增量五步设置中，我们在整体发现准确率方面取得了显著的改进，在 CIFAR-100 和 CUB 数据集上分别提高了 9.1% 和 9%。</p>
<h3 id="43-各组件的案例研究">4.3 各组件的案例研究<a class="anchor-link" href="#43-各组件的案例研究" title="Permanent link">&para;</a></h3>
<p>在本节中，我们通过不同场景和视角进行了一系列案例研究，旨在评估我们方法中每个组件的单独贡献。</p>
<p><strong>无监督类别发现的粒度对齐</strong>。在本节中，我们强调了粒度对齐策略在无监督类别发现任务中的有效性，作为自我引导。我们的关注点仅在于每个会话中特定任务的类别发现性能，与增量场景无关。为了量化这一点，我们测量了5个单独任务中聚类准确率的均值和方差，结果呈现在表 2 中。我们将我们提出的方法与 k-Means、MSc-iNCD，以及配备我们提出的粒度对齐（Granular Alignment, GA）方法的 MSciNCD 适应版本（称为 MSc-iNCD+GA）进行了比较。此外，我们还探索了从我们提出的方法中移除 GA 的影响，通过为每个类别设置一个原型（称为 ours w/o GA）。此外，我们还检验了我们方法在不同数量的细粒度原型下的性能。我们还进行了固定方程 1 中可训练参数 σ 的实验，将其命名为 ours w/o σ，并将其设置为 Msc-iNCD 中的 0.1。表 2 中的结果表明，MSc-iNCD+GA 的改进和 ours w/o GA 的性能下降都强调了粒度对齐对类别发现的积极影响。此外，增加原型数量可以带来性能的提升，表明细粒度建模有助于获得更好的聚类结果。不移动 σ 的下降进一步证明了高斯密度在建模概率分布上比常见的余弦距离更有益。</p>
<p><strong>细粒度原型用于知识保留</strong>。此外，我们强调了所提出的细粒度高斯原型学习在保留先前知识以防止遗忘方面的优势。如表 3 所示，我们展示了与其它设计方法相比的整体发现准确率和遗忘得分，并且只替换了我们方法中的记忆策略。Examplar 表示 CIL 中常用的策略，即在每个发现的类别中随机选择 {5,20,50} 个样本作为示例，并在每个会话后存储。Class-mean 是 Msc-iNCD 中使用的战略，涉及计算和存储每个发现类别的均值和方差。为了参考，我们还报告了使用不同数量的高斯原型集 {500, 1000, 2000, 5000} 以及相应的记忆大小的性能。表 3 显示，我们的战略在存储示例的实践中表现更好。这种优势是由于我们方法能够捕获和模拟特征分布的统计细微差别。此外，使用更多原型可以提高性能的结果，进一步证实了我们方法的有效性。</p>
<p><strong>重叠减少策略分析</strong>。如图 4 所示，我们通过选择性地移除或替换它们，检验了各种训练策略在重叠减少方法中的优势。具体来说：KTRFR 对应于 Msc-iNCD [20] 中采用的策略，通过重放旧样本和新样本进行分类器训练，使用伪标签。我们报告了用 KTRFR 替换我们的损失函数（方程 13）后的性能。w/o Lsep 表示在方程 12 中移除分离损失后的结果。w/o Proj 反映了在移除投影器 g 后的成果。结果强调了每个组件的重要性，证明了它们对我们最终性能的贡献。</p>
<h3 id="44-超参数分析">4.4 超参数分析<a class="anchor-link" href="#44-超参数分析" title="Permanent link">&para;</a></h3>
<p><strong>原型数量</strong>。虽然我们已经简要讨论了调整原型数量 (pNum) 的影响，但本节将更详细地探讨其影响。如图 3 所示，显然增加原型数量对类别发现和减少遗忘性能都有正面影响。在准确性和内存大小之间找到平衡，我们选择 pNum = 1000 作为我们方法的最佳选择。</p>
<p><strong>其他参数</strong>。如图 4 所示，我们分析了我们方法中使用的几种其他参数：(a) 和 (b) 分别表示在变化旧损失权重 <span class="math-inline">\lambda_{\text{old}}</span> 和粒度对齐正则化项权重 <span class="math-inline">\lambda_{\text{GA}}</span> 时的性能。值得注意的是，这些权重在广泛的值范围内表现出稳定性。(c) 展示了在方程 6 中使用的 temperature 参数 <span class="math-inline">\tau</span> 的敏感性分析。我们选择推荐的值 0.1，与大多数使用 l2 标准化余弦距离的先前研究一致。对于投影器输出的维度，(d) 显示我们的方法在各种常用设置中表现一致。这些结果共同强调了我们方法对超参数选择的鲁棒性和不敏感性。</p>
<h2 id="5-结论和讨论">5. 结论和讨论<a class="anchor-link" href="#5-结论和讨论" title="Permanent link">&para;</a></h2>
<p><strong>结论</strong>：我们的工作深入探讨了更具挑战性和实用性的问题——无监督类别增量学习（UCIL）。我们分析了有效捕获全面特征表示和发现未知新类别对于解决这一问题至关重要。基于这一洞见，我们提出了一种新的 UCIL 方法，利用细粒度原型分布以及粒度对齐和重叠减少策略。实验已经在五个数据集上证明了与现有最先进方法相比的显著改进。</p>
<p><strong>局限性 &amp; 未来工作</strong>：在本文中，我们考虑的是一个比传统 CIL 更实际的场景，即在训练期间缺少所有标签。然而，实际情况可能带来更多挑战，包括未知的类别数量、历史和新类别的混合，或者类别分布不均衡。未来的研究将努力提出更有效的方法来解决这些挑战，并在日益现实的场景中应用。</p>
                </div>

                <!-- Comments Section (Giscus) -->
                <section class="comments-section">
                    <h3><i class="fas fa-comments"></i> 评论</h3>
                    <script src="https://giscus.app/client.js"
                        data-repo="Geeks-Z/Geeks-Z.github.io"
                        data-repo-id=""
                        data-category="Announcements"
                        data-category-id=""
                        data-mapping="pathname"
                        data-strict="0"
                        data-reactions-enabled="1"
                        data-emit-metadata="0"
                        data-input-position="bottom"
                        data-theme="preferred_color_scheme"
                        data-lang="zh-CN"
                        crossorigin="anonymous"
                        async>
                    </script>
                </section>
            </article>

            <footer class="post-footer">
                <p>© 2025 Hongwei Zhao. Built with ❤️</p>
            </footer>
        </main>
    </div>

    <!-- Theme Toggle Button -->
    <button class="theme-toggle" id="themeToggle" aria-label="切换主题">
        <i class="fas fa-moon"></i>
    </button>

    <script>
        // Theme Toggle
        const themeToggle = document.getElementById('themeToggle');
        const html = document.documentElement;
        const icon = themeToggle.querySelector('i');
        const hljsDark = document.getElementById('hljs-theme-dark');
        const hljsLight = document.getElementById('hljs-theme-light');
        
        // Check saved theme or system preference
        const savedTheme = localStorage.getItem('theme');
        const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
        
        if (savedTheme === 'dark' || (!savedTheme && prefersDark)) {
            html.setAttribute('data-theme', 'dark');
            icon.className = 'fas fa-sun';
            hljsDark.disabled = false;
            hljsLight.disabled = true;
        }
        
        themeToggle.addEventListener('click', () => {
            const isDark = html.getAttribute('data-theme') === 'dark';
            if (isDark) {
                html.removeAttribute('data-theme');
                icon.className = 'fas fa-moon';
                localStorage.setItem('theme', 'light');
                hljsDark.disabled = true;
                hljsLight.disabled = false;
            } else {
                html.setAttribute('data-theme', 'dark');
                icon.className = 'fas fa-sun';
                localStorage.setItem('theme', 'dark');
                hljsDark.disabled = false;
                hljsLight.disabled = true;
            }
            
            // Update Giscus theme
            const giscusFrame = document.querySelector('iframe.giscus-frame');
            if (giscusFrame) {
                giscusFrame.contentWindow.postMessage({
                    giscus: {
                        setConfig: {
                            theme: isDark ? 'light' : 'dark'
                        }
                    }
                }, 'https://giscus.app');
            }
        });
        
        // Highlight.js
        document.addEventListener('DOMContentLoaded', () => {
            hljs.highlightAll();
        });
        
        // KaTeX auto-render
        document.addEventListener('DOMContentLoaded', () => {
            if (typeof renderMathInElement !== 'undefined') {
                renderMathInElement(document.body, {
                    delimiters: [
                        {left: '$$', right: '$$', display: true},
                        {left: '$', right: '$', display: false},
                        {left: '\\[', right: '\\]', display: true},
                        {left: '\\(', right: '\\)', display: false}
                    ],
                    throwOnError: false
                });
            }
        });
        
        // TOC active state
        const tocLinks = document.querySelectorAll('.toc-container a');
        const headings = document.querySelectorAll('.post-content h2, .post-content h3, .post-content h4');
        
        function updateTocActive() {
            let current = '';
            headings.forEach(heading => {
                const rect = heading.getBoundingClientRect();
                if (rect.top <= 100) {
                    current = heading.getAttribute('id');
                }
            });
            
            tocLinks.forEach(link => {
                link.classList.remove('active');
                if (link.getAttribute('href') === '#' + current) {
                    link.classList.add('active');
                }
            });
        }
        
        window.addEventListener('scroll', updateTocActive);
        updateTocActive();
    </script>
</body>
</html>
