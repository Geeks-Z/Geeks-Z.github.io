<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Untitled</title>
    <meta name="description" content="Untitled - Hongwei Zhao's Blog">
    <meta name="author" content="Hongwei Zhao">
    
    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Noto+Sans+SC:wght@300;400;500;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    
    <!-- Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <!-- Code Highlighting -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css" id="hljs-theme-dark">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css" id="hljs-theme-light" disabled>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    
    <!-- KaTeX for Math -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>
    
    <style>
        :root {
            /* Light Theme */
            --primary-color: #2980b9;
            --primary-hover: #1a5276;
            --link-color: #c0392b;
            --text-color: #333;
            --text-light: #666;
            --text-muted: #999;
            --bg-color: #fff;
            --bg-secondary: #f8f9fa;
            --bg-code: #f5f5f5;
            --border-color: #e5e7eb;
            --shadow: 0 1px 3px rgba(0,0,0,0.1);
            --shadow-lg: 0 4px 15px rgba(0,0,0,0.1);
        }

        [data-theme="dark"] {
            --primary-color: #5dade2;
            --primary-hover: #85c1e9;
            --link-color: #e74c3c;
            --text-color: #e5e7eb;
            --text-light: #9ca3af;
            --text-muted: #6b7280;
            --bg-color: #1a1a2e;
            --bg-secondary: #16213e;
            --bg-code: #0f0f23;
            --border-color: #374151;
            --shadow: 0 1px 3px rgba(0,0,0,0.3);
            --shadow-lg: 0 4px 15px rgba(0,0,0,0.4);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            scroll-behavior: smooth;
        }

        body {
            font-family: 'Inter', 'Noto Sans SC', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            font-size: 16px;
            line-height: 1.8;
            color: var(--text-color);
            background: var(--bg-color);
            transition: background-color 0.3s, color 0.3s;
        }

        a {
            color: var(--primary-color);
            text-decoration: none;
            transition: color 0.2s;
        }

        a:hover {
            color: var(--primary-hover);
            text-decoration: underline;
        }

        /* Layout */
        .page-wrapper {
            display: flex;
            max-width: 1400px;
            margin: 0 auto;
            padding: 2rem;
            gap: 3rem;
        }

        /* Sidebar TOC */
        .toc-sidebar {
            width: 260px;
            flex-shrink: 0;
            position: sticky;
            top: 2rem;
            height: fit-content;
            max-height: calc(100vh - 4rem);
            overflow-y: auto;
        }

        .toc-container {
            background: var(--bg-secondary);
            border-radius: 12px;
            padding: 1.5rem;
            border: 1px solid var(--border-color);
        }

        .toc-container h3 {
            font-size: 0.85rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-muted);
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .toc-container ul {
            list-style: none;
        }

        .toc-container li {
            margin-bottom: 0.5rem;
        }

        .toc-container a {
            font-size: 0.9rem;
            color: var(--text-light);
            display: block;
            padding: 0.25rem 0;
            border-left: 2px solid transparent;
            padding-left: 0.75rem;
            transition: all 0.2s;
        }

        .toc-container a:hover,
        .toc-container a.active {
            color: var(--primary-color);
            border-left-color: var(--primary-color);
            text-decoration: none;
        }

        .toc-container ul ul {
            margin-left: 1rem;
        }

        /* Main Content */
        .main-content {
            flex: 1;
            min-width: 0;
            max-width: 800px;
        }

        /* Header */
        .post-header {
            margin-bottom: 2rem;
            padding-bottom: 1.5rem;
            border-bottom: 1px solid var(--border-color);
        }

        .back-link {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.9rem;
            color: var(--text-light);
            margin-bottom: 1.5rem;
        }

        .back-link:hover {
            color: var(--primary-color);
            text-decoration: none;
        }

        .post-header h1 {
            font-size: 2.25rem;
            font-weight: 700;
            line-height: 1.3;
            margin-bottom: 1rem;
            color: var(--text-color);
        }

        .post-meta {
            display: flex;
            flex-wrap: wrap;
            gap: 1.5rem;
            font-size: 0.9rem;
            color: var(--text-light);
        }

        .post-meta span {
            display: flex;
            align-items: center;
            gap: 0.4rem;
        }

        .post-meta i {
            color: var(--text-muted);
        }

        .tags {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-top: 1rem;
        }

        .tag {
            display: inline-block;
            font-size: 0.8rem;
            background: var(--bg-secondary);
            color: var(--text-light);
            padding: 0.25rem 0.75rem;
            border-radius: 20px;
            border: 1px solid var(--border-color);
            transition: all 0.2s;
        }

        .tag:hover {
            background: var(--primary-color);
            color: white;
            border-color: var(--primary-color);
        }

        /* Article Content */
        .post-content {
            font-size: 1rem;
            line-height: 1.9;
        }

        .post-content h1,
        .post-content h2,
        .post-content h3,
        .post-content h4,
        .post-content h5,
        .post-content h6 {
            margin-top: 2rem;
            margin-bottom: 1rem;
            font-weight: 600;
            line-height: 1.4;
            color: var(--text-color);
        }

        .post-content h1 { font-size: 1.875rem; }
        .post-content h2 { 
            font-size: 1.5rem; 
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--border-color);
        }
        .post-content h3 { font-size: 1.25rem; }
        .post-content h4 { font-size: 1.125rem; }

        .post-content p {
            margin-bottom: 1.25rem;
        }

        .post-content ul,
        .post-content ol {
            margin: 1.25rem 0;
            padding-left: 1.5rem;
        }

        .post-content li {
            margin-bottom: 0.5rem;
        }

        .post-content blockquote {
            margin: 1.5rem 0;
            padding: 1rem 1.5rem;
            background: var(--bg-secondary);
            border-left: 4px solid var(--primary-color);
            border-radius: 0 8px 8px 0;
            color: var(--text-light);
            font-style: italic;
        }

        .post-content blockquote p:last-child {
            margin-bottom: 0;
        }

        /* Code */
        .post-content code {
            font-family: 'JetBrains Mono', 'Fira Code', Consolas, monospace;
            font-size: 0.9em;
            background: var(--bg-code);
            padding: 0.2em 0.4em;
            border-radius: 4px;
            color: var(--link-color);
        }

        .post-content pre {
            margin: 1.5rem 0;
            padding: 1.25rem;
            background: var(--bg-code);
            border-radius: 10px;
            overflow-x: auto;
            border: 1px solid var(--border-color);
        }

        .post-content pre code {
            background: none;
            padding: 0;
            color: inherit;
            font-size: 0.875rem;
            line-height: 1.6;
        }

        /* Images */
        .post-content img {
            max-width: 100%;
            height: auto;
            border-radius: 10px;
            margin: 1.5rem 0;
            box-shadow: var(--shadow-lg);
        }

        /* Tables */
        .post-content table {
            width: 100%;
            margin: 1.5rem 0;
            border-collapse: collapse;
            font-size: 0.95rem;
        }

        .post-content th,
        .post-content td {
            padding: 0.75rem 1rem;
            border: 1px solid var(--border-color);
            text-align: left;
        }

        .post-content th {
            background: var(--bg-secondary);
            font-weight: 600;
        }

        .post-content tr:nth-child(even) {
            background: var(--bg-secondary);
        }

        /* Math */
        .math-display {
            margin: 1.5rem 0;
            overflow-x: auto;
            padding: 1rem;
            background: var(--bg-secondary);
            border-radius: 8px;
        }

        /* Anchor links */
        .anchor-link {
            opacity: 0;
            margin-left: 0.5rem;
            color: var(--text-muted);
            font-weight: 400;
            transition: opacity 0.2s;
        }

        .post-content h2:hover .anchor-link,
        .post-content h3:hover .anchor-link,
        .post-content h4:hover .anchor-link {
            opacity: 1;
        }

        /* Theme Toggle */
        .theme-toggle {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: var(--primary-color);
            color: white;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.25rem;
            box-shadow: var(--shadow-lg);
            transition: transform 0.2s, background 0.2s;
            z-index: 1000;
        }

        .theme-toggle:hover {
            transform: scale(1.1);
            background: var(--primary-hover);
        }

        /* Comments Section */
        .comments-section {
            margin-top: 3rem;
            padding-top: 2rem;
            border-top: 1px solid var(--border-color);
        }

        .comments-section h3 {
            font-size: 1.25rem;
            margin-bottom: 1.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        /* Footer */
        .post-footer {
            margin-top: 3rem;
            padding-top: 1.5rem;
            border-top: 1px solid var(--border-color);
            text-align: center;
            font-size: 0.9rem;
            color: var(--text-muted);
        }

        /* Responsive */
        @media (max-width: 1024px) {
            .toc-sidebar {
                display: none;
            }
            
            .page-wrapper {
                padding: 1.5rem;
            }
        }

        @media (max-width: 768px) {
            .post-header h1 {
                font-size: 1.75rem;
            }
            
            .post-meta {
                flex-direction: column;
                gap: 0.5rem;
            }
            
            .theme-toggle {
                bottom: 1rem;
                right: 1rem;
                width: 44px;
                height: 44px;
            }
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-secondary);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--text-muted);
        }
    </style>
</head>
<body>
    <div class="page-wrapper">
        <!-- TOC Sidebar -->
        <aside class="toc-sidebar">
            <div class="toc-container">
                <h3><i class="fas fa-list"></i> 目录</h3>
                <div class="toc">
<ul>
<li><a href="#kimi全文翻译-arrow_down">Kimi全文翻译 :arrow_down:</a></li>
<li><a href="#0-摘要">0. 摘要</a></li>
<li><a href="#1-引言">1 引言</a></li>
<li><a href="#2-背景">2 背景</a><ul>
<li><a href="#21-迁移学习和监督预训练">2.1 迁移学习和监督预训练</a></li>
<li><a href="#22-自监督学习和自监督预训练">2.2 自监督学习和自监督预训练</a></li>
</ul>
</li>
<li><a href="#3-transformer-和代表性的预训练模型-ptms">3 Transformer 和代表性的预训练模型 (PTMs)</a><ul>
<li><a href="#31-transformer">3.1 Transformer</a></li>
</ul>
</li>
</ul>
</div>

            </div>
        </aside>

        <!-- Main Content -->
        <main class="main-content">
            <article>
                <header class="post-header">
                    <a href="../../../index.html" class="back-link">
                        <i class="fas fa-arrow-left"></i> 返回博客列表
                    </a>
                    <h1>Untitled</h1>
                    <div class="post-meta">
                        <span><i class="fas fa-calendar-alt"></i> 2026-01-28</span>
                        <span><i class="fas fa-folder"></i> AINotes/08.PTM</span>
                        <span><i class="fas fa-user"></i> Hongwei Zhao</span>
                    </div>
                    <div class="tags">
                        
                    </div>
                </header>

                <div class="post-content">
                    <p>利用深度学习自动学习特征已经逐步取代了人工构建特征和统计方法。但其中一个关键问题是需要大量的数据，否则会因为参数过多过拟合。但是这个成本非常高昂，因此长久以来，我们都在研究一个关键问题：如何在有限数据下训练高效的深度学习模型？</p>
<p>一个重要的里程碑是转移学习——受人类启发，不是从大量数据中从头开始学习，而是利用少量样例来解决问题。转移学习有两个阶段：预训练+微调，微调阶段就是转移预训练阶段学到的知识到特定任务上。这一方法首先在计算机视觉（CV）领域取得成功，这是对预训练模型（PTMs）的第一波探索浪潮。</p>
<p>自然语言处理（NLP）领域采用了自监督学习进行预训练，其动机是利用文本内在关联作为监督信号取代人工标注。最初的探索聚焦在浅层预训练模型获取词的语义，比如 Word2Vec 和 Glove，但它们的局限是无法很好地表征一词多义。自然而然地，就想到了利用 RNN 来提供上下文表征，但彼时的模型表现仍受限于模型大小和深度。2018 年 GPT 和 BERT 横空出世，将 NLP 的 PTM 带入了新时代。</p>
<p>这些新模型都很大，大量的参数可以从文本中捕捉到一词多义、词法、句法结构、现实知识等信息，通过对模型微调，只要很少的样例就可以在下游任务上取得惊人的表现。到了现在，在大规模 PTMs 上对特定任务进行微调已经成为业界共识。尽管已经取得了很大的成功，但还有一些基本的问题：我们仍然不清楚隐藏在大量模型参数中的本质，训练这些庞然大物的巨大计算成本也阻碍了我们进一步探索。PTMs 已经将 AI 研究者推到了一个十字路口。</p>
<p><a href="https://blog.csdn.net/Datawhale/article/details/118383045">万字解读：预训练模型最新综述！</a></p>
<h2 id="kimi全文翻译-arrow_down">Kimi全文翻译 :arrow_down:<a class="anchor-link" href="#kimi全文翻译-arrow_down" title="Permanent link">&para;</a></h2>
<h2 id="0-摘要">0. 摘要<a class="anchor-link" href="#0-摘要" title="Permanent link">&para;</a></h2>
<p>大规模预训练模型（PTMs），如BERT和GPT，近年来取得了巨大成功，成为人工智能领域的一个里程碑。由于复杂的预训练目标和庞大的模型参数，大规模PTMs能够有效地从大量标记和未标记数据中捕获知识。通过将知识存储在庞大的参数中，并在特定任务上进行微调，隐含在庞大参数中的丰富知识可以惠及各种下游任务，这一点已经通过实验验证和实证分析得到了广泛证明。现在AI社区的共识是采用PTMs作为下游任务的主干，而不是从头开始学习模型。在本文中，我们深入研究了预训练的历史，特别是它与迁移学习和自监督学习的特别关系，以揭示PTMs在AI发展谱中的关键位置。此外，我们全面回顾了PTMs的最新突破。这些突破是由计算能力的激增和数据可用性的增加推动的，朝着四个重要方向发展：设计有效的架构、利用丰富的上下文、提高计算效率以及进行解释和理论分析。最后，我们讨论了一系列PTMs的开放问题和研究方向，并希望我们的观点能够激发和推动PTMs未来的研究。</p>
<h2 id="1-引言">1 引言<a class="anchor-link" href="#1-引言" title="Permanent link">&para;</a></h2>
<p>深度神经网络，例如卷积神经网络（CNNs）（Krizhevsky et al., 2012; Kim, 2014; Kalchbrenner et al., 2014; He et al., 2016）、循环神经网络（RNNs）（Sutskever et al., 2014; Donahue et al., 2015; Liu et al., 2016; Wu et al., 2016）、图神经网络（GNNs）（Kipf and Welling, 2016; Veličković et al., 2018; Schlichtkrull et al., 2018）和注意力神经网络（Jaderberg et al., 2015; Wang et al., 2017），在过去几年中已被广泛应用于各种人工智能任务。与以往主要依赖手工特征提取和统计方法的非神经模型不同，神经模型可以从数据中自动学习低维连续向量（即分布式表示）作为任务特定特征，从而避免了复杂的特征工程。尽管深度神经网络取得了成功，但许多研究发现它们面临的关键挑战之一是数据需求大。由于深度神经网络通常有大量参数，因此它们容易过拟合，并且在没有足够训练数据的情况下泛化能力较差（Belkin et al., 2019; Xu et al., 2021）。</p>
<p>鉴于此问题，在深度神经网络发展的同时，大量努力已投入到为AI任务手动构建高质量数据集（Deng et al., 2009; Lin et al., 2014; Bojar et al., 2014），使得学习针对特定任务的有效神经模型成为可能，这些模型优于传统的非神经模型。然而，手动注释大规模数据是昂贵且耗时的。例如，利用众包对图像进行分割的成本约为每张图像6.4美元（Liu et al., 2020b）。一些需要专家注释的复杂任务可能需要更高的成本来构建它们的数据集。像视觉识别（Deng et al., 2009）和机器翻译（Bojar et al., 2014）这样的任务拥有包含数百万样本的数据集，但不可能为所有AI任务构建如此大规模的数据集。更一般地说，特定AI任务的数据集通常大小有限。因此，直到现在，一个关键的研究问题是如何使用有限的人工注释数据来训练针对特定任务的有效深度神经模型。</p>
<p>为了解决这一问题，一个重要的里程碑是迁移学习（transfer learning）的引入（Thrun and Pratt, 1998; Pan and Yang, 2009）。与从头开始用大量数据训练模型不同，人类可以通过很少的样本学习解决新问题。这种惊人的学习过程受到人类利用先前学到的知识处理新问题的启发。受此启发，迁移学习形式化了一个两阶段学习框架：一个预训练阶段，从一个或多个源任务中捕获知识，以及一个微调阶段，将捕获的知识转移到目标任务。由于在预训练阶段获得的丰富知识，微调阶段可以使模型在有限样本的情况下很好地处理目标任务。</p>
<p>迁移学习为缓解数据需求挑战提供了一种可行的方法，并且很快就被广泛应用于计算机视觉（CV）领域。一系列的CNN（Krizhevsky et al., 2012; Simonyan and Zisserman, 2015; Szegedy et al., 2015; He et al., 2016）在人类注释的视觉识别数据集ImageNet（Deng et al., 2009）上进行预训练。得益于ImageNet中强大的视觉知识，用少量特定任务数据对这些预训练的CNN进行微调可以在下游任务上表现良好。这引发了深度学习时代探索预训练模型（PTMs）的第一次浪潮。在这次浪潮中，PTMs被用于几乎所有的CV任务，如图像分类（He et al., 2016）、目标检测（Sermanet et al., 2014; Ren et al., 2016）、图像分割（Long et al., 2015）和图像字幕（Vinyals et al., 2015）。</p>
<p>自然语言处理（NLP）社区也意识到了PTMs的潜力，并开始为NLP任务开发PTMs（Qiu et al., 2020）。为了充分利用大规模未标记语料库为NLP任务提供通用的语言知识，NLP社区采用自监督学习（self-supervised learning）（Liu et al., 2020b）来开发PTMs。自监督学习的动力在于利用文本中的内在相关性作为监督信号，而不是人类监督。例如，给定句子"Beijing is the capital of China"，我们遮蔽句子中的最后一个词，并要求模型用词"China"预测遮蔽位置。通过自监督学习，可以利用大量的未标记文本数据捕获通用的语言知识，而无需繁重的工作量。这种自监督设置本质上遵循了著名的语言模型学习（Bengio et al., 2003）。长期以来，消失或爆炸梯度（vanishing or exploding gradients）（Bengio et al., 1994）问题是使用深度神经网络进行NLP任务的痛点。因此，当CV社区推进深度PTMs的研究时，NLP社区的早期探索集中在预训练浅层网络上，以捕获单词的语义，如Word2Vec（Mikolov et al., 2013b,a,c）和GloVe（Pennington et al., 2014）。尽管这些预训练的词嵌入在各种NLP任务中扮演了重要角色，但它们仍然面临着一个主要的限制，即无法表示不同上下文中的多义词，因为每个词仅由一个密集向量表示。NLP中一个著名的例子是，词“bank”在句子“open a bank account”和“on a bank of the river”中具有完全不同的含义。这激发了预训练RNNs以提供上下文化词嵌入（Melamud et al., 2016; Peters et al., 2018; Howard and Ruder, 2018），然而这些模型的性能仍然受到其模型大小和深度的限制。随着深度神经网络在NLP社区的发展，Transformers（Vaswani et al., 2017）的引入使得为NLP任务训练非常深的神经模型成为可能。以Transformers为架构，以语言模型学习为目标，深度PTMs GPT（Radford and Narasimhan, 2018）和BERT（Devlin et al., 2019）在2018年被提出用于NLP任务。从GPT和BERT中，我们可以发现当PTMs的大小变大时，具有数亿参数的大型PTMs能够捕获多义词消歧、词汇和句法结构以及文本中的事实知识。通过用相当多的样本微调大型PTMs，PTMs的丰富语言知识为下游NLP任务带来了出色的性能。如图1(a)和图1(b)所示，大型PTMs在过去几年中在语言理解和语言生成任务上表现良好，甚至取得了比人类更好的结果。如图2(a)所示，NLP社区的所有这些努力和成就使大型PTMs成为AI研究的焦点，继上一波PTMs在CV社区取得巨大进步之后的浪潮。到目前为止，各种努力已投入到探索大型PTMs，无论是NLP（Radford et al., 2019; Liu et al., 2020d; Raffel et al., 2020; Lewis et al., 2020a）还是CV（Lu et al., 2019; Li et al., 2019; Tan and Bansal, 2019）。而不是从头开始学习模型，对特定AI任务进行微调已成为共识（Qiu et al., 2020）。如图2(b)所示，随着分布式计算设备和策略的广泛使用，计算能力的提高，我们可以进一步将PTMs的参数规模从百万级推进到十亿级（Brown et al., 2020; Lepikhin et al., 2021; Zeng et al., 2021; Zhang et al., 2020c, 2021a）甚至万亿级（Fedus et al., 2021）。GPT-3的出现（Brown et al., 2020），拥有数千亿参数，使我们得以窥见在庞大模型参数中分布的潜在能力，特别是像人类一样的少次学习的巨大能力（如图3所示）。</p>
<p>现有的大规模PTMs已经提高了模型在各种AI任务上的性能，甚至颠覆了我们对深度学习模型性能的当前认知。然而，关于PTMs的几个基本问题仍然存在：我们仍然不清楚隐藏在庞大模型参数中的自然属性是什么，训练这些庞然大物的巨大计算成本也阻碍了我们进一步的探索。在这一刻，这些PTMs将我们的AI研究者推向了一个十字路口，有许多开放的方向可以选择。“罗马不是一天建成的”——PTMs在取得最新成功之前也经历了漫长的发展。为此，我们试图追溯PTMs的发展历史，并在AI谱系中确定它们的位置，这可以让我们清楚地理解PTMs的核心研究问题。然后，我们介绍了各种最新的PTMs的细节，沿着目前正推进的四个重要方向，包括设计有效的架构、利用丰富的上下文、提高计算效率以及进行解释和理论分析。通过将PTMs的当前发展融入历史谱系的背景中，我们讨论了几个开放问题，并为PTMs的未来发展方向做出了有希望的结论。我们希望本文的努力能够推进PTMs的进一步发展。在接下来的部分中，我们将在第2节和第3节中介绍预训练的背景，在第4节中介绍PTMs的模型架构，在第5节中使用多源异构数据进行PTMs，在第6节中优化PTMs的计算效率，并在第7节中对PTMs进行理论分析。最后，我们将简要讨论一系列开放问题，并展望未来更好的PTMs的有希望的方向。</p>
<h2 id="2-背景">2 背景<a class="anchor-link" href="#2-背景" title="Permanent link">&para;</a></h2>
<p>尽管有效的预训练模型（PTMs）最近受到了研究者的关注，但预训练并不是一个新颖的机器学习工具。事实上，预训练已经发展了数十年，作为一种典型的机器学习范式。在这一部分，我们介绍了预训练在AI谱系中的发展，从早期的监督预训练到现在的自监督预训练，这可以让我们简要了解PTMs的背景。</p>
<h3 id="21-迁移学习和监督预训练">2.1 迁移学习和监督预训练<a class="anchor-link" href="#21-迁移学习和监督预训练" title="Permanent link">&para;</a></h3>
<p>预训练的早期努力主要涉及迁移学习（Thrun和Pratt, 1998）。迁移学习的研究很大程度上受到这样一个事实的启发：人们可以依靠之前学到的知识来解决新问题，并且甚至能够取得更好的结果。更正式地说，迁移学习的目标是从多个源任务中捕获重要知识，然后将这些知识应用到目标任务上。</p>
<p>在迁移学习中，源任务和目标任务可能具有完全不同的数据领域和任务设置，但处理这些任务所需的知识是一致的（Pan和Yang, 2009）。因此，选择一个可行的方法将知识从源任务转移到目标任务是非常重要的。为此，提出了各种预训练方法作为源任务和目标任务之间的桥梁。具体来说，这些方法首先在多个源任务的数据上预训练模型以预编码知识，然后将预编码的知识转移到训练模型的目标任务上。通常，在迁移学习中广泛探索了两种预训练方法：特征转移和参数转移。特征转移方法预训练有效的特征表示以预编码跨领域和任务的知识（Johnson和Zhang, 2005; Evgeniou和Pontil, 2007; Dai等人，2007; Raina等人，2007）。通过将这些预训练的表示注入到目标任务中，可以显著提高目标任务的模型性能。参数转移方法遵循一个直观的假设，即源任务和目标任务可以共享模型参数或超参数的先验分布。因此，这些方法将知识预编码到共享的模型参数中（Lawrence和Platt, 2004; Evgeniou和Pontil, 2004; Williams等人，2007; Gao等人，2008），然后通过使用目标任务的数据微调预训练的参数来转移知识。</p>
<p>在某种程度上，这两种表示转移和参数转移为PTMs奠定了基础。广泛用作NLP任务输入的词嵌入是建立在特征转移框架上的。受参数转移的启发，预训练的CNN被应用于大多数最先进的CV模型的骨干。一些最近的知名PTMs也基于表示转移和参数转移，例如，ELMo（Peters等人，2018）和BERT分别应用了表示转移和参数转移。</p>
<p>自从AlexNet（Krizhevsky等人，2012）以来，一系列的深度神经网络已经被开发用于AI任务。与传统的机器学习模型相比，深度神经模型有更多的参数，并且显示出更好的拟合复杂数据的能力。因此，从AlexNet到后来的VGG（Simonyan和Zisserman, 2015）和GoogleNet（Szegedy等人，2015），这些神经网络的架构变得越来越深，它们的性能相应地也越来越好。尽管网络深度很重要，但训练一个深度网络并不容易，因为堆叠更多的网络层不可避免地会带来消失或爆炸梯度的问题（Bengio等人，1994）。除了梯度问题外，模型性能可能很快就会遇到天花板，然后随着网络深度的不断增加而迅速下降。通过将归一化添加到参数初始化（LeCun等人，2012; Saxe等人，2013）和隐藏状态（Ioffe和Szegedy, 2015），并引入具有残差层的快捷连接，ResNet（He等人，2016）有效地解决了这些问题。正如我们之前提到的，深度神经网络需要大量的数据进行训练。为了提供足够的数据来训练深度模型，一些大规模的监督数据集也被构建了（Russakovsky等人，2015; Lin等人，2014; Krishna等人，2017; Chen等人，2015; Cordts等人，2016），最具代表性的是ImageNet。ImageNet包含数百万张图像，分为数千个类别，代表了各种日常对象。基于有效的模型ResNet、信息丰富的数据集ImageNet以及成熟的知识转移方法，出现了一波在标记数据上预训练模型的浪潮。CV社区从这一波中受益匪浅。通过应用在ImageNet上预训练的ResNet作为骨干，各种CV任务迅速推进，如图像分类（He等人，2016; Lee等人，2015）、目标检测（Ren等人，2016; Sermanet等人，2014; Gidaris和Komodakis, 2015）、图像分割（Long等人，2015; Zheng等人，2015）、图像字幕（Vinyals等人，2015; Johnson等人，2016）、视觉问答（Antol等人，2015; Gao等人，2015; Xiong等人，2016）等。使用像ResNet50这样的PTMs已经证明是获得大多数CV任务上高度准确结果的关键步骤。</p>
<p>受到PTMs在CV任务中成功的启发，一些NLP研究者也探索了监督预训练，最具代表性的工作是CoVE（McCann等人，2017）。CoVE采用机器翻译作为其预训练目标。预训练后，源语言的编码器可以作为下游NLP任务的强大骨干。</p>
<h3 id="22-自监督学习和自监督预训练">2.2 自监督学习和自监督预训练<a class="anchor-link" href="#22-自监督学习和自监督预训练" title="Permanent link">&para;</a></h3>
<p>如图4所示，迁移学习可以分为四个子设置：归纳迁移学习（Lawrence和Platt, 2004; Mihalkova等人，2007; Evgeniou和Pontil, 2007）、演绎迁移学习（Shimodaira, 2000; Zadrozny, 2004; Daume III和Marcu, 2006）、自我教学学习（Raina等人，2007; Dai等人，2008）和无监督迁移学习（Wang等人，2008）。在这四种设置中，归纳和演绎设置是研究的核心，因为这两种设置旨在将知识从监督源任务迁移到目标任务。尽管监督学习一直是机器学习研究的核心问题之一，但未标记数据的规模远大于手动标记的数据。最近，越来越多的研究者注意到了大量未标记数据的重要性，并致力于从未标记数据中提取信息。</p>
<p>自监督学习被提出来利用输入数据本身作为监督，从大规模未标记数据中提取知识。</p>
<p>自监督学习和无监督学习在设置上有许多相似之处。在某种程度上，自监督学习可以被视为无监督学习的一个分支，因为它们都使用未标记数据。然而，无监督学习主要关注于检测数据模式（例如聚类、社区发现和异常检测），而自监督学习仍然处于监督设置的范式中（例如分类和生成）（Liu等人，2020b）。</p>
<p>自监督学习的发展使得在大规模无监督数据上进行预训练成为可能。与在深度学习时代作为计算机视觉基石的监督预训练相比，自监督预训练允许在自然语言处理领域取得巨大进步。尽管一些监督预训练方法如CoVE在NLP任务上取得了有希望的结果，但考虑到注释文本数据比注释图像要复杂得多，几乎不可能为NLP任务注释像ImageNet那样大的数据集。因此，应用自监督学习来利用未标记数据成为预训练NLP任务模型的最佳选择。近期在PTMs方面的惊人突破主要是针对NLP任务的，更具体地说是预训练语言模型。</p>
<p>早期的NLP任务PTMs以众所周知的词嵌入的形式存在（Collobert和Weston, 2008; Mikolov等人，2013b; Pennington等人，2014），它们应用自监督方法将单词转换为分布式表示。由于这些预训练的词表示捕获了文本中的句法和语义信息，它们通常用作NLP模型的输入嵌入和初始化参数，并比随机初始化参数提供了显著的改进（Turian等人，2010）。由于这些词级模型经常面临词义多义性的问题，Peters等人（2018）进一步采用序列级神经模型来捕获不同语言环境中的复杂单词特征，并生成上下文感知的词嵌入。使用词嵌入作为神经模型的输入已成为NLP任务的常见模式。</p>
<p>在Vaswani等人（2017）提出Transformers处理序列数据后，NLP任务的PTMs进入了一个新的阶段，因为与常规的CNN和RNN相比，现在可以训练更深的语言模型。与那些用作输入特征的词级PTMs不同，基于Transformer的PTMs如GPT和BERT可以作为各种特定任务的模型骨干。在大规模文本语料库上预训练这些基于Transformer的PTMs后，PTMs的架构和参数可以作为特定NLP任务的起点，即只需微调PTMs的参数即可实现竞争性能。到目前为止，这些基于Transformer的PTMs在几乎所有NLP任务上都取得了最先进的结果。受到自监督学习和Transformers在NLP中的成功的启发，一些研究者还探索了自监督学习（Wu等人，2018; Chen等人，2020d; Chen和He, 2020; He等人，2020）和Transformers（Carion等人，2020; Liu等人，2021c）用于CV任务。这些初步努力已经显示出自监督学习和Transformers可以胜过传统的监督CNN。此外，基于Transformer的多模态PTMs（Lu等人，2019; Li等人，2019; Tan和Bansal, 2019）也被提出并显示出有希望的结果。在上一波监督预训练之后，自监督预训练已成为当前AI研究的焦点。回顾AI谱系中的预训练，不难发现预训练已经发展了数十年，重点是如何为各种下游任务获取通用知识。接下来，我们将全面介绍这一波自监督预训练中PTMs的最新突破。考虑到几乎所有最新的PTMs都与预训练语言模型有关，“PTMs”在后续部分中指的是预训练语言模型或多模态模型。对于那些基于监督预训练的传统PTMs，我们参考He等人（2019）和Zoph等人（2020）的论文。</p>
<h2 id="3-transformer-和代表性的预训练模型-ptms">3 Transformer 和代表性的预训练模型 (PTMs)<a class="anchor-link" href="#3-transformer-和代表性的预训练模型-ptms" title="Permanent link">&para;</a></h2>
<p>正如我们之前提到的，近期预训练模型（PTMs）成功的关键因素是自监督学习与 Transformer 的结合。因此，本节首先介绍主要的基础神经网络架构——Transformer。然后，我们将介绍两个基于 Transformer 的标志性预训练模型，GPT 和 BERT。这两个模型分别使用自回归语言建模和自编码语言建模作为预训练目标。所有后续的预训练模型都是这两个模型的变体。本节的最后部分将简要回顾 GPT 和 BERT 之后的典型变体，以揭示预训练模型的最新发展。</p>
<h3 id="31-transformer">3.1 Transformer<a class="anchor-link" href="#31-transformer" title="Permanent link">&para;</a></h3>
<p>在 Transformer 之前，RNN 一直是处理序列数据的典型工具，特别是处理自然语言。由于 RNN 具有序列特性，它们按顺序在每个时间步骤读取一个词。对于每个词，RNN 参考其之前所有词的隐藏状态来处理它。这种机制被认为难以利用高性能计算设备的并行能力，例如 GPU 和 TPU。如图 5 所示，Transformer 是一种非循环的序列到序列（seq2seq）架构，由编码器和解码器组成。Transformer 的编码器和解码器都由多个相同的块堆叠而成。每个编码器块由一个多头自注意力层和一个逐位置前馈层组成。与编码器块相比，每个解码器块还有一个额外的交叉注意力层，因为解码器需要考虑编码器的输出作为生成的上下文。在神经层之间，使用残差连接（He 等人，2016）和层归一化（Ba 等人，2016），使得可以训练深层的 Transformer。</p>
<p><strong>注意力层</strong>。自注意力层是 Transformer 成功的关键。形式上，给定一个查询集 Q = {q1, ..., qn}，一个键集 K = {k1, ..., km}，一个值集 V = {v1, ..., vm}，每个查询向量 qi ∈ R^dk，每个键向量 ki ∈ R^dk，每个值向量 vi ∈ R^dv，缩放点积注意力定义为：<br />
<div class="math-display"><br />
    {h_1, ..., h_n} = \text{ATT}(Q, K, V),<br />
</div></p>
<p><div class="math-display"><br />
    h_i = \sum_{j=1}^{m} a_{ij} v_j,<br />
</div></p>
<p><div class="math-display"><br />
    a_{ij} = \frac{\exp(\text{ATT-Mask}(q_i \cdot k_j / \sqrt{dk}))}{\sum_{l=1}^{m} \exp(\text{ATT-Mask}(q_i \cdot k_l / \sqrt{dk}))}.<br />
</div><br />
直观地说，Q 是用于计算注意力的向量集，K 是用于计算注意力的向量集。作为点积乘法的结果，我们可以得到权重 aij，表示查询向量 qi 对键向量 kj 的注意力程度。最后，我们可以计算值向量的加权平均作为注意力层的最终结果。注意，掩码函数 ATT-Mask(·) 用于限制每个查询向量可以关注的键值对。如果我们不希望 qi 关注 kj，ATT-Mask(x) = -∞，否则 ATT-Mask(x) = x。通过将 Q、K、V 分别打包成矩阵表示 Q ∈ R^n×dk, K ∈ R^m×dk, V ∈ R^m×dv，注意力可以简化为：<br />
<div class="math-display"><br />
    H = \text{ATT}(Q, K, V) = A V,<br />
</div></p>
<p><div class="math-display"><br />
    A = \text{Softmax}(\text{ATT-Mask}(Q K^T / \sqrt{dk})),<br />
</div><br />
其中 Softmax(·) 以行方式应用，A ∈ R^n×m 是注意力矩阵，H ∈ R^n×dv 是结果。Transformer 不使用普通的缩放点积注意力，而是应用多头注意力层，定义如下：<br />
<div class="math-display"><br />
    H = \text{MH-ATT}(Q, K, V) = \text{Concat}(H_1, ..., H_h) W_O,<br />
</div></p>
<p><div class="math-display"><br />
    H_i = \text{ATT}(Q W_{Q_i}, K W_{K_i}, V W_{V_i}),<br />
</div><br />
其中 h 是头的数量。WQ_i, WK_i, WV_i 分别用于将输入 Q, K, V 投影到第 i 个头注意力的特征空间。在通过 Concat(·) 连接所有头的输出之后，多头注意力层应用 WO 将连接投影到最终输出空间。</p>
<p><strong>逐位置前馈层</strong>。除了注意力层，Transformer 的每个块还包含一个逐位置前馈层。给定一个打包的输入矩阵 X ∈ R^n×di，表示一组输入向量，di 是向量维度，逐位置前馈层定义为：<br />
<div class="math-display"><br />
    H = \text{FFN}(X) = \sigma(X W_1 + b_1) W_2 + b_2,<br />
</div><br />
其中σ(·) 是激活函数（通常是 ReLU 函数）。W1 ∈ R^di×df , b1 ∈ R^df , W2 ∈ R^df×do, b2 ∈ R^do 都是可学习的参数用于投影。H ∈ R^n×do 是前馈层的最终结果。经验上，di 设置为等于 do，df 设置为比 di 和 do 大得多。</p>
<p><strong>残差连接和归一化</strong>。正如我们之前提到的，Transformer 在各种神经层之间应用残差连接和层归一化，使得 Transformer 的架构可以变得很深。形式上，给定一个神经层 f(·)，残差连接和归一化层定义为：<br />
<div class="math-display"><br />
    H = \text{A\&amp;N}(X) = \text{LayerNorm}(f(X) + X),<br />
</div><br />
其中 LayerNorm(·) 表示层归一化操作。如图 5 所示，Transformer 中有三种多头注意力的变体：(1) 自注意力在编码器中使用，它使用前一层的输出作为 Q、K、V。在编码阶段，给定一个词，自注意力通过与输入序列中的所有词比较来计算其注意力分数。这样的注意力分数表明每个其他词应该在给定词的下一个表示中贡献多少。我们给出了图 6 的一个例子，其中自注意力准确地捕获了“Jack”和“he”之间的指代关系，生成了最高的注意力分数。(2) 掩码自注意力在解码器中使用，其注意力矩阵满足 Aij = 0, i &gt; j。这种注意力对自回归语言建模有利。在解码阶段，自注意力类似于编码，只不过它只从左到右解码一个表示，因为每个解码阶段的步骤只参考之前解码的结果，因此我们需要在自注意力中加入掩码函数。(3) 交叉注意力也在解码器中使用，它使用前一个解码器块的输出作为 Q，以及编码器的输出作为 K 和 V。这样的过程本质上是聚合整个输入序列的信息，并将应用于解码阶段生成的所有词。利用输入上下文对于某些 seq2seq 任务如机器翻译和文本摘要具有重要意义。</p>
<p>有关 Transformer 的更多细节，请参考其原始论文（Vaswani 等人，2017）和综述论文（Lin 等人，2021）。由于其显著的特性，Transformer 逐渐成为自然语言理解和生成的标准神经结构。此外，它还作为随后派生的 PTMs 的骨干神经结构。接下来，我们将介绍两个完全开启大规模自监督 PTMs 时代的里程碑，GPT 和 BERT。通常，GPT 擅长自然语言生成，而 BERT 更侧重于自然语言理解。</p>
                </div>

                <!-- Comments Section (Giscus) -->
                <section class="comments-section">
                    <h3><i class="fas fa-comments"></i> 评论</h3>
                    <script src="https://giscus.app/client.js"
                        data-repo="Geeks-Z/Geeks-Z.github.io"
                        data-repo-id=""
                        data-category="Announcements"
                        data-category-id=""
                        data-mapping="pathname"
                        data-strict="0"
                        data-reactions-enabled="1"
                        data-emit-metadata="0"
                        data-input-position="bottom"
                        data-theme="preferred_color_scheme"
                        data-lang="zh-CN"
                        crossorigin="anonymous"
                        async>
                    </script>
                </section>
            </article>

            <footer class="post-footer">
                <p>© 2025 Hongwei Zhao. Built with ❤️</p>
            </footer>
        </main>
    </div>

    <!-- Theme Toggle Button -->
    <button class="theme-toggle" id="themeToggle" aria-label="切换主题">
        <i class="fas fa-moon"></i>
    </button>

    <script>
        // Theme Toggle
        const themeToggle = document.getElementById('themeToggle');
        const html = document.documentElement;
        const icon = themeToggle.querySelector('i');
        const hljsDark = document.getElementById('hljs-theme-dark');
        const hljsLight = document.getElementById('hljs-theme-light');
        
        // Check saved theme or system preference
        const savedTheme = localStorage.getItem('theme');
        const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
        
        if (savedTheme === 'dark' || (!savedTheme && prefersDark)) {
            html.setAttribute('data-theme', 'dark');
            icon.className = 'fas fa-sun';
            hljsDark.disabled = false;
            hljsLight.disabled = true;
        }
        
        themeToggle.addEventListener('click', () => {
            const isDark = html.getAttribute('data-theme') === 'dark';
            if (isDark) {
                html.removeAttribute('data-theme');
                icon.className = 'fas fa-moon';
                localStorage.setItem('theme', 'light');
                hljsDark.disabled = true;
                hljsLight.disabled = false;
            } else {
                html.setAttribute('data-theme', 'dark');
                icon.className = 'fas fa-sun';
                localStorage.setItem('theme', 'dark');
                hljsDark.disabled = false;
                hljsLight.disabled = true;
            }
            
            // Update Giscus theme
            const giscusFrame = document.querySelector('iframe.giscus-frame');
            if (giscusFrame) {
                giscusFrame.contentWindow.postMessage({
                    giscus: {
                        setConfig: {
                            theme: isDark ? 'light' : 'dark'
                        }
                    }
                }, 'https://giscus.app');
            }
        });
        
        // Highlight.js
        document.addEventListener('DOMContentLoaded', () => {
            hljs.highlightAll();
        });
        
        // KaTeX auto-render
        document.addEventListener('DOMContentLoaded', () => {
            if (typeof renderMathInElement !== 'undefined') {
                renderMathInElement(document.body, {
                    delimiters: [
                        {left: '$$', right: '$$', display: true},
                        {left: '$', right: '$', display: false},
                        {left: '\\[', right: '\\]', display: true},
                        {left: '\\(', right: '\\)', display: false}
                    ],
                    throwOnError: false
                });
            }
        });
        
        // TOC active state
        const tocLinks = document.querySelectorAll('.toc-container a');
        const headings = document.querySelectorAll('.post-content h2, .post-content h3, .post-content h4');
        
        function updateTocActive() {
            let current = '';
            headings.forEach(heading => {
                const rect = heading.getBoundingClientRect();
                if (rect.top <= 100) {
                    current = heading.getAttribute('id');
                }
            });
            
            tocLinks.forEach(link => {
                link.classList.remove('active');
                if (link.getAttribute('href') === '#' + current) {
                    link.classList.add('active');
                }
            });
        }
        
        window.addEventListener('scroll', updateTocActive);
        updateTocActive();
    </script>
</body>
</html>
