<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Untitled</title>
    <meta name="description" content="Untitled - Hongwei Zhao's Blog">
    <meta name="author" content="Hongwei Zhao">
    
    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Noto+Sans+SC:wght@300;400;500;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    
    <!-- Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <!-- Code Highlighting -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css" id="hljs-theme-dark">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css" id="hljs-theme-light" disabled>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    
    <!-- KaTeX for Math -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>
    
    <style>
        :root {
            /* Light Theme - 明亮清新配色 */
            --primary-color: #4A90D9;
            --primary-hover: #3678C2;
            --link-color: #E86B5F;
            --text-color: #2D2D2D;
            --text-light: #5A5A5A;
            --text-muted: #8A8A8A;
            --bg-color: #FFFFFF;
            --bg-secondary: #F5F7FA;
            --bg-code: #F8F9FC;
            --border-color: #E8ECF0;
            --shadow: 0 2px 8px rgba(0,0,0,0.06);
            --shadow-lg: 0 8px 24px rgba(0,0,0,0.08);
        }

        [data-theme="dark"] {
            --primary-color: #5dade2;
            --primary-hover: #85c1e9;
            --link-color: #e74c3c;
            --text-color: #e5e7eb;
            --text-light: #9ca3af;
            --text-muted: #6b7280;
            --bg-color: #1a1a2e;
            --bg-secondary: #16213e;
            --bg-code: #0f0f23;
            --border-color: #374151;
            --shadow: 0 1px 3px rgba(0,0,0,0.3);
            --shadow-lg: 0 4px 15px rgba(0,0,0,0.4);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            scroll-behavior: smooth;
        }

        body {
            font-family: 'Inter', 'Noto Sans SC', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            font-size: 16px;
            line-height: 1.8;
            color: var(--text-color);
            background: var(--bg-color);
            transition: background-color 0.3s, color 0.3s;
        }

        a {
            color: var(--primary-color);
            text-decoration: none;
            transition: color 0.2s;
        }

        a:hover {
            color: var(--primary-hover);
            text-decoration: underline;
        }

        /* Layout */
        .page-wrapper {
            display: flex;
            max-width: 1400px;
            margin: 0 auto;
            padding: 2rem;
            gap: 3rem;
        }

        /* Sidebar TOC */
        .toc-sidebar {
            width: 260px;
            flex-shrink: 0;
            position: sticky;
            top: 2rem;
            height: fit-content;
            max-height: calc(100vh - 4rem);
            overflow-y: auto;
        }

        .toc-container {
            background: var(--bg-secondary);
            border-radius: 12px;
            padding: 1.5rem;
            border: 1px solid var(--border-color);
        }

        .toc-container h3 {
            font-size: 0.85rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-muted);
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .toc-container ul {
            list-style: none;
        }

        .toc-container li {
            margin-bottom: 0.5rem;
        }

        .toc-container a {
            font-size: 0.9rem;
            color: var(--text-light);
            display: block;
            padding: 0.25rem 0;
            border-left: 2px solid transparent;
            padding-left: 0.75rem;
            transition: all 0.2s;
        }

        .toc-container a:hover,
        .toc-container a.active {
            color: var(--primary-color);
            border-left-color: var(--primary-color);
            text-decoration: none;
        }

        .toc-container ul ul {
            margin-left: 1rem;
        }

        /* Main Content */
        .main-content {
            flex: 1;
            min-width: 0;
            max-width: 800px;
        }

        /* Header */
        .post-header {
            margin-bottom: 2rem;
            padding-bottom: 1.5rem;
            border-bottom: 1px solid var(--border-color);
        }

        .back-link {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.9rem;
            color: var(--text-light);
            margin-bottom: 1.5rem;
        }

        .back-link:hover {
            color: var(--primary-color);
            text-decoration: none;
        }

        .post-header h1 {
            font-size: 2.25rem;
            font-weight: 700;
            line-height: 1.3;
            margin-bottom: 1rem;
            color: var(--text-color);
        }

        .post-meta {
            display: flex;
            flex-wrap: wrap;
            gap: 1.5rem;
            font-size: 0.9rem;
            color: var(--text-light);
        }

        .post-meta span {
            display: flex;
            align-items: center;
            gap: 0.4rem;
        }

        .post-meta i {
            color: var(--text-muted);
        }

        .tags {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-top: 1rem;
        }

        .tag {
            display: inline-block;
            font-size: 0.8rem;
            background: var(--bg-secondary);
            color: var(--text-light);
            padding: 0.25rem 0.75rem;
            border-radius: 20px;
            border: 1px solid var(--border-color);
            transition: all 0.2s;
        }

        .tag:hover {
            background: var(--primary-color);
            color: white;
            border-color: var(--primary-color);
        }

        /* Article Content */
        .post-content {
            font-size: 1rem;
            line-height: 1.9;
        }

        .post-content h1,
        .post-content h2,
        .post-content h3,
        .post-content h4,
        .post-content h5,
        .post-content h6 {
            margin-top: 2rem;
            margin-bottom: 1rem;
            font-weight: 600;
            line-height: 1.4;
            color: var(--text-color);
        }

        .post-content h1 { font-size: 1.875rem; }
        .post-content h2 { 
            font-size: 1.5rem; 
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--border-color);
        }
        .post-content h3 { font-size: 1.25rem; }
        .post-content h4 { font-size: 1.125rem; }

        .post-content p {
            margin-bottom: 1.25rem;
        }

        .post-content ul,
        .post-content ol {
            margin: 1.25rem 0;
            padding-left: 1.5rem;
        }

        .post-content li {
            margin-bottom: 0.5rem;
        }

        .post-content blockquote {
            margin: 1.5rem 0;
            padding: 1rem 1.5rem;
            background: var(--bg-secondary);
            border-left: 4px solid var(--primary-color);
            border-radius: 0 8px 8px 0;
            color: var(--text-light);
            font-style: italic;
        }

        .post-content blockquote p:last-child {
            margin-bottom: 0;
        }

        /* Code */
        .post-content code {
            font-family: 'JetBrains Mono', 'Fira Code', Consolas, monospace;
            font-size: 0.9em;
            background: var(--bg-code);
            padding: 0.2em 0.4em;
            border-radius: 4px;
            color: var(--link-color);
        }

        .post-content pre {
            margin: 1.5rem 0;
            padding: 1.25rem;
            background: var(--bg-code);
            border-radius: 10px;
            overflow-x: auto;
            border: 1px solid var(--border-color);
        }

        .post-content pre code {
            background: none;
            padding: 0;
            color: inherit;
            font-size: 0.875rem;
            line-height: 1.6;
        }

        /* Images */
        .post-content img {
            max-width: 100%;
            height: auto;
            border-radius: 10px;
            margin: 1.5rem 0;
            box-shadow: var(--shadow-lg);
        }

        /* Tables */
        .post-content table {
            width: 100%;
            margin: 1.5rem 0;
            border-collapse: collapse;
            font-size: 0.95rem;
        }

        .post-content th,
        .post-content td {
            padding: 0.75rem 1rem;
            border: 1px solid var(--border-color);
            text-align: left;
        }

        .post-content th {
            background: var(--bg-secondary);
            font-weight: 600;
        }

        .post-content tr:nth-child(even) {
            background: var(--bg-secondary);
        }

        /* Math */
        .math-display {
            margin: 1.5rem 0;
            overflow-x: auto;
            padding: 1rem;
            background: var(--bg-secondary);
            border-radius: 8px;
        }

        /* Anchor links */
        .anchor-link {
            opacity: 0;
            margin-left: 0.5rem;
            color: var(--text-muted);
            font-weight: 400;
            transition: opacity 0.2s;
        }

        .post-content h2:hover .anchor-link,
        .post-content h3:hover .anchor-link,
        .post-content h4:hover .anchor-link {
            opacity: 1;
        }

        /* Theme Toggle */
        .theme-toggle {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: var(--primary-color);
            color: white;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.25rem;
            box-shadow: var(--shadow-lg);
            transition: transform 0.2s, background 0.2s;
            z-index: 1000;
        }

        .theme-toggle:hover {
            transform: scale(1.1);
            background: var(--primary-hover);
        }

        /* Comments Section */
        .comments-section {
            margin-top: 3rem;
            padding-top: 2rem;
            border-top: 1px solid var(--border-color);
        }

        .comments-section h3 {
            font-size: 1.25rem;
            margin-bottom: 1.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        /* Footer */
        .post-footer {
            margin-top: 3rem;
            padding-top: 1.5rem;
            border-top: 1px solid var(--border-color);
            text-align: center;
            font-size: 0.9rem;
            color: var(--text-muted);
        }

        /* Responsive */
        @media (max-width: 1024px) {
            .toc-sidebar {
                display: none;
            }
            
            .page-wrapper {
                padding: 1.5rem;
            }
        }

        @media (max-width: 768px) {
            .post-header h1 {
                font-size: 1.75rem;
            }
            
            .post-meta {
                flex-direction: column;
                gap: 0.5rem;
            }
            
            .theme-toggle {
                bottom: 1rem;
                right: 1rem;
                width: 44px;
                height: 44px;
            }
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-secondary);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--text-muted);
        }
    </style>
</head>
<body>
    <div class="page-wrapper">
        <!-- TOC Sidebar -->
        <aside class="toc-sidebar">
            <div class="toc-container">
                <h3><i class="fas fa-list"></i> 目录</h3>
                <div class="toc">
<ul>
<li><a href="#chatgpt全文翻译-arrow_down">ChatGPT全文翻译 :arrow_down:</a></li>
<li><a href="#0-摘要">0. 摘要</a></li>
<li><a href="#1-引言">1. 引言</a></li>
<li><a href="#2-相关工作">2. 相关工作</a></li>
<li><a href="#3-方法">3. 方法</a><ul>
<li><a href="#31-持续学习表述">3.1 持续学习表述</a></li>
<li><a href="#32-continual-clip">3.2 Continual-CLIP</a></li>
</ul>
</li>
<li><a href="#4-实验">4. 实验</a><ul>
<li><a href="#41-实验协议">4.1 实验协议</a></li>
<li><a href="#42-结果">4.2 结果</a></li>
<li><a href="#43-文本提示分析">4.3 文本提示分析</a></li>
</ul>
</li>
<li><a href="#5-结论">5. 结论</a></li>
</ul>
</div>

            </div>
        </aside>

        <!-- Main Content -->
        <main class="main-content">
            <article>
                <header class="post-header">
                    <a href="../../../index.html" class="back-link">
                        <i class="fas fa-arrow-left"></i> 返回博客列表
                    </a>
                    <h1>Untitled</h1>
                    <div class="post-meta">
                        <span><i class="fas fa-calendar-alt"></i> 2026-02-04</span>
                        <span><i class="fas fa-folder"></i> AINotes/43.多模态增量学习MMCL</span>
                        <span><i class="fas fa-user"></i> Hongwei Zhao</span>
                    </div>
                    <div class="tags">
                        
                    </div>
                </header>

                <div class="post-content">
                    <h2 id="chatgpt全文翻译-arrow_down">ChatGPT全文翻译 :arrow_down:<a class="anchor-link" href="#chatgpt全文翻译-arrow_down" title="Permanent link">&para;</a></h2>
<h2 id="0-摘要">0. 摘要<a class="anchor-link" href="#0-摘要" title="Permanent link">&para;</a></h2>
<p>持续学习旨在随着时间的推移学习新任务而不遗忘之前的任务。文献中报告了多项重大努力，以在有限或无法访问以前任务数据的情况下解决这一问题。在这些努力中，典型的解决方案提供了复杂的技术，包括记忆重放、知识蒸馏、模型正则化和动态网络扩展。由此产生的方法在每个学习任务中都有重新训练的成本、专用的内存需求和特定设置的设计选择。在这项工作中，我们展示了一个冻结的 CLIP（对比语言 - 图像预训练）模型在不进行任何微调（零样本评估）的情况下，提供了惊人的持续学习性能。我们在包括类增量、域增量和任务无关增量学习的各种设置下，在五个流行基准（ImageNet-100 &amp; 1K、CORe50、CIFAR-100 和 TinyImageNet）上评估了 CLIP。在没有任何额外技巧的情况下，CLIP 模型在大多数设置中都优于最新的持续学习方法。我们展示了通过简单的提示模板来改变文本输入对 CLIP 模型性能的影响。据我们所知，这是首次在持续学习环境中报告 CLIP 零样本性能的工作。我们提倡在未来的持续学习任务比较中使用这种强大而又令人尴尬的简单基线。代码可在 https://github.com/vgthengane/Continual-CLIP 获取。</p>
<h2 id="1-引言">1. 引言<a class="anchor-link" href="#1-引言" title="Permanent link">&para;</a></h2>
<p>传统上，以监督方式训练在包含所有感兴趣类别的训练集上的深度神经网络（DNN）表现出了优异的结果。这类模型可以在一次训练过程中假设学习到数据集中所有相关特征。然而，在现实世界中，并不是所有的数据样本都可以一次性获得。为了应对这种情况，持续学习提供了一个有前途的范式，因为它使得学习可以应对数据分布随时间的变化。然而，在这种增量数据流上训练的 DNN 会遭遇灾难性遗忘问题，因为之前任务的数据无法完全访问【31】。</p>
<p>文献中存在四种流行的持续学习协议：任务增量学习（TIL）使用任务特定的神经网络，其中在推理时假设任务标识符已知。类增量学习（CIL）设置中，类别按顺序添加，推理时任务标识符未知。在域增量学习（DIL）中，类别数量保持不变，但数据域随着时间推移发生变化。任务无关（或任务无标识）持续学习（TFCL）是一种更通用的设置，没有显式的任务边界，数据可以自由地在持续学习阶段中出现【21】。这些方法面临的主要挑战是在更新新数据时避免遗忘以前学到的知识。</p>
<p>在持续学习文献中，已经开发了几种专门的方法来减少灾难性遗忘。其中，典型的解决方案提供了复杂的技术，包括记忆重放【17，27，12】、知识蒸馏【5，13】、模型正则化【14，3】、参数隔离【22，7】以及动态网络扩展【6，8，20】。这些方法在每个学习任务中都有重新训练的成本，需要专门的内存来存储样本或过去的模型，并且涉及复杂的超参数调整，这限制了它们的实际应用。此外，上述持续学习协议通常是单独处理的，现有方法涉及特定设置的设计选择，使它们无法在不同的持续学习设置之间转移。</p>
<p>在这项工作中，我们旨在测试目前为止在实现真正的持续学习系统方面取得的进展。我们的主要问题是探索是否可以用一种不需要为每个增量步骤训练的简单通用方法取代当前最先进的狭窄模型，无需示例记忆存储，并且可以在所有现有增量学习协议中工作，且无需或仅需极少的超参数调整。为此，我们展示了一个冻结的 CLIP 模型【19】由于其可泛化的表示和无需任何参数调整的零样本行为，展示了巨大的潜力。我们称在各种持续学习设置下评估的 CLIP 为 Continual-CLIP。图 1 概述了传统的持续学习方法和冻结 CLIP 在持续学习系统中的应用。</p>
<p>我们在四种不同的设置（TIL、CIL、DIL 和 TFCL）和七个数据集（ImageNet-100 &amp; 1K【9】，CLEAR【10】，CIFAR-100【18】，TinyImageNet【26】，CoRe50【28】和高斯计划 CIFAR-100【24】）中的广泛评估表明，CLIP 在所有这些 CL 设置中都具有竞争力。这种泛化行为是由于视觉 - 语言模型如 CLIP 在 400M 图文对上进行对比训练目标的过程中进行了大规模预训练。在预训练期间，CLIP 学习了一系列多样化的高级表示，这些表示可以传递到多个下游任务，包括增量任务。我们还展示了如何通过简单的提示工程来改变文本输入，从而影响 CLIP 在 CL 中的性能。</p>
<p>总之，这项工作为基于预训练视觉 - 语言模型的未来持续学习方向奠定了基线。我们在各种流行的图像识别基准上评估了预训练的冻结 CLIP 模型在不同持续学习设置下的表现，并与当前最先进的方法进行比较，显示出开箱即用的 CLIP 表示在所有情况下都表现出竞争力。我们的结果旨在整合持续学习领域中分散的努力，这些努力专注于特定的设置，并强调了需要能够在多个设置中工作的通用方法。</p>
<h2 id="2-相关工作">2. 相关工作<a class="anchor-link" href="#2-相关工作" title="Permanent link">&para;</a></h2>
<p>持续学习：现有的持续学习方法主要采用以下方案之一：（1）模型正则化，（2）记忆重放，（3）动态网络扩展。基于正则化的方法【14，3，13，5】通过限制对先前任务重要的模型参数的可塑性来避免灾难性遗忘。尽管这些方法不需要记忆重放，但它们仅被证明在简化的任务增量设置（假设在推理时任务标识符已知）和较小的数据集上有效【29】。基于记忆重放的方法使用存储在内存中的样本或使用生成技术合成样本，并在更具挑战性的设置和数据集上表现出色【17，25，11，15】。然而，当内存较小时，它们的性能会下降【15】，并且存储这些样本可能引发安全和隐私问题【23】。架构驱动的 CL 方法要么动态扩展网络【8，16，30，31】要么划分为子网络以适应新任务【31，32】。这种方法缺乏可扩展性，因为网络容量随着任务的增加而增长。</p>
<p>视觉 - 语言模型：训练一个联合视觉 - 语言嵌入空间可以促进文本和图像数据之间的交互，这对于解决零样本学习、视觉定位和图像字幕等问题至关重要。尽管最初的视觉 - 语言模型是单流的，并将视觉和文本数据的连接输入作为一个输入集进行处理【30，4】最近的方法，如对比语言 - 图像预训练（CLIP）【19】是双流的，分别为图像和文本输入提供专用编码器。两个编码器的表示被投射到一个统一的嵌入空间中，并使用对比学习目标来最小化匹配图文对之间的距离，并最大化不匹配的图文嵌入对之间的距离。随后的工作表明，CLIP 是可扩展的，并且其能力在训练了大规模噪声数据 1B 未整理样本【33】时有所提高。已经证明，CLIP 学习的表示在众多下游任务中具有良好的泛化能力，包括图文检索，具有出色的零样本转移能力【35】。CLIP 还可以灵活地适应视频【34，36】，并捕捉对象级交互【31，35，37】。然而，CLIP 表示在 CL 中的适用性尚未被探讨。</p>
<p>随着视觉 Transformer【4】和 NLP 中基于提示的微调的最新进展【6】，Wang 等人已经展示了通过提示学习与 ImageNet 预训练模型交互是一种有前途的持续学习方法【32，33】。一小组可学习参数，称为提示，附加到输入上，使得冻结的 ImageNet 预训练模型能够快速适应新的流任务。在我们的分析中，我们展示了直接利用预训练的视觉 - 语言模型，而不引入任何可学习参数，是一种简单但有前途的持续学习方法。我们认为，适应联合视觉 - 语言模型如 CLIP【19】以进行持续学习具有多个优势。它使得在没有明确任务标识符和边界的实际场景中，可以动态适应流数据的任务无关方式中操作。使用 CLIP 模型不需要为新任务进行计算密集的训练或微</p>
<p>调。此外，与当前最先进的方法需要存储来自以前任务的训练样本的记忆缓冲区相比，Continual-CLIP 方法不需要重放，更适合在存储训练样本可能存在实际隐私和安全问题或存储限制的场景中使用【23】。相反，Continual-CLIP 方法在所有学习阶段中需要的内存是固定的。总之，Continual-CLIP 方法是无内存的，不需要测试时的任务标识信息，可以灵活、轻松地适应任意数量的类别，而无需额外的可学习参数。</p>
<h2 id="3-方法">3. 方法<a class="anchor-link" href="#3-方法" title="Permanent link">&para;</a></h2>
<p>在本节中，我们首先简要讨论不同的持续学习设置。接下来，我们介绍对比语言 - 图像预训练（CLIP，Radford 等人【19】），并解释如何在零样本的情况下使用手工制作的提示将其应用于不同的下游持续学习任务。</p>
<h3 id="31-持续学习表述">3.1 持续学习表述<a class="anchor-link" href="#31-持续学习表述" title="Permanent link">&para;</a></h3>
<p>不同的持续学习（CL）问题集中于在非平稳数据中从连续任务中训练模型，同时减少对旧任务的遗忘。考虑一个任务序列 <span class="math-inline">D = {D_1, D_2, \ldots, D_T}</span>，其中第 <span class="math-inline">t</span> 个任务 <span class="math-inline">D_t = {(x_{i,t}, y_{i,t})}<em>{i=1}^{N</em>{D_t}}</span> 包含输入样本的元组 <span class="math-inline">x_{i,t} \in X</span> 及其对应的标签 <span class="math-inline">y_{i,t} \in Y</span>。目标是优化参数为 <span class="math-inline">\theta</span> 的模型 <span class="math-inline">f_\theta : X \rightarrow Y</span>，使其能够预测任意任务的未见测试样本 <span class="math-inline">x</span> 的标签 <span class="math-inline">y = f_\theta(x) \in Y</span>。在任务 <span class="math-inline">t</span> 期间，来自先前分布 <span class="math-inline">D_{t-1}</span> 的数据不可用或受限。</p>
<p>基于任务 <span class="math-inline">t</span> 的输入分布 <span class="math-inline">P(X^{(t)})</span> 和输出分布 <span class="math-inline">P(Y^{(t)})</span>，其中 <span class="math-inline">P(X^{(t)}) \neq P(X^{(t+1)})</span>，持续学习可以分为四种流行的设置，每种设置都有略微不同的假设，即任务增量、类增量、域增量和任务无关 CL。常见的任务、类、域增量设置假设任务数据 <span class="math-inline">D_t</span> 按序列到达，使得 <span class="math-inline">t = {1, 2, \ldots, T}</span>。在任务 <span class="math-inline">t</span> 中，类增量设置定义了所有观察到的类别标签的输出空间 <span class="math-inline">Y^{(t)} \subset Y^{(t+1)}</span> 且 <span class="math-inline">P(Y^{(t)}) \neq P(Y^{(t+1)})</span>。与类增量设置不同，任务增量设置定义了 <span class="math-inline">Y^{(t)} \neq Y^{(t+1)}</span>，且 <span class="math-inline">P(Y^{(t)}) \neq P(Y^{(t+1)})</span> 需要任务标签 <span class="math-inline">t</span> 来表示隔离的输出头 <span class="math-inline">Y^{(t)}</span>。与每个任务有不同类别的任务和类增量设置不同，域增量设置定义为 <span class="math-inline">Y^{(t)} = Y^{(t+1)}</span> 且 <span class="math-inline">P(Y^{(t)}) = P(Y^{(t+1)})</span> 及 <span class="math-inline">P(X^{(t)}) \neq P(X^{(t+1)})</span>，表明它包含来自不同域的图像集，但每个任务都有相同的类别集。更具挑战性的是任务无关（或任务无标识）设置，其中任务数据 <span class="math-inline">D_t</span> 平滑变化，且任务标识 <span class="math-inline">t</span> 未知【21】。在这项工作中，我们进行了广泛的实验，以展示基于 CLIP 的方法在类增量、域增量和 CL 中任务无关设置中的有效性。</p>
<h3 id="32-continual-clip">3.2 Continual-CLIP<a class="anchor-link" href="#32-continual-clip" title="Permanent link">&para;</a></h3>
<p>对比语言 - 图像预训练（CLIP，Radford 等人【19】）由两个并行的编码器组成，一个用于文本，另一个用于图像。文本编码器基于 Transformer【34】架构，为基于文本的语言输入生成嵌入表示。另一方面，图像编码器架构可以基于 CNN（如 ResNet-50【16】）或视觉 Transformer（ViT）模型【8】将高维输入图像转换为紧凑的嵌入空间。文本和图像编码器的嵌入特征维度相同，从而使两个模态的表示学习在一个共享和统一的表示空间中。</p>
<p>CLIP 模型使用对比损失进行训练，该损失增强了属于同一图文对的图像和文本嵌入之间的相似性，使它们在联合特征空间中对齐。给定一批图文对，CLIP 的目标是最大化匹配对之间的余弦相似度，同时最小化不匹配图文嵌入对之间的相似度。使用这一学习目标，模型在一个包含 400M 图文对的大规模数据集上进行训练，学习到具有高度可转移性的图像和文本数据表示，显示了令人印象深刻的零样本泛化能力。</p>
<p>设 CLIP 模型为 <span class="math-inline">F = {E_{\text{visual}}, E_{\text{text}}}</span>，其中 <span class="math-inline">E_{\text{visual}}</span> 和 <span class="math-inline">E_{\text{text}}</span> 分别是图像和文本编码器。考虑一个 <span class="math-inline">K</span> 类分类问题，其中单个测试图像 <span class="math-inline">x_{\text{test}} \in \mathbb{R}^{C \times H \times W}</span> 属于类别 <span class="math-inline">y \in \mathbb{R}^K</span>。在传统的零样本分类场景中，每个 <span class="math-inline">y_i \in Y = {y_1, y_2, \ldots, y_K}</span> 被预先附加了一个手工制作的提示模板 <span class="math-inline">p</span>，例如“a photo of a {category}”，以形成类别特定的文本输入 <span class="math-inline">{p; y_i}</span>。然后将该文本输入送入文本编码器以获得文本嵌入 <span class="math-inline">{t_1, t_2, \ldots, t_K}</span>，其中 <span class="math-inline">t_i = E_{\text{text}}({p; y_i})</span>。图像输入 <span class="math-inline">x_{\text{test}}</span> 被送入 <span class="math-inline">E_{\text{visual}}</span> 以获得相应的图像嵌入 <span class="math-inline">v = E_{\text{visual}}(x_{\text{test}})</span>。然后将文本和图像嵌入进行匹配以计算相似度得分 <span class="math-inline">s_i = \text{sim}(t_i \cdot v)</span>，其中 <span class="math-inline">\text{sim}(·, ·)</span> 表示余弦相似度。测试样本 <span class="math-inline">x_{\text{test}}</span> 的预测概率可以表示为<br />
<div class="math-display"><br />
    p(y_i | x_{\text{test}}) = \frac{\exp(\text{sim}(t_i \cdot v))}{\sum_{i=1}^{K} \exp(\text{sim}(t_i \cdot v))}<br />
</div><br />
传统的分类器学习闭集的视觉概念，而视觉 - 语言预训练模型如 CLIP 通过高容量的文本编码器学习开放集的视觉概念。这导致了一个更广泛的语义空间，使得学习到的表示更易于转移到下游任务。预训练的视觉 - 语言 CLIP 模型因此提供了令人印象深刻的零样本能力。我们在持续学习设置下利用冻结的 CLIP 模型进行图像识别，而无需进行任何训练，以严格的零样本方式进行。在评估过程中，我们首先初始化两个 CLIP 编码器并冻结权重。与传统评估不同的是，在持续评估中，我们假设模型正在学习当前任务 <span class="math-inline">t</span>，并仅在已观察到的任务上进行评估。</p>
<h2 id="4-实验">4. 实验<a class="anchor-link" href="#4-实验" title="Permanent link">&para;</a></h2>
<h3 id="41-实验协议">4.1 实验协议<a class="anchor-link" href="#41-实验协议" title="Permanent link">&para;</a></h3>
<p>数据集：我们在七个不同的数据集和 13 个不同的学习任务配置中评估了 Continual-CLIP。在类增量设置中，我们在 CIFAR-100、ImageNet-100 &amp; 1K、TinyImageNet 下的不同类分割中评估 Continual-CLIP。（a）在 CIFAR-100 中，我们比较了在 10 个步骤（每个步骤 10 个新类）、20 个步骤（每个步骤 5 个新类）和 50 个步骤（每个步骤 2 个新类）下的性能【6，8】。（b）在 ImageNet-100 中，我们考虑了两种评估设置；ImageNet-100-B0 在所有步骤中具有相同数量的类（即每步 10 个类），ImageNet-100-B50 在第一步包含 50 个类，其余 50 个类在接下来的 10 步中逐步观察（每步 5 个类）【8】。（c）我们将 ImageNet-1K 分为 10 个增量步骤（每步 100 个类）【</p>
<p>8】。（d）在 TinyImageNet 中，我们在第一步保留了 100 个类，然后与 ImageNet-100 类似，在三种不同的步骤数量（即 5 步（每步 20 个类）、10 步（每步 10 个类）和 20 步（每步 5 个类））中逐步添加剩余的类【26】。请注意，我们没有在推理时已知任务 ID 的任务增量设置下进行评估，因为这是持续学习设置中最简单的一种。</p>
<p>我们在域增量设置下使用 CORe50 和 CLEAR-10 &amp; 100 数据集评估 Continual-CLIP。CORe50 有 11 个不同的场景和 10 个类。由于我们不训练（或微调）模型，只考虑了 3 个域进行评估，遵循【28】中的指南。在 CLEAR-10 &amp; 100 实验中，我们使用了 Avalanche【32】的预构建方法来获取评估场景。</p>
<p>我们在任务无关（或任务无标识）设置下使用高斯计划 CIFAR-100 进行评估。我们使用与【24】中相同的设置来检查 Continual-CLIP 方法在任务无标识设置中的有效性。对于评估，【24】将评估数据集置于一旁，并在每个任务后对整个数据集进行评估。由于 Continual-CLIP 模型是冻结的，我们报告了最终的测试准确率以进行比较。</p>
<p>评估指标：在类增量设置中，我们通过“Avg”准确率（在每个时间步骤获得的所有准确率值的平均值）和“Last”准确率（学习所有任务后的最终准确率）与其他基线方法比较 Continual-CLIP。在域增量设置中，我们使用“In-domain”、“Next-domain”、“Forward transfer”、“Backward transfer”和“Overall accuracy”来比较 Continual-CLIP。请注意，对于 CORe50 数据集，只有一个测试集可用，因此我们报告了该测试集的准确率。同样，对于任务无标识设置，我们仅报告测试准确率。</p>
<p>实现细节：我们在零样本评估设置中使用了官方的 CLIP【19】实现。为了构建类增量设置的持续场景，我们大量使用了 Continuum【32】，并遵循了【6】中的相同评估设置。在 CORe50 和 CLEAR 数据集上的域增量场景中，我们使用了 Avalanche 库【32】。由于 CIFAR100 和 TinyImageNet 数据集包含低分辨率图像，我们使用了“a bad photo of a {category}”提示模板。ImageNet-100 和 1K 等数据集具有高分辨率图像，因此我们在所有实验中使用了“a good photo of a {category}”提示模板来评估 Continual-CLIP。</p>
<p>在评估中，我们使用了【19】中定义的数据预处理技术，包括双三次插值、中心裁剪和归一化。</p>
<h3 id="42-结果">4.2 结果<a class="anchor-link" href="#42-结果" title="Permanent link">&para;</a></h3>
<p>类增量设置。表 1 中的结果将 Continual-CLIP 与其他基线方法在 CIFAR-100 数据集上的三种不同设置（10、20 和 50 个步骤）进行了比较。在 10 个步骤设置中，即使没有任何训练或微调，Continual-CLIP 在平均准确率和最后准确率方面也达到了与最近的最先进方法（如 DyTox【6】和 DER【8】）相当的竞争力。特别是，在 20 个步骤设置中，Continual-CLIP 达到了 75.95% 的“Avg”准确率，而在 50 个步骤设置中达到了 76.49% 的“Avg”准确率。最后的准确率在所有情况下相同（因为这是零样本评估）。结果表明，Continual-CLIP 在大多数情况下始终优于大多数比较方法，并且有显著的差距。这一趋势在较大数量任务上尤为显著，这是 CL 中更具挑战性的案例（图 2）。</p>
<p>ImageNet-100 &amp; 1K 数据集上的结果如表 2 所示。在标准设置（即所有步骤中的类数相同；参见第 2-5 列）中，Continual-CLIP 在 ImageNet-100 上显示出 7.84% 的改进，在 ImageNet-1K 数据集上显示出 4.63% 的改进，均为“Avg”准确率相比第二好的方法。同样，在“Last”准确率上，ImageNet-100 上显示了 7.71% 的显著改进，而 ImageNet-1K 上显示了 7.70% 的显著改进。在具有 50 个基础类的其他设置（即 ImageNet-100-B50）中，Continual-CLIP 显示的结果优于最近的方法。</p>
<p>在表 3 中报告的结果中，我们观察到在 TinyImageNet 数据集上，Continual-CLIP 在所有 3 个设置中都显示了持续的改进。Continual-CLIP 相比于第二好的方法 DyTox 在平均准确率方面平均提高了 20.30%，在最后的准确率方面也显示了显著的增益。</p>
<p>域增量设置。表 4 显示了 Continual-CLIP 方法与 CVPR 2022 CLEAR 挑战赛榜单上获胜团队的比较【10】。这些值是根据【28】中的评估协议在测试集上报告的。对于 CLEAR-10 &amp; 100，Continual-CLIP 在整体表现上与表现最好的团队竞争。</p>
<p>任务无标识设置。这是一种通用设置，其中没有任务、类别或域的约束，被认为相当具有挑战性。这种设置在文献中相对较少探索。在表 6 中，我们展示了 Continual-CLIP 与先前最佳方法（即 Encoders and Ensemble【24】）的比较。Continual-CLIP 以大幅度超越了比较方法，且无需任何训练或模型集成。</p>
<p>总之，我们的广泛经验评估和比较提供了证据表明，Continual-CLIP 在所有持续学习设置中始终表现出令人印象深刻的结果，无需任何微调（或训练）、过去样本的专用内存或模型副本、复杂的超参数调整、动态模型扩展或更改分类头。</p>
<h3 id="43-文本提示分析">4.3 文本提示分析<a class="anchor-link" href="#43-文本提示分析" title="Permanent link">&para;</a></h3>
<p>在本节中，我们研究了不同类别名称用作文本提示的一部分对 Continual-CLIP 准确率的影响。我们找到了 ImageNet-1K 数据集类的不同命名约定，并使用它们来评估 Continual-CLIP 性能。具体来说，我们使用了来自三个不同来源的三个名称：（a）ImageNet 原始标签，其中每个 1000 个 ImageNet 类【9】对应于一个 WordNet 同义词集（synset），（b）原始 ImageNet 标签具有重叠含义（例如“nail”，CLIP 模型将其理解为“fingernail”，因此它被更改为“metal nail”），因此 Radford 等人【19】对默认标签进行了整理以克服这种混淆，以及（c）每个同义词集的第一个同义词标签。表 7 显示了不同类名约定对模型性能的影响。使用类名类型（b）时，模型比其他两种类名类型显示出更好的结果，这是因为类名类型（b）以清晰的边界和不同类别名之间的区分进行了整理，而其他两种类型可能具有重叠的类含义。</p>
<p>我们进一步探索了 Continual-CLIP 在提示工程中的有效性。为此，我们使用了不同的提示，并分析了 ImageNet-100 数据集上的结果。在表 8 中，我们报告了两种不同提示技术的零样本持续 CLIP 结果。（p1）基于决策的池化（计算每个提示的分数，然后进行平均池化），（p2）基于嵌入的池化（我们首先通过文本编码器传递每个提示以计算文本嵌入，然后通过堆叠所有嵌入创建一个单一分类头）。表 8 中的结果显示了基于嵌入和基于决策池化之间的权衡。相比于 Continual-CLIP 主结果，嵌入和基于决策的池化需要收集多个提示模板并进行额外的计算以获得每个提示的文本嵌入。此外，使用基于决策和嵌入的池化，我们需要领域专家知识来进行提示工程，并在多个试验中重复该过程，直到找到最佳提示。</p>
<h2 id="5-结论">5. 结论<a class="anchor-link" href="#5-结论" title="Permanent link">&para;</a></h2>
<p>在这项工作中，我们评估了一个简单但有效的基线，在三种不同的增量学习设置中始终取得了良好的结果：（1）类增量，（2）域增量和（3）任务无标识增量学习。Continual-CLIP 是一个标准的 CLIP 模型，在持续学习场景中进行了评估。在不同基准上的实验结果显示，在具有挑战性的配置下，Continual-CLIP 在持续学习中优于当前最先进的方法，无需进行任何微调、重放缓冲或内存开销。Continual-CLIP 模型可以在任何持续学习设置中使用，且几乎不需要修改。ImageNet-1k（类增量）和 CORe50（域增量）等大数据集上的最先进性能</p>
<p>表明，Continual-CLIP 具有良好的可扩展性。</p>
<p>尽管 Continual-CLIP 在持续学习设置中表现出色，但存在潜在的信息泄漏可能性，例如 CLIP 可能在预训练阶段已经遇到过评估下游数据集中的某些类。此外，还出现了新的问题，例如从混淆矩阵中可以看出（图 4 左侧：CIFAR100），当类名语义上接近时，模型会出现混淆：类索引“50”的类名为“mouse”，而模型将其预测为“74”，即“shrew”。</p>
<p>在未来的工作中，这种建立在 CLIP 零样本转移能力之上的简单基线方法可以通过快速适应方法扩展到下游持续任务中。当前的工作为持续学习领域的发展奠定了基础，利用了视觉 - 语言基础模型。我们的工作还激励了对持续学习问题所取得的进展的重新思考，其中最新的方法带来了诸多限制，并鼓励寻找超越狭隘设置和繁琐内存及计算需求的通用解决方案。</p>
                </div>

                <!-- Comments Section (Giscus) -->
                <section class="comments-section">
                    <h3><i class="fas fa-comments"></i> 评论</h3>
                    <script src="https://giscus.app/client.js"
                        data-repo="Geeks-Z/Geeks-Z.github.io"
                        data-repo-id=""
                        data-category="Announcements"
                        data-category-id=""
                        data-mapping="pathname"
                        data-strict="0"
                        data-reactions-enabled="1"
                        data-emit-metadata="0"
                        data-input-position="bottom"
                        data-theme="preferred_color_scheme"
                        data-lang="zh-CN"
                        crossorigin="anonymous"
                        async>
                    </script>
                </section>
            </article>

            <footer class="post-footer">
                <p>© 2025 Hongwei Zhao. Built with ❤️</p>
            </footer>
        </main>
    </div>

    <!-- Theme Toggle Button -->
    <button class="theme-toggle" id="themeToggle" aria-label="切换主题">
        <i class="fas fa-moon"></i>
    </button>

    <script>
        // Theme Toggle
        const themeToggle = document.getElementById('themeToggle');
        const html = document.documentElement;
        const icon = themeToggle.querySelector('i');
        const hljsDark = document.getElementById('hljs-theme-dark');
        const hljsLight = document.getElementById('hljs-theme-light');
        
        // Check saved theme or system preference
        const savedTheme = localStorage.getItem('theme');
        const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
        
        if (savedTheme === 'dark' || (!savedTheme && prefersDark)) {
            html.setAttribute('data-theme', 'dark');
            icon.className = 'fas fa-sun';
            hljsDark.disabled = false;
            hljsLight.disabled = true;
        }
        
        themeToggle.addEventListener('click', () => {
            const isDark = html.getAttribute('data-theme') === 'dark';
            if (isDark) {
                html.removeAttribute('data-theme');
                icon.className = 'fas fa-moon';
                localStorage.setItem('theme', 'light');
                hljsDark.disabled = true;
                hljsLight.disabled = false;
            } else {
                html.setAttribute('data-theme', 'dark');
                icon.className = 'fas fa-sun';
                localStorage.setItem('theme', 'dark');
                hljsDark.disabled = false;
                hljsLight.disabled = true;
            }
            
            // Update Giscus theme
            const giscusFrame = document.querySelector('iframe.giscus-frame');
            if (giscusFrame) {
                giscusFrame.contentWindow.postMessage({
                    giscus: {
                        setConfig: {
                            theme: isDark ? 'light' : 'dark'
                        }
                    }
                }, 'https://giscus.app');
            }
        });
        
        // Highlight.js
        document.addEventListener('DOMContentLoaded', () => {
            hljs.highlightAll();
        });
        
        // KaTeX auto-render
        document.addEventListener('DOMContentLoaded', () => {
            if (typeof renderMathInElement !== 'undefined') {
                renderMathInElement(document.body, {
                    delimiters: [
                        {left: '$$', right: '$$', display: true},
                        {left: '$', right: '$', display: false},
                        {left: '\\[', right: '\\]', display: true},
                        {left: '\\(', right: '\\)', display: false}
                    ],
                    throwOnError: false
                });
            }
        });
        
        // TOC active state
        const tocLinks = document.querySelectorAll('.toc-container a');
        const headings = document.querySelectorAll('.post-content h2, .post-content h3, .post-content h4');
        
        function updateTocActive() {
            let current = '';
            headings.forEach(heading => {
                const rect = heading.getBoundingClientRect();
                if (rect.top <= 100) {
                    current = heading.getAttribute('id');
                }
            });
            
            tocLinks.forEach(link => {
                link.classList.remove('active');
                if (link.getAttribute('href') === '#' + current) {
                    link.classList.add('active');
                }
            });
        }
        
        window.addEventListener('scroll', updateTocActive);
        updateTocActive();
    </script>
</body>
</html>
