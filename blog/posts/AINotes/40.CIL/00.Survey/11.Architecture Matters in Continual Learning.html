<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Untitled</title>
    <meta name="description" content="Untitled - Hongwei Zhao's Blog">
    <meta name="author" content="Hongwei Zhao">
    
    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Noto+Sans+SC:wght@300;400;500;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    
    <!-- Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <!-- Code Highlighting -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css" id="hljs-theme-dark">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css" id="hljs-theme-light" disabled>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    
    <!-- KaTeX for Math -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>
    
    <style>
        :root {
            /* Light Theme */
            --primary-color: #2980b9;
            --primary-hover: #1a5276;
            --link-color: #c0392b;
            --text-color: #333;
            --text-light: #666;
            --text-muted: #999;
            --bg-color: #fff;
            --bg-secondary: #f8f9fa;
            --bg-code: #f5f5f5;
            --border-color: #e5e7eb;
            --shadow: 0 1px 3px rgba(0,0,0,0.1);
            --shadow-lg: 0 4px 15px rgba(0,0,0,0.1);
        }

        [data-theme="dark"] {
            --primary-color: #5dade2;
            --primary-hover: #85c1e9;
            --link-color: #e74c3c;
            --text-color: #e5e7eb;
            --text-light: #9ca3af;
            --text-muted: #6b7280;
            --bg-color: #1a1a2e;
            --bg-secondary: #16213e;
            --bg-code: #0f0f23;
            --border-color: #374151;
            --shadow: 0 1px 3px rgba(0,0,0,0.3);
            --shadow-lg: 0 4px 15px rgba(0,0,0,0.4);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            scroll-behavior: smooth;
        }

        body {
            font-family: 'Inter', 'Noto Sans SC', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            font-size: 16px;
            line-height: 1.8;
            color: var(--text-color);
            background: var(--bg-color);
            transition: background-color 0.3s, color 0.3s;
        }

        a {
            color: var(--primary-color);
            text-decoration: none;
            transition: color 0.2s;
        }

        a:hover {
            color: var(--primary-hover);
            text-decoration: underline;
        }

        /* Layout */
        .page-wrapper {
            display: flex;
            max-width: 1400px;
            margin: 0 auto;
            padding: 2rem;
            gap: 3rem;
        }

        /* Sidebar TOC */
        .toc-sidebar {
            width: 260px;
            flex-shrink: 0;
            position: sticky;
            top: 2rem;
            height: fit-content;
            max-height: calc(100vh - 4rem);
            overflow-y: auto;
        }

        .toc-container {
            background: var(--bg-secondary);
            border-radius: 12px;
            padding: 1.5rem;
            border: 1px solid var(--border-color);
        }

        .toc-container h3 {
            font-size: 0.85rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-muted);
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .toc-container ul {
            list-style: none;
        }

        .toc-container li {
            margin-bottom: 0.5rem;
        }

        .toc-container a {
            font-size: 0.9rem;
            color: var(--text-light);
            display: block;
            padding: 0.25rem 0;
            border-left: 2px solid transparent;
            padding-left: 0.75rem;
            transition: all 0.2s;
        }

        .toc-container a:hover,
        .toc-container a.active {
            color: var(--primary-color);
            border-left-color: var(--primary-color);
            text-decoration: none;
        }

        .toc-container ul ul {
            margin-left: 1rem;
        }

        /* Main Content */
        .main-content {
            flex: 1;
            min-width: 0;
            max-width: 800px;
        }

        /* Header */
        .post-header {
            margin-bottom: 2rem;
            padding-bottom: 1.5rem;
            border-bottom: 1px solid var(--border-color);
        }

        .back-link {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.9rem;
            color: var(--text-light);
            margin-bottom: 1.5rem;
        }

        .back-link:hover {
            color: var(--primary-color);
            text-decoration: none;
        }

        .post-header h1 {
            font-size: 2.25rem;
            font-weight: 700;
            line-height: 1.3;
            margin-bottom: 1rem;
            color: var(--text-color);
        }

        .post-meta {
            display: flex;
            flex-wrap: wrap;
            gap: 1.5rem;
            font-size: 0.9rem;
            color: var(--text-light);
        }

        .post-meta span {
            display: flex;
            align-items: center;
            gap: 0.4rem;
        }

        .post-meta i {
            color: var(--text-muted);
        }

        .tags {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-top: 1rem;
        }

        .tag {
            display: inline-block;
            font-size: 0.8rem;
            background: var(--bg-secondary);
            color: var(--text-light);
            padding: 0.25rem 0.75rem;
            border-radius: 20px;
            border: 1px solid var(--border-color);
            transition: all 0.2s;
        }

        .tag:hover {
            background: var(--primary-color);
            color: white;
            border-color: var(--primary-color);
        }

        /* Article Content */
        .post-content {
            font-size: 1rem;
            line-height: 1.9;
        }

        .post-content h1,
        .post-content h2,
        .post-content h3,
        .post-content h4,
        .post-content h5,
        .post-content h6 {
            margin-top: 2rem;
            margin-bottom: 1rem;
            font-weight: 600;
            line-height: 1.4;
            color: var(--text-color);
        }

        .post-content h1 { font-size: 1.875rem; }
        .post-content h2 { 
            font-size: 1.5rem; 
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--border-color);
        }
        .post-content h3 { font-size: 1.25rem; }
        .post-content h4 { font-size: 1.125rem; }

        .post-content p {
            margin-bottom: 1.25rem;
        }

        .post-content ul,
        .post-content ol {
            margin: 1.25rem 0;
            padding-left: 1.5rem;
        }

        .post-content li {
            margin-bottom: 0.5rem;
        }

        .post-content blockquote {
            margin: 1.5rem 0;
            padding: 1rem 1.5rem;
            background: var(--bg-secondary);
            border-left: 4px solid var(--primary-color);
            border-radius: 0 8px 8px 0;
            color: var(--text-light);
            font-style: italic;
        }

        .post-content blockquote p:last-child {
            margin-bottom: 0;
        }

        /* Code */
        .post-content code {
            font-family: 'JetBrains Mono', 'Fira Code', Consolas, monospace;
            font-size: 0.9em;
            background: var(--bg-code);
            padding: 0.2em 0.4em;
            border-radius: 4px;
            color: var(--link-color);
        }

        .post-content pre {
            margin: 1.5rem 0;
            padding: 1.25rem;
            background: var(--bg-code);
            border-radius: 10px;
            overflow-x: auto;
            border: 1px solid var(--border-color);
        }

        .post-content pre code {
            background: none;
            padding: 0;
            color: inherit;
            font-size: 0.875rem;
            line-height: 1.6;
        }

        /* Images */
        .post-content img {
            max-width: 100%;
            height: auto;
            border-radius: 10px;
            margin: 1.5rem 0;
            box-shadow: var(--shadow-lg);
        }

        /* Tables */
        .post-content table {
            width: 100%;
            margin: 1.5rem 0;
            border-collapse: collapse;
            font-size: 0.95rem;
        }

        .post-content th,
        .post-content td {
            padding: 0.75rem 1rem;
            border: 1px solid var(--border-color);
            text-align: left;
        }

        .post-content th {
            background: var(--bg-secondary);
            font-weight: 600;
        }

        .post-content tr:nth-child(even) {
            background: var(--bg-secondary);
        }

        /* Math */
        .math-display {
            margin: 1.5rem 0;
            overflow-x: auto;
            padding: 1rem;
            background: var(--bg-secondary);
            border-radius: 8px;
        }

        /* Anchor links */
        .anchor-link {
            opacity: 0;
            margin-left: 0.5rem;
            color: var(--text-muted);
            font-weight: 400;
            transition: opacity 0.2s;
        }

        .post-content h2:hover .anchor-link,
        .post-content h3:hover .anchor-link,
        .post-content h4:hover .anchor-link {
            opacity: 1;
        }

        /* Theme Toggle */
        .theme-toggle {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: var(--primary-color);
            color: white;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.25rem;
            box-shadow: var(--shadow-lg);
            transition: transform 0.2s, background 0.2s;
            z-index: 1000;
        }

        .theme-toggle:hover {
            transform: scale(1.1);
            background: var(--primary-hover);
        }

        /* Comments Section */
        .comments-section {
            margin-top: 3rem;
            padding-top: 2rem;
            border-top: 1px solid var(--border-color);
        }

        .comments-section h3 {
            font-size: 1.25rem;
            margin-bottom: 1.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        /* Footer */
        .post-footer {
            margin-top: 3rem;
            padding-top: 1.5rem;
            border-top: 1px solid var(--border-color);
            text-align: center;
            font-size: 0.9rem;
            color: var(--text-muted);
        }

        /* Responsive */
        @media (max-width: 1024px) {
            .toc-sidebar {
                display: none;
            }
            
            .page-wrapper {
                padding: 1.5rem;
            }
        }

        @media (max-width: 768px) {
            .post-header h1 {
                font-size: 1.75rem;
            }
            
            .post-meta {
                flex-direction: column;
                gap: 0.5rem;
            }
            
            .theme-toggle {
                bottom: 1rem;
                right: 1rem;
                width: 44px;
                height: 44px;
            }
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-secondary);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--text-muted);
        }
    </style>
</head>
<body>
    <div class="page-wrapper">
        <!-- TOC Sidebar -->
        <aside class="toc-sidebar">
            <div class="toc-container">
                <h3><i class="fas fa-list"></i> 目录</h3>
                <div class="toc">
<ul>
<li><a href="#0-摘要">0. 摘要</a></li>
<li><a href="#1-引言">1. 引言</a></li>
<li><a href="#2-比较架构">2. 比较架构</a><ul>
<li><a href="#21-实验设置">2.1 实验设置</a><ul>
<li><a href="#211-持续学习设置">2.1.1 持续学习设置</a></li>
<li><a href="#212-评估指标">2.1.2 评估指标</a></li>
</ul>
</li>
<li><a href="#22-结果">2.2 结果</a></li>
</ul>
</li>
<li><a href="#3-架构组件的作用">3. 架构组件的作用</a><ul>
<li><a href="#31-宽度和深度">3.1 宽度和深度</a><ul>
<li><a href="#表-3-宽度和深度的作用">表 3: 宽度和深度的作用</a></li>
</ul>
</li>
<li><a href="#32-批归一化batch-normalization-bn">3.2 批归一化（Batch Normalization, BN）</a></li>
<li><a href="#表-4-不同组件在-split-cifar-100-基准上的作用">表 4: 不同组件在 Split CIFAR-100 基准上的作用</a></li>
<li><a href="#33-跳跃连接skip-connections">3.3 跳跃连接（Skip Connections）</a></li>
<li><a href="#34-池化层pooling-layers">3.4 池化层（Pooling Layers）</a></li>
<li><a href="#35-全局池化层global-pooling-layers">3.5 全局池化层（Global Pooling Layers）</a><ul>
<li><a href="#表-5-gap-在-split-cifar-100-中的作用">表 5: GAP 在 Split CIFAR-100 中的作用</a></li>
</ul>
</li>
<li><a href="#36-注意力头attention-heads">3.6 注意力头（Attention Heads）</a><ul>
<li><a href="#表-6-注意力头在-split-cifar-100-中的作用">表 6: 注意力头在 Split CIFAR-100 中的作用</a></li>
</ul>
</li>
<li><a href="#37-架构的改进">3.7 架构的改进</a><ul>
<li><a href="#表-7-改进-cnn-和-resnet-架构在-split-cifar-100-和-imagenet-1k-基准上的性能">表 7: 改进 CNN 和 ResNet 架构在 Split CIFAR-100 和 ImageNet-1K 基准上的性能</a></li>
</ul>
</li>
<li><a href="#4-相关工作">4. 相关工作</a><ul>
<li><a href="#41-算法">4.1 算法</a></li>
<li><a href="#42-架构">4.2 架构</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>

            </div>
        </aside>

        <!-- Main Content -->
        <main class="main-content">
            <article>
                <header class="post-header">
                    <a href="../../../../index.html" class="back-link">
                        <i class="fas fa-arrow-left"></i> 返回博客列表
                    </a>
                    <h1>Untitled</h1>
                    <div class="post-meta">
                        <span><i class="fas fa-calendar-alt"></i> 2026-01-28</span>
                        <span><i class="fas fa-folder"></i> AINotes/40.CIL/00.Survey</span>
                        <span><i class="fas fa-user"></i> Hongwei Zhao</span>
                    </div>
                    <div class="tags">
                        
                    </div>
                </header>

                <div class="post-content">
                    <h2 id="0-摘要">0. 摘要<a class="anchor-link" href="#0-摘要" title="Permanent link">&para;</a></h2>
<p>在持续学习（Continual Learning）领域，大量研究致力于通过设计能够应对分布变化的新算法，来克服神经网络的灾难性遗忘问题。然而，这些研究大多仅专注于为“固定的神经网络架构”开发新的算法，并在很大程度上忽略了使用不同架构的影响。即便是少数修改模型的持续学习方法，也假定架构固定，并试图开发一种算法以在整个学习过程中高效利用该模型。  </p>
<p>在这项工作中，我们展示了架构选择会显著影响持续学习的性能，不同架构在记住先前任务和学习新任务的能力之间存在不同的权衡。此外，我们研究了各种架构决策的影响，并提出了一些最佳实践和建议，可以改善持续学习的性能。  </p>
<hr />
<h2 id="1-引言">1. 引言<a class="anchor-link" href="#1-引言" title="Permanent link">&para;</a></h2>
<p>持续学习（Continual Learning, CL）【1, 2】是机器学习的一个分支，在该领域中，模型会依次接触到一系列任务，期望利用现有知识快速适应新任务。在过去的几年里，持续学习的研究得到了快速发展，研究重点是开发能够缓解灾难性遗忘【3】的新算法——当模型在训练新任务时，会突然遗忘对先前任务的知识。  </p>
<p>虽然大多数持续学习的研究都专注于开发在数据流上比简单微调更优的学习算法，但据我们所知，模型架构在其中的角色并未在现有工作中得到明确的研究。即使是参数隔离或扩展方法【4,5】，它们也只是在某种程度上关注模型架构，假设特定架构的前提下开发操作该架构的算法。与此类算法设计方向不同，我们的动机是揭示不同架构组件所引入的归纳偏置对持续学习的重要性。  </p>
<p>为了说明这一点，考虑在 Split CIFAR-100 数据集上使用 ResNet-18 模型的场景，其中 CIFAR-100 数据集被划分为 20 个互不重叠的子集——这是现有持续学习研究中常用的架构和基准。  </p>
<p>图 1a 显示了显式设计的持续学习算法，如 EWC【6】（基于参数正则化的方法）和经验重放【7】（基于内存的持续学习算法），确实改善了相对于简单微调的性能。然而，可以看到，通过简单地从 ResNet-18 中移除全局平均池化（Global Average Pooling, GAP）层并进行简单的微调，可以在此基准上实现类似或更好的性能。这清楚地表明，我们需要更好地理解网络架构在持续学习中的作用。  </p>
<p>简而言之，在这项工作中，我们对持续学习中的架构决策影响进行了深入研究。我们的实验表明，现代神经网络的不同组件对持续学习相关指标（即平均准确率、遗忘率和学习准确率，详见第 2.1.2 节）有不同的影响——到这种程度，使用经过修改的组件的普通微调方法可以在不显著增加参数数量的情况下，达到或超过在基础架构上专门设计的持续学习方法的性能。  </p>
<p>我们总结了主要贡献如下：  </p>
<ul>
<li>我们比较了流行架构在学习和保持能力方面的表现。据我们所知，架构在持续学习中的重要性此前尚未被探讨过。  </li>
<li>我们研究了个别架构决策（例如宽度和深度、批归一化、跳跃连接和池化层）的作用，以及它们如何影响持续学习性能。  </li>
<li>我们展示了，在某些情况下，仅通过修改架构就可以实现类似甚至优于基于固定基础架构的持续学习算法的性能。  </li>
<li>除了标准的持续学习基准（如 Rotated MNIST 和 Split CIFAR-100），我们还在一个复杂度更高的 Split ImageNet-1K 基准上报告了结果，以确保我们的结论在更复杂的环境中依然成立。  </li>
<li>受我们的发现启发，我们提供了一些计算成本低的实用建议，可以改善各种架构在持续学习中的表现。  </li>
</ul>
<p>我们强调，这项工作的主要目标是说明架构决策在持续学习中的重要性，这并不意味着算法方面不重要。事实上，正如附录 B 中所讨论的那样，人们可以同时享受在架构和算法两方面的改进。最后，我们指出，这项工作的次要目标是成为持续学习架构方面进一步研究的奠基石。我们希望未来的工作能够进一步深入分析本文未涵盖的主题，从而显著提高我们对持续学习的理解。  </p>
<h2 id="2-比较架构">2. 比较架构<a class="anchor-link" href="#2-比较架构" title="Permanent link">&para;</a></h2>
<h3 id="21-实验设置">2.1 实验设置<a class="anchor-link" href="#21-实验设置" title="Permanent link">&para;</a></h3>
<p>在本节中，我们简要介绍了实验设置，更多详细信息（如超参数、架构的具体细节以及实验设置选择的理由等）请参见附录 A。  </p>
<h4 id="211-持续学习设置">2.1.1 持续学习设置<a class="anchor-link" href="#211-持续学习设置" title="Permanent link">&para;</a></h4>
<p>我们在三个持续学习基准上进行了实验。Split CIFAR-100 包含 20 个任务，每个任务包含 5 个类别的数据（互不相交），我们在每个任务上训练 10 个周期。Split ImageNet-1K 包含 10 个任务，每个任务包括 ImageNet-1K 中的 100 个类别，并在每个任务上训练 60 个周期。最后，在一些实验中，我们使用了一个小型的 Rotated MNIST 基准，其包含 5 个任务，其中第一个任务是标准的 MNIST 数据集，随后的每个任务将前一任务的图像旋转 22.5 度。我们设计该 MNIST 设置的初衷是通过增加旋转角度，使任务之间的分布变化更大，从而使基准更具挑战性【8】。  </p>
<p>需要注意的是，Split CIFAR-100 和 Split ImageNet-1K 基准使用多头分类层，而 MNIST 基准使用单头分类层。因此，Split CIFAR-100 和 Split ImageNet-1K 属于任务增量学习（Task Incremental Learning）设定，而 Rotated MNIST 属于领域增量学习（Domain Incremental Learning）【9】。  </p>
<p>我们选用了文献中最常用的架构（无论是持续学习领域还是其他领域），并为每种架构指定了描述符。例如，MLP-N 表示具有宽度为 <span class="math-inline">N</span> 的隐藏层的全连接网络；卷积神经网络（CNN）用 CNN×N 表示，其中 <span class="math-inline">N</span> 是每层通道数量的倍数。除非另有说明，这些 CNN 模型仅包含卷积层（步幅为 2），后接一个全连接层用于分类。在 CIFAR-100 的实验中，我们使用三层卷积网络，而在 ImageNet-1K 实验中，我们使用六层卷积网络。此外，每当我们添加池化层时，会将卷积层的步幅改为 1，以保持特征的维度不变。  </p>
<p>标准 ResNet【10】模型以 ResNet-D 表示，其中 <span class="math-inline">D</span> 表示网络的深度；宽残差网络（WideResNet, WRN）以 WRN-D-N 表示，其中 <span class="math-inline">D</span> 和 <span class="math-inline">N</span> 分别表示深度和宽度。最后，我们还使用了最近提出的 Vision Transformer (ViT)【11】模型。在 ImageNet-1K 的实验中，我们采用原论文中的命名规范。然而，在 Split CIFAR-100 的实验中，我们使用了更小的 ViT 模型，其中 ViT N/M 表示具有 4 层结构、隐藏层大小为 <span class="math-inline">N</span>、MLP 尺寸为 <span class="math-inline">M</span> 的 ViT 模型。  </p>
<p>对于每种架构，我们在一个大的超参数网格中进行搜索，并报告最佳结果。此外，对于每个架构的最佳超参数设置，我们在 5 个不同的随机初始化上取平均值，并报告均值和标准差。最后，对于 Split CIFAR-100 和 Split ImageNet-1K 基准，我们在每次运行中随机打乱标签顺序，并进行 5 次重复实验，以确保结果不偏向特定的标签顺序。  </p>
<h4 id="212-评估指标">2.1.2 评估指标<a class="anchor-link" href="#212-评估指标" title="Permanent link">&para;</a></h4>
<p>我们希望从两个方面比较不同架构的性能：(1) 一个架构学习新任务的能力，即学习能力（Learning Ability）；(2) 一个架构保留先前知识的能力，即保持能力（Retention Ability）。为此，我们记录以下指标：  </p>
<ol>
<li>
<p><strong>平均准确率</strong> <span class="math-inline">(\text{Average Accuracy}, A_T) \in [0, 100]</span>（值越高越好）：在模型完成 <span class="math-inline">T</span> 个任务的持续学习后，其平均验证准确率定义为：<br />
<div class="math-display"><br />
    A_T = \frac{1}{T} \sum_{i=1}^{T} a_{T, i},<br />
</div><br />
其中，<span class="math-inline">a_{T, i}</span> 是模型完成第 <span class="math-inline">t</span> 个任务后，在第 <span class="math-inline">i</span> 个任务数据集上的验证准确率。</p>
</li>
<li>
<p><strong>学习准确率</strong> <span class="math-inline">(\text{Learning Accuracy}, L_A) \in [0, 100]</span>（值越高越好）：每个任务在完成学习后直接得到的准确率。学习准确率是评估模型塑性（Plasticity）的良好代表，可通过以下公式计算：<br />
<div class="math-display"><br />
    L_A = \frac{1}{T} \sum_{i=1}^{T} a_{i, i}.<br />
</div><br />
注意，对于 Split CIFAR-100 和 Split ImageNet-1K 基准，由于任务包含不相交的标签，指标的标准差可能较高。此外，由于所有模型从零开始训练，第一个任务的学习准确率通常低于后续任务。</p>
</li>
<li>
<p><strong>联合准确率</strong> <span class="math-inline">(\text{Joint Accuracy}) \in [0, 100]</span>（值越高越好）：模型在所有任务的数据上同时训练时的准确率。</p>
</li>
<li>
<p><strong>平均遗忘率</strong> <span class="math-inline">(\text{Average Forgetting}, F) \in [-100, 100]</span>（值越低越好）：平均遗忘率是指在持续学习完成后，每个任务的峰值准确率与最终准确率之间的差异。对于包含 <span class="math-inline">T</span> 个任务的持续学习基准，其定义如下：<br />
<div class="math-display"><br />
    F = \frac{1}{T-1} \sum_{i=1}^{T-1} \max_{t \in {1, \dots, T-1}} (a_{t, i} - a_{T, i}).<br />
</div></p>
</li>
</ol>
<hr />
<h3 id="22-结果">2.2 结果<a class="anchor-link" href="#22-结果" title="Permanent link">&para;</a></h3>
<p>我们首先比较了不同架构在 Split CIFAR-100 和 Split ImageNet-1K 基准上的表现。本节主要关注不同架构在学习和保持能力方面的表现，而对架构间性能差距的解释以及不同架构组件的分析将在下一节讨论。  </p>
<p>表 1 列出了不同架构在 Split CIFAR-100 基准上的性能。可以从表中观察到以下几点：  </p>
<ol>
<li>
<p>非常简单的 CNN（在单任务图像分类任务中不是最先进的架构）在平均准确率和遗忘率方面显著优于 ResNet、WRN 和 ViT。这一结论在所有架构的不同宽度和深度配置下均成立。类似的趋势在图 1b 和图 1c 中也可以看到，即简单 CNN 在给定参数数量的情况下优于其他架构。  </p>
</li>
<li>
<p>单纯增加参数数量（无论是架构内还是架构间）并不一定能提升持续学习性能。例如，ResNet-18 和 ResNet-34 的参数数量相差近一倍，但它们的性能几乎相同。类似地，WRN-10-10 优于 WRN-16-10 和 WRN-28-10，即使后两者的参数数量显著增加。  </p>
</li>
<li>
<p>比较不同架构的学习和保持能力时可以发现，ResNet 和 WRN 的学习准确率更高，表明它们在学习新任务方面表现更好。这也解释了它们在单任务环境中的广泛使用。然而，在保持能力方面，CNN 和 ViT 更出色，其较低的遗忘率得以证明这一点。  </p>
</li>
</ol>
<p>从表 1 中可以进一步总结出以下结论：  </p>
<p>虽然 ResNet 和 WRN 在前几个任务上表现出更高的学习能力（即较高的学习准确率），但随着任务数量的增加，CNN 因其较低的遗忘率逐渐在整体性能上占据优势，最终表现为更平坦的平均准确率曲线（如图 2a 中的 CIFAR-100 和图 2b 中的 ImageNet-1K 所示）。  </p>
<p>对于 ImageNet-1K 基准（见表 2），我们观察到类似的趋势。然而，与 CIFAR-100 相比，在平均准确率上，CNN 与其他架构之间的性能差异较小。这可能是因为在此基准下，其他架构的学习准确率明显更高，从而提升了最终的平均准确率。然而，CNN 的平均遗忘率仍显著低于其他架构。  </p>
<p>总的来说，从表 1 和表 2 中，我们可以得出结论：ResNet 和 WRN 的学习能力较强，而 CNN 和 ViT 的保持能力较强。在我们的实验中，简单的 CNN 在学习和保持能力之间达到了最佳的平衡。  </p>
<hr />
<h2 id="3-架构组件的作用">3. 架构组件的作用<a class="anchor-link" href="#3-架构组件的作用" title="Permanent link">&para;</a></h2>
<p>接下来，我们研究了各种架构中的独立组件，以了解它们如何影响持续学习性能。我们从所有架构的通用结构特性（例如宽度和深度）入手（参见 3.1 节），发现宽度的增加可以显著降低遗忘率。在 3.2 节，我们研究了批归一化（Batch Normalization, BN）的作用，观察到它可以显著提高持续学习中的学习准确率。然后，在 3.3 节中，我们发现将跳跃连接（Skip Connection）添加到 CNN 并不一定能改善持续学习性能，而在 3.4 节和 3.5 节中发现，池化层（尤其是最大池化）对学习准确率和遗忘率具有显著影响。此外，在 3.6 节中，我们简要探讨了 ViT 的注意力头（Attention Heads）的影响。最后，在 3.7 节中，我们基于上述章节的观察总结了一些改进架构的方法，这些方法可以在 Split CIFAR-100 和 ImageNet-1K 基准上提升架构性能。  </p>
<hr />
<h3 id="31-宽度和深度">3.1 宽度和深度<a class="anchor-link" href="#31-宽度和深度" title="Permanent link">&para;</a></h3>
<p>近期研究表明，宽神经网络在灾难性遗忘方面表现较好【12】。在此，我们通过更广泛的架构和基准验证了这一结论。  </p>
<p>表 3 显示了宽度和深度的作用：增加参数数量（通过增加宽度）能够降低遗忘率，从而提高平均准确率。然而，增加深度并不一定改善性能，因此需要区分通过增加深度和宽度来扩展模型的效果。  </p>
<h4 id="表-3-宽度和深度的作用">表 3: 宽度和深度的作用<a class="anchor-link" href="#表-3-宽度和深度的作用" title="Permanent link">&para;</a></h4>
<table>
<thead>
<tr>
<th>基准</th>
<th>模型</th>
<th>深度</th>
<th>参数（M）</th>
<th>平均准确率（%）</th>
<th>平均遗忘率（%）</th>
<th>学习准确率（%）</th>
</tr>
</thead>
<tbody>
<tr>
<td>Rot MNIST</td>
<td>MLP-128</td>
<td>2</td>
<td>0.1</td>
<td>70.8 ± 0.68</td>
<td>31.5 ± 0.92</td>
<td>96.0 ± 0.90</td>
</tr>
<tr>
<td>Rot MNIST</td>
<td>MLP-128</td>
<td>8</td>
<td>0.2</td>
<td>68.9 ± 1.07</td>
<td>35.4 ± 1.34</td>
<td>97.3 ± 0.76</td>
</tr>
<tr>
<td>Rot MNIST</td>
<td>MLP-512</td>
<td>2</td>
<td>0.7</td>
<td>72.6 ± 0.27</td>
<td>29.6 ± 0.36</td>
<td>96.4 ± 0.73</td>
</tr>
</tbody>
</table>
<p>从表中可以看出，增加宽度（如将 MLP 的宽度从 128 增加到 512）能够显著改善所有指标的性能。而对于相同的宽度（如 MLP-128 和 MLP-256），增加深度（从 2 增加到 8）反而导致平均准确率下降、平均遗忘率增加，同时学习准确率的提升非常有限。  </p>
<p>在表 3 的进一步分析中，我们可以看到，对于 MLP-256（深度为 8）和 MLP-512（深度为 2），它们的参数数量相近。然而，在宽度较大的情况下（即 MLP-512，深度较浅），持续学习性能显著优于宽度较小但深度较大的网络。  </p>
<p>对于 ResNet 和 WideResNet（WRN）的类似分析在表 1 中得以体现。ResNet-50 和 ResNet-101 的宽度是 ResNet-18 和 ResNet-34 的四倍。从表中可以看出，宽度的增加导致了平均准确率的显著提升，同时遗忘率显著降低。同样，WRN 的宽网络（如 WRN-10-10、WRN-16-10 和 WRN-28-10）在性能上优于窄网络（如 WRN-10-2 和 WRN-16-2）。然而，如果保持宽度不变，仅增加深度，并不能显著改善性能。  </p>
<p>总的来说，我们得出结论，通过增加网络的宽度进行过参数化（Over-parameterization）可以显著改善持续学习性能，而类似的结论并不能适用于深度的增加。  </p>
<p>这种现象可以通过以下机制进行解释：宽网络能够激活“懒惰训练”（Lazy Training）模式，促进梯度正交化以及由宽度增加引起的稀疏化【12】。受此观察启发，我们在后续章节中展示了为什么全局平均池化（GAP）层会对持续学习性能产生不良影响，以及如何通过调整这些层来缓解这种影响。  </p>
<hr />
<h3 id="32-批归一化batch-normalization-bn">3.2 批归一化（Batch Normalization, BN）<a class="anchor-link" href="#32-批归一化batch-normalization-bn" title="Permanent link">&para;</a></h3>
<p>批归一化（Batch Normalization, BN）【13】是一种归一化方法，已被证明可以通过优化和泛化优势来提高网络的收敛速度【14, 15】。BN 层的另一个优势在于其能够减少协变量偏移（Covariate Shift）问题，而这一问题在持续学习中尤为重要，因为数据分布可能会随任务的变化而变化。  </p>
<p>尽管批归一化在持续学习中的作用并未被广泛研究，但现有的研究表明 BN 可以显著改善学习能力。例如，Mirzadeh 等人【12】通过泛化视角分析了 BN 在持续学习中的作用；Pham 等人【16】研究了不同归一化方法在持续学习中的表现，并表明 BN 能够促进任务间知识的转移，尤其是在存在重放缓冲区的情况下，相比于其他归一化方法（如组归一化 Group Normalization【17】）表现更优。  </p>
<p>然而，从直觉上看，由于持续学习中数据分布会随任务变化，BN 统计可能会因此发生变化，而没有为每个任务保存统计信息的情况下，这可能会加剧遗忘。但我们的实验发现，并非在所有情况下都是如此。例如，在 Split CIFAR-100 和 Split ImageNet-1K 基准中，我们发现 BN 能够显著提升模型的学习准确率（见表 4 和表 7）。  </p>
<p>我们推测，这可能是因为这些数据集中的 BN 统计在持续学习过程中相对稳定。为验证这一假设，我们在附录 B.2 中绘制了 CNN×4 的第一层 BN 统计（在 Split CIFAR-100 数据集上的表现），并显示 BN 统计在持续学习中保持稳定。然而，如果输入分布变化较大（例如 Permuted MNIST 基准，见附录 B.3），则 BN 统计会发生较大变化，导致持续学习性能下降（表现在遗忘率显著增加）。  </p>
<p>总体而言，我们得出结论：BN 层的效果取决于数据分布。在输入分布相对稳定的设置下（如 Split CIFAR-100 和 Split ImageNet-1K），BN 层通过提高模型的学习能力来改善持续学习性能。而在输入分布变化较大的设置下（如 Permuted MNIST），BN 层可能会因增加遗忘率而对持续学习性能产生负面影响。  </p>
<h3 id="表-4-不同组件在-split-cifar-100-基准上的作用">表 4: 不同组件在 Split CIFAR-100 基准上的作用<a class="anchor-link" href="#表-4-不同组件在-split-cifar-100-基准上的作用" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>模型</th>
<th>参数数量（M）</th>
<th>平均准确率（%）</th>
<th>平均遗忘率（%）</th>
<th>学习准确率（%）</th>
<th>联合准确率（%）</th>
</tr>
</thead>
<tbody>
<tr>
<td>CNN ×4</td>
<td>2.3</td>
<td>68.1 ± 0.5</td>
<td>8.7 ± 0.21</td>
<td>76.4 ± 6.92</td>
<td>73.4 ± 0.89</td>
</tr>
<tr>
<td>CNN ×4 + Skip</td>
<td>2.4</td>
<td>68.2 ± 0.56</td>
<td>8.9 ± 0.72</td>
<td>76.6 ± 7.07</td>
<td>73.8 ± 0.47</td>
</tr>
<tr>
<td>CNN ×4 + BN</td>
<td>2.3</td>
<td>74.0 ± 0.56</td>
<td>8.1 ± 0.35</td>
<td>81.7 ± 6.68</td>
<td>80.2 ± 0.16</td>
</tr>
<tr>
<td>CNN ×4 + AvgPool</td>
<td>2.3</td>
<td>68.5 ± 0.6</td>
<td>8.3 ± 0.57</td>
<td>76.3 ± 7.63</td>
<td>73.6 ± 0.83</td>
</tr>
<tr>
<td>CNN ×4 + MaxPool</td>
<td>2.3</td>
<td>74.4 ± 0.34</td>
<td>9.3 ± 0.47</td>
<td>83.3 ± 6.1</td>
<td>79.9 ± 0.53</td>
</tr>
<tr>
<td>CNN ×4 + 全部</td>
<td>2.4</td>
<td>77.7 ± 0.77</td>
<td>6.5 ± 0.58</td>
<td>83.7 ± 6.31</td>
<td>81.6 ± 0.77</td>
</tr>
</tbody>
</table>
<p>从表 4 可以看出：<br />
1. 添加跳跃连接（Skip Connection）对性能的影响不大。<br />
2. 添加批归一化（BN）显著提高了学习准确率和平均准确率，同时对遗忘率的影响较小。<br />
3. 添加最大池化（MaxPool）显著提高了学习准确率，而平均遗忘率略有增加。<br />
4. 同时添加所有组件（Skip、BN 和 MaxPool）带来了最佳性能，显著提高了学习能力并减少了遗忘率。  </p>
<hr />
<h3 id="33-跳跃连接skip-connections">3.3 跳跃连接（Skip Connections）<a class="anchor-link" href="#33-跳跃连接skip-connections" title="Permanent link">&para;</a></h3>
<p>跳跃连接最初由 He 等人【18】为卷积网络提出，并已被广泛应用于 ResNet 架构以及其他模型（如 Transformer）中。许多研究试图解释跳跃连接的作用：<br />
- Hardt 和 Ma【19】指出跳跃连接可以消除伪局部最优解。<br />
- Bartlett 等人【20】研究了残差网络的函数表达能力。<br />
- Jastrzebski 等人【21】表明跳跃连接能够迭代性地优化学习到的表示。  </p>
<p>然而，这些工作主要集中在单任务学习的场景。在持续学习中，由于存在分布变化，跳跃连接的这些优势是否仍然显著尚不清楚。  </p>
<p>我们通过实验研究了跳跃连接在持续学习中的作用。正如表 4 所示，将跳跃连接添加到简单 CNN 并未显著改变性能，其结果在标准差范围内几乎一致。因此，我们得出结论，跳跃连接在我们研究的持续学习基准上并未显著影响模型性能。  </p>
<hr />
<h3 id="34-池化层pooling-layers">3.4 池化层（Pooling Layers）<a class="anchor-link" href="#34-池化层pooling-layers" title="Permanent link">&para;</a></h3>
<p>池化层是早期 CNN 性能改进的重要组成部分，在 ResNet 出现之前非常流行。池化层不仅通过引入局部平移不变性帮助分类任务【22】，还通过降低特征的空间分辨率减少了计算成本。由于我们研究的部分架构是纯卷积 CNN，因此我们重新考察了池化层在持续学习场景中的作用。  </p>
<p>我们在表 4 中比较了没有池化层的 CNN（CNN×N）和添加池化层（如平均池化或最大池化）的 CNN。结果表明：<br />
1. 添加平均池化（AvgPool）对持续学习的指标影响较小。<br />
2. 添加最大池化（MaxPool）显著提升了学习能力（学习准确率显著提高）。<br />
3. 在保持能力（遗忘率）方面，池化层的作用相对较小。  </p>
<p>总体而言，最大池化通过增强模型的学习能力在平均准确率方面表现最佳。  </p>
<h3 id="35-全局池化层global-pooling-layers">3.5 全局池化层（Global Pooling Layers）<a class="anchor-link" href="#35-全局池化层global-pooling-layers" title="Permanent link">&para;</a></h3>
<p>全局平均池化（Global Average Pooling, GAP）层通常用于卷积网络的最终分类层之前，以减少分类器中的参数数量。添加 GAP 层的直接效果是减少最终分类器的宽度。然而，正如第 3.1 节所述，网络的宽度减少会导致更高的遗忘率。因此，包含 GAP 层的架构可能会在持续学习中表现出更高的遗忘率。  </p>
<p>表 5 验证了这一直觉。从表中可以看到，添加 GAP 层显著增加了遗忘率，从而降低了平均准确率。然而，为了证明 GAP 层本身并不是问题，而是由于最终分类器宽度减少所导致，我们设计了一个对比实验：通过将最后一个卷积层的通道数增加 16 倍后再应用 GAP，这种网络被标记为 “CNN ×4 (16x) + GAP”。从表中可以看到，这种架构的遗忘率显著降低，说明 GAP 层的影响与最终分类器的宽度直接相关。  </p>
<h4 id="表-5-gap-在-split-cifar-100-中的作用">表 5: GAP 在 Split CIFAR-100 中的作用<a class="anchor-link" href="#表-5-gap-在-split-cifar-100-中的作用" title="Permanent link">&para;</a></h4>
<table>
<thead>
<tr>
<th>模型</th>
<th>参数数量（M）</th>
<th>最终分类器宽度</th>
<th>平均准确率（%）</th>
<th>平均遗忘率（%）</th>
<th>学习准确率（%）</th>
<th>联合准确率（%）</th>
</tr>
</thead>
<tbody>
<tr>
<td>CNN ×4</td>
<td>2.3</td>
<td>8192</td>
<td>68.1 ± 0.5</td>
<td>8.7 ± 0.21</td>
<td>76.4 ± 6.92</td>
<td>73.4 ± 0.89</td>
</tr>
<tr>
<td>CNN ×4 + GAP</td>
<td>1.5</td>
<td>512</td>
<td>60.1 ± 0.43</td>
<td>14.3 ± 0.8</td>
<td>66.1 ± 7.76</td>
<td>76.9 ± 0.81</td>
</tr>
<tr>
<td>CNN ×4 (16x) + GAP</td>
<td>32.3</td>
<td>8192</td>
<td>73.6 ± 0.39</td>
<td>5.2 ± 0.66</td>
<td>75.6 ± 4.77</td>
<td>77.9 ± 0.37</td>
</tr>
<tr>
<td>CNN ×8</td>
<td>7.5</td>
<td>16384</td>
<td>69.9 ± 0.62</td>
<td>8.0 ± 0.71</td>
<td>77.5 ± 6.78</td>
<td>74.1 ± 0.83</td>
</tr>
<tr>
<td>CNN ×8 + GAP</td>
<td>6.1</td>
<td>1024</td>
<td>63.1 ± 2.0</td>
<td>14.7 ± 1.68</td>
<td>70.1 ± 7.18</td>
<td>78.3 ± 0.97</td>
</tr>
<tr>
<td>CNN ×16</td>
<td>26.9</td>
<td>32768</td>
<td>76.8 ± 0.76</td>
<td>4.7 ± 0.84</td>
<td>81.0 ± 6.97</td>
<td>74.6 ± 0.86</td>
</tr>
<tr>
<td>CNN ×16 + GAP</td>
<td>23.8</td>
<td>2048</td>
<td>66.3 ± 0.82</td>
<td>12.2 ± 0.65</td>
<td>72.3 ± 6.02</td>
<td>78.9 ± 0.27</td>
</tr>
</tbody>
</table>
<p>受此观察启发，我们在第 3.7 节中进一步展示了通过移除 GAP 层或用较小的平均池化层替代 GAP 层，可以显著提高 ResNet 在持续学习中的性能。  </p>
<hr />
<h3 id="36-注意力头attention-heads">3.6 注意力头（Attention Heads）<a class="anchor-link" href="#36-注意力头attention-heads" title="Permanent link">&para;</a></h3>
<p>注意力机制是 Transformer 架构中一个重要的组成部分，在自然语言处理和计算机视觉任务中取得了巨大的成功。对于后者，Vision Transformers (ViTs) 的注意力头被证明可以同时捕捉图像的局部和全局特征【23】。  </p>
<p>在本节中，我们通过将 ViT 中的注意力头数量加倍，同时保持网络宽度不变，以确保结果的变化不受表示维度增加的影响。表 6 显示了实验结果。从表中可以看出，即使将 ViT 的注意力头数量加倍，也仅在学习准确率和遗忘率方面带来了微小的改善。这表明，通过增加注意力头数量来提升 ViT 的持续学习性能并不是一种高效的方式。  </p>
<h4 id="表-6-注意力头在-split-cifar-100-中的作用">表 6: 注意力头在 Split CIFAR-100 中的作用<a class="anchor-link" href="#表-6-注意力头在-split-cifar-100-中的作用" title="Permanent link">&para;</a></h4>
<table>
<thead>
<tr>
<th>模型</th>
<th>注意力头数量</th>
<th>参数数量（M）</th>
<th>平均准确率（%）</th>
<th>平均遗忘率（%）</th>
<th>学习准确率（%）</th>
</tr>
</thead>
<tbody>
<tr>
<td>ViT 512/1024</td>
<td>4</td>
<td>8.8</td>
<td>50.9 ± 0.73</td>
<td>23.8 ± 1.3</td>
<td>72.8 ± 6.13</td>
</tr>
<tr>
<td>ViT 512/1024</td>
<td>8</td>
<td>8.8</td>
<td>51.7 ± 1.4</td>
<td>21.9 ± 1.3</td>
<td>71.4 ± 5.52</td>
</tr>
<tr>
<td>ViT 1024/1536</td>
<td>4</td>
<td>30.7</td>
<td>57.4 ± 1.59</td>
<td>14.4 ± 1.96</td>
<td>66.0 ± 5.89</td>
</tr>
<tr>
<td>ViT 1024/1536</td>
<td>8</td>
<td>30.7</td>
<td>60.4 ± 1.56</td>
<td>12.2 ± 1.12</td>
<td>67.4 ± 5.57</td>
</tr>
</tbody>
</table>
<p>尽管如此，与现有文献的其他观察一致【24】，ViT 对分布变化表现出一定的鲁棒性，从而在 Split CIFAR-100 基准上以较少的参数实现了较低的遗忘率（参见图 1c）。  </p>
<h3 id="37-架构的改进">3.7 架构的改进<a class="anchor-link" href="#37-架构的改进" title="Permanent link">&para;</a></h3>
<p>基于前述各节的观察，我们提出了一些改进架构性能的实用建议，这些建议可直接应用于持续学习任务中。  </p>
<p>对于 CNN，我们建议添加以下组件：<br />
- <strong>批归一化（Batch Normalization, BN）：</strong> 它能够显著提升模型的学习能力。<br />
- <strong>最大池化（Max Pooling）：</strong> 最大池化增强了特征提取能力，进而提高学习准确率。<br />
- <strong>跳跃连接（Skip Connections）：</strong> 跳跃连接虽然对持续学习性能的改善不显著，但在优化问题中提供了一定的便利。  </p>
<p>表 7 显示了在 CIFAR-100 和 ImageNet-1K 基准上添加这些组件后 CNN 的改进结果。结果表明，添加这些组件显著提高了 CNN 的性能，在几乎所有指标上都有所改善。  </p>
<p>对于 ResNet，我们建议：<br />
- <strong>移除全局平均池化层（GAP）：</strong> 在 CIFAR-100 基准中完全移除 GAP。<br />
- <strong>局部平均池化替代 GAP：</strong> 在 ImageNet-1K 基准中，用 4×4 的局部平均池化替代 GAP。这是因为在 ImageNet-1K 中完全移除 GAP 会显著增加分类器层的参数数量。  </p>
<p>表 7 中可以看到，无论是完全移除 GAP（CIFAR-100）还是部分替代 GAP（ImageNet-1K），都显著改善了 ResNet 的保持能力，从而降低了遗忘率。  </p>
<h4 id="表-7-改进-cnn-和-resnet-架构在-split-cifar-100-和-imagenet-1k-基准上的性能">表 7: 改进 CNN 和 ResNet 架构在 Split CIFAR-100 和 ImageNet-1K 基准上的性能<a class="anchor-link" href="#表-7-改进-cnn-和-resnet-架构在-split-cifar-100-和-imagenet-1k-基准上的性能" title="Permanent link">&para;</a></h4>
<table>
<thead>
<tr>
<th>模型</th>
<th>基准</th>
<th>参数数量（M）</th>
<th>平均准确率（%）</th>
<th>平均遗忘率（%）</th>
<th>学习准确率（%）</th>
</tr>
</thead>
<tbody>
<tr>
<td>CNN ×4</td>
<td>CIFAR-100</td>
<td>2.3</td>
<td>68.1 ± 0.5</td>
<td>8.7 ± 0.21</td>
<td>76.4 ± 6.92</td>
</tr>
<tr>
<td>CNN ×4 + BN + MaxPool + Skip</td>
<td>CIFAR-100</td>
<td>1.5</td>
<td>77.7 ± 0.77</td>
<td>6.5 ± 0.58</td>
<td>83.7 ± 6.31</td>
</tr>
<tr>
<td>CNN ×8</td>
<td>CIFAR-100</td>
<td>7.5</td>
<td>69.9 ± 0.62</td>
<td>8.0 ± 0.71</td>
<td>77.5 ± 6.78</td>
</tr>
<tr>
<td>CNN ×8 + BN + MaxPool + Skip</td>
<td>CIFAR-100</td>
<td>6.1</td>
<td>78.1 ± 1.15</td>
<td>5.7 ± 0.36</td>
<td>83.3 ± 6.27</td>
</tr>
<tr>
<td>CNN ×3</td>
<td>ImageNet-1K</td>
<td>9.1</td>
<td>63.3 ± 0.68</td>
<td>5.8 ± 0.93</td>
<td>71.6 ± 2.31</td>
</tr>
<tr>
<td>CNN ×3 + BN + MaxPool + Skip</td>
<td>ImageNet-1K</td>
<td>9.1</td>
<td>66.4 ± 0.47</td>
<td>5.4 ± 0.3</td>
<td>74.7 ± 2.1</td>
</tr>
<tr>
<td>ResNet-18</td>
<td>CIFAR-100</td>
<td>11.2</td>
<td>45.0 ± 0.63</td>
<td>36.8 ± 1.08</td>
<td>74.9 ± 3.98</td>
</tr>
<tr>
<td>ResNet-18 w/o GAP</td>
<td>CIFAR-100</td>
<td>11.9</td>
<td>67.4 ± 0.76</td>
<td>11.2 ± 1.98</td>
<td>74.2 ± 4.79</td>
</tr>
<tr>
<td>ResNet-34</td>
<td>ImageNet-1K</td>
<td>21.8</td>
<td>62.7 ± 0.53</td>
<td>19.0 ± 0.67</td>
<td>80.4 ± 2.57</td>
</tr>
<tr>
<td>ResNet-34 w 4×4 AvgPool</td>
<td>ImageNet-1K</td>
<td>23.3</td>
<td>66.0 ± 0.24</td>
<td>4.2 ± 0.16</td>
<td>70.2 ± 3.87</td>
</tr>
</tbody>
</table>
<hr />
<h3 id="4-相关工作">4. 相关工作<a class="anchor-link" href="#4-相关工作" title="Permanent link">&para;</a></h3>
<p>与现有工作不同，我们的研究关注于持续学习中的架构设计，而非算法设计。因此，我们从以下两个方面回顾相关文献：  </p>
<h4 id="41-算法">4.1 算法<a class="anchor-link" href="#41-算法" title="Permanent link">&para;</a></h4>
<p>大多数持续学习的研究集中在算法层面，提出了多种方法以缓解灾难性遗忘。例如，正则化方法通过保存重要参数信息来减小遗忘【25】；重放方法通过保留小部分以前任务的数据或生成器以改善新任务学习【26】；参数隔离方法通过为每个任务分配模型的一部分来降低任务间干扰【27】。  </p>
<h4 id="42-架构">4.2 架构<a class="anchor-link" href="#42-架构" title="Permanent link">&para;</a></h4>
<p>少量研究将架构搜索引入持续学习【28, 29】，但其关注点主要在于如何高效共享或扩展模型，而没有深入讨论具体架构决策对持续学习的影响。我们的研究填补了这一空白，系统地探讨了架构组件对持续学习性能的作用。  </p>
                </div>

                <!-- Comments Section (Giscus) -->
                <section class="comments-section">
                    <h3><i class="fas fa-comments"></i> 评论</h3>
                    <script src="https://giscus.app/client.js"
                        data-repo="Geeks-Z/Geeks-Z.github.io"
                        data-repo-id=""
                        data-category="Announcements"
                        data-category-id=""
                        data-mapping="pathname"
                        data-strict="0"
                        data-reactions-enabled="1"
                        data-emit-metadata="0"
                        data-input-position="bottom"
                        data-theme="preferred_color_scheme"
                        data-lang="zh-CN"
                        crossorigin="anonymous"
                        async>
                    </script>
                </section>
            </article>

            <footer class="post-footer">
                <p>© 2025 Hongwei Zhao. Built with ❤️</p>
            </footer>
        </main>
    </div>

    <!-- Theme Toggle Button -->
    <button class="theme-toggle" id="themeToggle" aria-label="切换主题">
        <i class="fas fa-moon"></i>
    </button>

    <script>
        // Theme Toggle
        const themeToggle = document.getElementById('themeToggle');
        const html = document.documentElement;
        const icon = themeToggle.querySelector('i');
        const hljsDark = document.getElementById('hljs-theme-dark');
        const hljsLight = document.getElementById('hljs-theme-light');
        
        // Check saved theme or system preference
        const savedTheme = localStorage.getItem('theme');
        const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
        
        if (savedTheme === 'dark' || (!savedTheme && prefersDark)) {
            html.setAttribute('data-theme', 'dark');
            icon.className = 'fas fa-sun';
            hljsDark.disabled = false;
            hljsLight.disabled = true;
        }
        
        themeToggle.addEventListener('click', () => {
            const isDark = html.getAttribute('data-theme') === 'dark';
            if (isDark) {
                html.removeAttribute('data-theme');
                icon.className = 'fas fa-moon';
                localStorage.setItem('theme', 'light');
                hljsDark.disabled = true;
                hljsLight.disabled = false;
            } else {
                html.setAttribute('data-theme', 'dark');
                icon.className = 'fas fa-sun';
                localStorage.setItem('theme', 'dark');
                hljsDark.disabled = false;
                hljsLight.disabled = true;
            }
            
            // Update Giscus theme
            const giscusFrame = document.querySelector('iframe.giscus-frame');
            if (giscusFrame) {
                giscusFrame.contentWindow.postMessage({
                    giscus: {
                        setConfig: {
                            theme: isDark ? 'light' : 'dark'
                        }
                    }
                }, 'https://giscus.app');
            }
        });
        
        // Highlight.js
        document.addEventListener('DOMContentLoaded', () => {
            hljs.highlightAll();
        });
        
        // KaTeX auto-render
        document.addEventListener('DOMContentLoaded', () => {
            if (typeof renderMathInElement !== 'undefined') {
                renderMathInElement(document.body, {
                    delimiters: [
                        {left: '$$', right: '$$', display: true},
                        {left: '$', right: '$', display: false},
                        {left: '\\[', right: '\\]', display: true},
                        {left: '\\(', right: '\\)', display: false}
                    ],
                    throwOnError: false
                });
            }
        });
        
        // TOC active state
        const tocLinks = document.querySelectorAll('.toc-container a');
        const headings = document.querySelectorAll('.post-content h2, .post-content h3, .post-content h4');
        
        function updateTocActive() {
            let current = '';
            headings.forEach(heading => {
                const rect = heading.getBoundingClientRect();
                if (rect.top <= 100) {
                    current = heading.getAttribute('id');
                }
            });
            
            tocLinks.forEach(link => {
                link.classList.remove('active');
                if (link.getAttribute('href') === '#' + current) {
                    link.classList.add('active');
                }
            });
        }
        
        window.addEventListener('scroll', updateTocActive);
        updateTocActive();
    </script>
</body>
</html>
