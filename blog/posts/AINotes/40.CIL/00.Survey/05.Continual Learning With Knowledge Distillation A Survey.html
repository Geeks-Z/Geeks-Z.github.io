<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Untitled</title>
    <meta name="description" content="Untitled - Hongwei Zhao's Blog">
    <meta name="author" content="Hongwei Zhao">
    
    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Noto+Sans+SC:wght@300;400;500;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    
    <!-- Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <!-- Code Highlighting -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css" id="hljs-theme-dark">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css" id="hljs-theme-light" disabled>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    
    <!-- KaTeX for Math -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>
    
    <style>
        :root {
            /* Light Theme - 明亮清新配色 */
            --primary-color: #4A90D9;
            --primary-hover: #3678C2;
            --link-color: #E86B5F;
            --text-color: #2D2D2D;
            --text-light: #5A5A5A;
            --text-muted: #8A8A8A;
            --bg-color: #FFFFFF;
            --bg-secondary: #F5F7FA;
            --bg-code: #F8F9FC;
            --border-color: #E8ECF0;
            --shadow: 0 2px 8px rgba(0,0,0,0.06);
            --shadow-lg: 0 8px 24px rgba(0,0,0,0.08);
        }

        [data-theme="dark"] {
            --primary-color: #5dade2;
            --primary-hover: #85c1e9;
            --link-color: #e74c3c;
            --text-color: #e5e7eb;
            --text-light: #9ca3af;
            --text-muted: #6b7280;
            --bg-color: #1a1a2e;
            --bg-secondary: #16213e;
            --bg-code: #0f0f23;
            --border-color: #374151;
            --shadow: 0 1px 3px rgba(0,0,0,0.3);
            --shadow-lg: 0 4px 15px rgba(0,0,0,0.4);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            scroll-behavior: smooth;
        }

        body {
            font-family: 'Inter', 'Noto Sans SC', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            font-size: 16px;
            line-height: 1.8;
            color: var(--text-color);
            background: var(--bg-color);
            transition: background-color 0.3s, color 0.3s;
        }

        a {
            color: var(--primary-color);
            text-decoration: none;
            transition: color 0.2s;
        }

        a:hover {
            color: var(--primary-hover);
            text-decoration: underline;
        }

        /* Layout */
        .page-wrapper {
            display: flex;
            max-width: 1400px;
            margin: 0 auto;
            padding: 2rem;
            gap: 3rem;
        }

        /* Sidebar TOC */
        .toc-sidebar {
            width: 260px;
            flex-shrink: 0;
            position: sticky;
            top: 2rem;
            height: fit-content;
            max-height: calc(100vh - 4rem);
            overflow-y: auto;
        }

        .toc-container {
            background: var(--bg-secondary);
            border-radius: 12px;
            padding: 1.5rem;
            border: 1px solid var(--border-color);
        }

        .toc-container h3 {
            font-size: 0.85rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-muted);
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .toc-container ul {
            list-style: none;
        }

        .toc-container li {
            margin-bottom: 0.5rem;
        }

        .toc-container a {
            font-size: 0.9rem;
            color: var(--text-light);
            display: block;
            padding: 0.25rem 0;
            border-left: 2px solid transparent;
            padding-left: 0.75rem;
            transition: all 0.2s;
        }

        .toc-container a:hover,
        .toc-container a.active {
            color: var(--primary-color);
            border-left-color: var(--primary-color);
            text-decoration: none;
        }

        .toc-container ul ul {
            margin-left: 1rem;
        }

        /* Main Content */
        .main-content {
            flex: 1;
            min-width: 0;
            max-width: 800px;
        }

        /* Header */
        .post-header {
            margin-bottom: 2rem;
            padding-bottom: 1.5rem;
            border-bottom: 1px solid var(--border-color);
        }

        .back-link {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.9rem;
            color: var(--text-light);
            margin-bottom: 1.5rem;
        }

        .back-link:hover {
            color: var(--primary-color);
            text-decoration: none;
        }

        .post-header h1 {
            font-size: 2.25rem;
            font-weight: 700;
            line-height: 1.3;
            margin-bottom: 1rem;
            color: var(--text-color);
        }

        .post-meta {
            display: flex;
            flex-wrap: wrap;
            gap: 1.5rem;
            font-size: 0.9rem;
            color: var(--text-light);
        }

        .post-meta span {
            display: flex;
            align-items: center;
            gap: 0.4rem;
        }

        .post-meta i {
            color: var(--text-muted);
        }

        .tags {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-top: 1rem;
        }

        .tag {
            display: inline-block;
            font-size: 0.8rem;
            background: var(--bg-secondary);
            color: var(--text-light);
            padding: 0.25rem 0.75rem;
            border-radius: 20px;
            border: 1px solid var(--border-color);
            transition: all 0.2s;
        }

        .tag:hover {
            background: var(--primary-color);
            color: white;
            border-color: var(--primary-color);
        }

        /* Article Content */
        .post-content {
            font-size: 1rem;
            line-height: 1.9;
        }

        .post-content h1,
        .post-content h2,
        .post-content h3,
        .post-content h4,
        .post-content h5,
        .post-content h6 {
            margin-top: 2rem;
            margin-bottom: 1rem;
            font-weight: 600;
            line-height: 1.4;
            color: var(--text-color);
        }

        .post-content h1 { font-size: 1.875rem; }
        .post-content h2 { 
            font-size: 1.5rem; 
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--border-color);
        }
        .post-content h3 { font-size: 1.25rem; }
        .post-content h4 { font-size: 1.125rem; }

        .post-content p {
            margin-bottom: 1.25rem;
        }

        .post-content ul,
        .post-content ol {
            margin: 1.25rem 0;
            padding-left: 1.5rem;
        }

        .post-content li {
            margin-bottom: 0.5rem;
        }

        .post-content blockquote {
            margin: 1.5rem 0;
            padding: 1rem 1.5rem;
            background: var(--bg-secondary);
            border-left: 4px solid var(--primary-color);
            border-radius: 0 8px 8px 0;
            color: var(--text-light);
            font-style: italic;
        }

        .post-content blockquote p:last-child {
            margin-bottom: 0;
        }

        /* Code */
        .post-content code {
            font-family: 'JetBrains Mono', 'Fira Code', Consolas, monospace;
            font-size: 0.9em;
            background: var(--bg-code);
            padding: 0.2em 0.4em;
            border-radius: 4px;
            color: var(--link-color);
        }

        .post-content pre {
            margin: 1.5rem 0;
            padding: 1.25rem;
            background: var(--bg-code);
            border-radius: 10px;
            overflow-x: auto;
            border: 1px solid var(--border-color);
        }

        .post-content pre code {
            background: none;
            padding: 0;
            color: inherit;
            font-size: 0.875rem;
            line-height: 1.6;
        }

        /* Images */
        .post-content img {
            max-width: 100%;
            height: auto;
            border-radius: 10px;
            margin: 1.5rem 0;
            box-shadow: var(--shadow-lg);
        }

        /* Tables */
        .post-content table {
            width: 100%;
            margin: 1.5rem 0;
            border-collapse: collapse;
            font-size: 0.95rem;
        }

        .post-content th,
        .post-content td {
            padding: 0.75rem 1rem;
            border: 1px solid var(--border-color);
            text-align: left;
        }

        .post-content th {
            background: var(--bg-secondary);
            font-weight: 600;
        }

        .post-content tr:nth-child(even) {
            background: var(--bg-secondary);
        }

        /* Math */
        .math-display {
            margin: 1.5rem 0;
            overflow-x: auto;
            padding: 1rem;
            background: var(--bg-secondary);
            border-radius: 8px;
        }

        /* Anchor links */
        .anchor-link {
            opacity: 0;
            margin-left: 0.5rem;
            color: var(--text-muted);
            font-weight: 400;
            transition: opacity 0.2s;
        }

        .post-content h2:hover .anchor-link,
        .post-content h3:hover .anchor-link,
        .post-content h4:hover .anchor-link {
            opacity: 1;
        }

        /* Theme Toggle */
        .theme-toggle {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: var(--primary-color);
            color: white;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.25rem;
            box-shadow: var(--shadow-lg);
            transition: transform 0.2s, background 0.2s;
            z-index: 1000;
        }

        .theme-toggle:hover {
            transform: scale(1.1);
            background: var(--primary-hover);
        }

        /* Comments Section */
        .comments-section {
            margin-top: 3rem;
            padding-top: 2rem;
            border-top: 1px solid var(--border-color);
        }

        .comments-section h3 {
            font-size: 1.25rem;
            margin-bottom: 1.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        /* Footer */
        .post-footer {
            margin-top: 3rem;
            padding-top: 1.5rem;
            border-top: 1px solid var(--border-color);
            text-align: center;
            font-size: 0.9rem;
            color: var(--text-muted);
        }

        /* Responsive */
        @media (max-width: 1024px) {
            .toc-sidebar {
                display: none;
            }
            
            .page-wrapper {
                padding: 1.5rem;
            }
        }

        @media (max-width: 768px) {
            .post-header h1 {
                font-size: 1.75rem;
            }
            
            .post-meta {
                flex-direction: column;
                gap: 0.5rem;
            }
            
            .theme-toggle {
                bottom: 1rem;
                right: 1rem;
                width: 44px;
                height: 44px;
            }
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-secondary);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--text-muted);
        }
    </style>
</head>
<body>
    <div class="page-wrapper">
        <!-- TOC Sidebar -->
        <aside class="toc-sidebar">
            <div class="toc-container">
                <h3><i class="fas fa-list"></i> 目录</h3>
                <div class="toc">
<ul>
<li><a href="#0-摘要">0. 摘要</a></li>
<li><a href="#1-引言">1. 引言</a></li>
<li><a href="#2-预备知识与问题表述">2. 预备知识与问题表述</a><ul>
<li><a href="#21-知识蒸馏">2.1 知识蒸馏</a></li>
<li><a href="#22-持续学习">2.2 持续学习</a></li>
<li><a href="#23-持续学习协议">2.3 持续学习协议</a><ul>
<li><a href="#231-ciltil-和-dil">2.3.1 CIL、TIL 和 DIL</a></li>
<li><a href="#232-离线和在线-cil">2.3.2 离线和在线 CIL</a></li>
<li><a href="#233-平衡-cil少样本-cil-和长尾-cil">2.3.3 平衡 CIL、少样本 CIL 和长尾 CIL</a></li>
</ul>
</li>
<li><a href="#24-持续学习与-kd-的形式化">2.4 持续学习与 KD 的形式化</a></li>
</ul>
</li>
<li><a href="#3-持续学习与-kd-的范式">3. 持续学习与 KD 的范式</a><ul>
<li><a href="#31-kd-作为正则化">3.1 KD 作为正则化</a></li>
<li><a href="#32-kd-与数据回放的结合">3.2 KD 与数据回放的结合</a></li>
<li><a href="#33-kd-与特征回放的结合">3.3 KD 与特征回放的结合</a></li>
</ul>
</li>
<li><a href="#4-持续学习与-kd-的知识源">4. 持续学习与 KD 的知识源</a><ul>
<li><a href="#41-logits-级蒸馏">4.1 Logits 级蒸馏</a><ul>
<li><a href="#411-概率匹配">4.1.1 概率匹配</a></li>
<li><a href="#412-logits-匹配">4.1.2 Logits 匹配</a></li>
</ul>
</li>
<li><a href="#42-特征级蒸馏">4.2 特征级蒸馏</a><ul>
<li><a href="#421-实例特征对齐">4.2.1 实例特征对齐</a></li>
<li><a href="#422-隐藏特征对齐">4.2.2 隐藏特征对齐</a></li>
<li><a href="#423-关系对齐">4.2.3 关系对齐</a></li>
</ul>
</li>
<li><a href="#43-数据级蒸馏">4.3 数据级蒸馏</a><ul>
<li><a href="#431-显式数据对齐">4.3.1 显式数据对齐</a></li>
<li><a href="#432-隐式数据对齐">4.3.2 隐式数据对齐</a></li>
</ul>
</li>
<li><a href="#44-讨论">4.4 讨论</a></li>
</ul>
</li>
<li><a href="#5-实验">5. 实验</a><ul>
<li><a href="#51-数据集">5.1 数据集</a></li>
<li><a href="#52-协议和场景">5.2 协议和场景</a></li>
<li><a href="#53-指标">5.3 指标</a></li>
<li><a href="#54-基线方法">5.4 基线方法</a></li>
<li><a href="#55-训练细节">5.5 训练细节</a></li>
<li><a href="#56-结果">5.6 结果</a><ul>
<li><a href="#561-数据集上的表现">5.6.1 数据集上的表现</a></li>
<li><a href="#562-kd-效果">5.6.2 KD 效果</a></li>
<li><a href="#563-kd-损失">5.6.3 KD 损失</a></li>
<li><a href="#564-kd-与数据回放">5.6.4 KD 与数据回放</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#6-kd-在其他任务中的应用">6. KD 在其他任务中的应用</a><ul>
<li><a href="#61-方法和实验设置">6.1 方法和实验设置</a></li>
<li><a href="#62-结果与讨论">6.2 结果与讨论</a></li>
</ul>
</li>
<li><a href="#7-持续学习与-kd-的未来趋势">7. 持续学习与 KD 的未来趋势</a><ul>
<li><a href="#71-高质量知识的-kd">7.1 高质量知识的 KD</a></li>
<li><a href="#72-针对特定任务的-kd">7.2 针对特定任务的 KD</a></li>
<li><a href="#73-更好的教师模型的-kd">7.3 更好的教师模型的 KD</a></li>
</ul>
</li>
<li><a href="#8-结论">8. 结论</a></li>
</ul>
</div>

            </div>
        </aside>

        <!-- Main Content -->
        <main class="main-content">
            <article>
                <header class="post-header">
                    <a href="../../../../index.html" class="back-link">
                        <i class="fas fa-arrow-left"></i> 返回博客列表
                    </a>
                    <h1>Untitled</h1>
                    <div class="post-meta">
                        <span><i class="fas fa-calendar-alt"></i> 2026-02-04</span>
                        <span><i class="fas fa-folder"></i> AINotes/40.CIL/00.Survey</span>
                        <span><i class="fas fa-user"></i> Hongwei Zhao</span>
                    </div>
                    <div class="tags">
                        
                    </div>
                </header>

                <div class="post-content">
                    <h2 id="0-摘要">0. 摘要<a class="anchor-link" href="#0-摘要" title="Permanent link">&para;</a></h2>
<p>持续学习中的首要挑战是缓解灾难性遗忘，使模型在学习新任务的同时保留对先前任务的知识。知识蒸馏（KD）作为一种正则化方法，因其在学习新任务时通过模仿早期模型的输出来保持模型在先前任务上的性能而受到广泛关注，从而减少遗忘。本文对图像分类领域中采用 KD 的持续学习方法进行了全面调查。我们详细分析了 KD 在持续学习方法中的应用，并将其应用分为三种不同的范式。此外，我们根据所使用的知识源类型对这些方法进行了分类，并从损失函数的角度深入探讨了 KD 如何巩固持续学习中的记忆。我们还通过在 CIFAR-100、TinyImageNet 和 ImageNet-100 数据集上对十种集成 KD 的持续学习方法进行了广泛的实验，分析了 KD 在持续学习中的作用，并进一步讨论了其在其他持续学习任务中的有效性。我们的大量实验证据表明，KD 在缓解持续学习中的遗忘方面起着至关重要的作用，并证实了当与数据回放结合使用时，分类偏差会对 KD 的有效性产生不利影响，而采用分离的 softmax 损失可以显著提高其效果。</p>
<p><strong>关键词</strong>：灾难性遗忘，持续学习，增量学习，知识蒸馏（KD）。</p>
<h2 id="1-引言">1. 引言<a class="anchor-link" href="#1-引言" title="Permanent link">&para;</a></h2>
<p>持续学习是一个新兴领域，旨在解决适应性智能的需求，近年来引起了广泛关注。标准的深度学习方法从已建立的数据集中学习静态数据分布，有效地针对特定应用 [1]。然而，这些方法在处理分布外数据时遇到困难。持续学习致力于使模型能够在动态数据环境中吸收新知识，同时保留先前的学习 [2, 3]。该领域强调模型在整个生命周期内对知识的终身吸收和精炼，类似于人类的学习过程。在文献中，持续学习也被称为终身学习 [4, 5, 6]、增量学习 [7, 8, 9] 或顺序学习 [10, 11]。持续学习的重要性在于其能够从持续流入的新数据中逐步获取知识，从而避免了完全重新训练模型的必要性。</p>
<p>与传统的联合训练不同，持续学习模型通常无法利用历史数据，因此容易受到<strong>灾难性遗忘</strong>[10, 12] 的影响。这导致模型在吸收新信息时无法保留先前获得的知识。为了解决这个问题，模型必须设计成在持续学习周期中既能缓解旧知识的丢失，又能促进新知识的整合。模型吸收新知识并同时保留现有信息的能力被<strong>稳定性 - 可塑性困境</strong>[13, 14] 所概括。持续学习的总体目标是在稳定性和可塑性之间取得平衡——使模型能够保持关键知识并有效地整合新信息。</p>
<p>在持续学习领域，已经提出了多种策略来抑制灾难性遗忘。知识蒸馏（KD）作为一种基于正则化的方法 [8, 15]，逐渐成为缓解持续学习中遗忘问题的标准技术，通过促使新任务模型模仿旧任务模型的输出来实现。在持续学习框架中，先前训练的模型充当“教师”，逐步将其专业知识传递给“学生”模型，后者学习新任务 [16, 17]。这一过程确保了学习信息的保留，同时促进了新任务的获取。持续学习中的 KD 通常被概念化为一种自蒸馏 [18, 19]，其中教师模型和学生模型共享相同的架构，除了它们的分类层。KD 与其他方法（如数据回放）的结合使用越来越受欢迎 [15, 20]。图 1 展示了 KD 在持续学习框架中的应用。</p>
<p>尽管 KD 逐渐成为对抗灾难性遗忘的流行方法，但仍需要深入探讨其在持续学习实践中的整合方式及其在克服遗忘方面的有效性。大多数当代关于持续学习的调查主要从图像分类领域和其他应用领域的各种方法分类角度进行研究。值得注意的是，缺乏通过特定技术（如 KD）来缓解持续学习中遗忘问题的综述。例如，[21] 是第一个系统地将持续学习方法分为三种类型的调查：基于回放的方法、基于正则化的方法和基于参数隔离的方法。Van de Ven 和 Tolias[7] 总结了持续学习场景的类型，定义了三种类型：任务增量学习（TIL）、类增量学习（CIL）和域增量学习（DIL）。Belouadah 等人 [22] 定义了持续学习算法的六个基本属性。Mai 等人 [23] 专注于在线持续学习，并总结了持续学习中的评估指标。Parisi 等人 [24] 和 Hayes 等人 [25] 从生物学角度讨论了持续学习。Masana 等人 [8] 和 Zhou 等人 [9] 对类增量持续学习方法进行了针对性调查，随着 CIL 场景的关注度增加。Wang 等人 [15] 从理论、代表性方法和应用角度对持续学习进行了综合分析。除了图像分类任务外，还有一些调查专注于其他应用领域的持续学习，如机器人 [26]、自然语言处理（NLP）[27, 28] 和神经推荐系统 [29]。</p>
<p>在本文中，我们对主要应用于图像分类任务的持续学习方法进行了详细分析，这些方法采用了 KD。我们广泛地将 KD 的应用分为三种不同的范式：KD 作为正则化、KD 与数据回放的结合以及 KD 与特征回放的结合。随后，我们根据蒸馏过程中使用的知识源对这些方法进行分类，确定了三个主要层次：logits 级、特征级和数据级。然后，我们从蒸馏损失函数的角度进行了深入分析，以理解 KD 如何巩固持续学习中的记忆。为了研究 KD 在缓解遗忘方面的影响，我们选择了十种集成 KD 的持续学习方法，并在 CIFAR-100、TinyImageNet 和 ImageNet-100 等数据集上进行了广泛的实验，深入分析了 KD 在各种持续学习场景中的作用。此外，我们证实了当与数据回放结合使用时，分离的 softmax 分类损失可以增强 KD 在缓解遗忘方面的有效性。我们的代码公开在 https://github.com/lisongze/CLKD。总体而言，本文的主要贡献如下：</p>
<p>1) 我们对集成 KD 的持续学习方法进行了全面调查，主要集中在图像分类任务上。据我们所知，这是该领域的首次系统综述。<br />
2) 我们引入了一种新的分类法，从两个方面对集成 KD 的持续学习方法进行分类：KD 在持续学习中的应用范式和蒸馏知识源。我们详细分析了蒸馏损失以对抗遗忘。<br />
3) 我们在广泛采用的数据集上对十种集成 KD 的持续学习方法进行了广泛的实验，展示了 KD 在缓解遗忘方面的作用。<br />
4) 我们证实了分类偏差会损害 KD 的性能，而分离的 softmax 损失可以增强 KD 在缓解遗忘方面的有效性，尤其是在与数据回放结合使用时。</p>
<p>本文的结构如下。第 II 节提供了 KD 和持续学习的背景和问题表述。第 III 节分析了 KD 在持续学习中的应用范式。第 IV 节根据蒸馏知识源对集成 KD 的持续学习方法进行了分类，并从 KD 损失函数的角度探讨了 KD 如何巩固记忆。第 V 节详细介绍了实验方法，并广泛分析了 KD 对持续学习的影响。第 VI 节讨论了 KD 在其他视觉任务中缓解遗忘的有效性。最后，第 VII 节展望了 KD 在持续学习中的未来研究趋势，第 VIII 节总结了本文。</p>
<h2 id="2-预备知识与问题表述">2. 预备知识与问题表述<a class="anchor-link" href="#2-预备知识与问题表述" title="Permanent link">&para;</a></h2>
<p>在本节中，我们首先阐述了 KD 和持续学习的概念，随后详细描述了各种持续学习协议。接着，我们形式化了 KD 在持续学习框架中的整合。</p>
<h3 id="21-知识蒸馏">2.1 知识蒸馏<a class="anchor-link" href="#21-知识蒸馏" title="Permanent link">&para;</a></h3>
<p>KD 的基本目标是转移知识 [30]。它遵循教师 - 学生模式 [16]，其中学生模型被训练以模仿训练有素的教师模型的输出。KD 的概念由 Hinton 等人 [31] 提出，通过最小化教师模型和学生模型输出之间的 Kullback-Leibler（KL）散度 [32] 来实现知识转移。设 Ter 表示教师模型，Stu 表示学生模型。教师模型对输入 x 的输出 logits 表示为 <span class="math-inline">\tau_{\text{Ter}}(x)</span>，学生模型的输出 logits 表示为 <span class="math-inline">\tau_{\text{Stu}}(x)</span>。通过应用带有温度 <span class="math-inline">\tau</span> 的 softmax 函数获得软目标：<br />
<div class="math-display"><br />
    P_{\text{Ter}}(x) = \text{softmax}(\tau_{\text{Ter}}(x)/\tau) \tag{1}<br />
</div><br />
蒸馏损失 <span class="math-inline">L_{\text{KD}}</span> 定义为教师和学生软目标之间的 KL 散度：<br />
<div class="math-display"><br />
    L_{\text{KD}} = \text{KL}(P_{\text{Ter}}(x) \parallel P_{\text{Stu}}(x)) \tag{3}<br />
</div><br />
在训练过程中最小化该损失，以确保学生模型模仿教师模型。</p>
<p>最初，KD 的主要应用是模型压缩 [33, 34]，解决了由于深度学习模型规模增长而增加的计算和存储需求，这限制了其在实时处理和资源受限系统上的部署。除了模型压缩外，KD 的应用还扩展到各种领域，如特权学习 [35, 36]、互学习 [37, 38]、辅助教学 [39, 40]、自学习 [41, 42]、对抗攻击的防护措施 [43, 44]，尤其是持续学习 [45, 46]。</p>
<h3 id="22-持续学习">2.2 持续学习<a class="anchor-link" href="#22-持续学习" title="Permanent link">&para;</a></h3>
<p>持续学习旨在从具有变化分布的连续数据流中学习，即使在新信息被获取时也能保留过去的知识。与静态的训练和部署模型不同，持续学习模型被设计为随着时间的推移而增长并整合新的技能和知识。然而，这些模型经常面临灾难性遗忘，即在无法访问旧任务数据的情况下引入新任务会导致先前学习的信息丢失。</p>
<p>在持续学习中缓解灾难性遗忘的方法可以大致分为三种主要策略。第一种策略通常称为基于正则化的方法 [47, 48, 49]，它采用正则化技术来引导模型训练朝向适应所有任务的全局最优解。另一种策略是基于参数隔离或架构的方法，其中在持续学习过程中为每个任务分配不同的参数。这些方法可以进一步分为固定 [50, 51, 52] 和动态 [53, 54, 55] 架构模型，基于网络规模在学习过程中的变化。最后，某些方法通过缓存先前任务的一小部分数据并在学习新任务时回放这些数据来缓解遗忘。这种技术通常被称为基于回放的方法 [56, 57, 58]。</p>
<h3 id="23-持续学习协议">2.3 持续学习协议<a class="anchor-link" href="#23-持续学习协议" title="Permanent link">&para;</a></h3>
<p>本节深入探讨了持续学习中的实验协议，从三个角度对其进行了分析。首先，我们将持续学习分为 CIL[59, 60, 61, 62]、TIL[7, 21] 和 DIL[63, 64, 65]，考虑了模型分类头的更新以及在训练和推理过程中是否需要任务指示器。其中，CIL 是目前持续学习研究中最普遍的协议之一。基于 CIL，我们根据学习模型在训练期间访问数据流的次数将持续学习分为离线和在线 [66, 67, 68] CIL。此外，我们根据跨类别的训练样本数量对持续学习进行分类，分为平衡、少样本 [69, 70, 71] 和长尾 CIL（LT-CIL）[72, 73]。各种持续学习协议的特征如图 2 所示。</p>
<h4 id="231-ciltil-和-dil">2.3.1 CIL、TIL 和 DIL<a class="anchor-link" href="#231-ciltil-和-dil" title="Permanent link">&para;</a></h4>
<p>CIL 是持续学习中最普遍的协议，涉及一系列具有唯一标签的任务，以实现在没有任务标识符的情况下对所有学习类进行分类。模型的分类头随着每个新任务的增加而增长。TIL 类似于 CIL，但在训练和推理过程中使用任务指示器，允许在给定任务范围内进行区分，从而简化了与 CIL 相比的类别确定。DIL 保持恒定数量的分类头，面临对来自相同类别但随时间变化分布的样本进行分类的挑战，这些样本是按顺序提供的。</p>
<h4 id="232-离线和在线-cil">2.3.2 离线和在线 CIL<a class="anchor-link" href="#232-离线和在线-cil" title="Permanent link">&para;</a></h4>
<p>当未明确指定“在线”CIL 时，该术语通常默认为“离线”CIL。离线 CIL 允许模型在当前任务的数据流上迭代，直到达到收敛。这种设置允许重复训练周期以提高性能。相比之下，在线 CIL 限制模型只能一次性通过传入数据，模拟现实世界中的数据是短暂的，只能通过物理捕获保存的条件。这种单次通过的限制增加了难度，因为模型必须快速学习并整合新信息，而无法重新访问数据。</p>
<h4 id="233-平衡-cil少样本-cil-和长尾-cil">2.3.3 平衡 CIL、少样本 CIL 和长尾 CIL<a class="anchor-link" href="#233-平衡-cil少样本-cil-和长尾-cil" title="Permanent link">&para;</a></h4>
<p>持续学习领域中的现有方法通常假设与传入任务相关的数据是均匀分布的，每个任务提供等量的训练样本。我们将此协议称为平衡 CIL，这在现实世界中并不常见。少样本 CIL（FSCIL）[69] 将少样本学习与持续学习相结合。在 FSCIL 中，模型从初始任务的大量训练数据开始，而后续任务仅提供少量样本，显著少于第一个任务的数据集。LT-CIL[72] 承认现实数据的复杂性和不平衡性，解决了跨任务的不同数据分布问题。任务按不同样本量排序，反映了现实世界数据集中发现的长尾分布，从而反映了实际使用案例中的多样性和不平衡性。</p>
<h3 id="24-持续学习与-kd-的形式化">2.4 持续学习与 KD 的形式化<a class="anchor-link" href="#24-持续学习与-kd-的形式化" title="Permanent link">&para;</a></h3>
<p>在本研究中，我们专注于 CIL 协议，其中模型暴露于由一系列独立任务组成的连续数据流，定义为 <span class="math-inline">D={D_{1},\ldots,D_{t},\ldots,D_{T}}</span>，其中 <span class="math-inline">t</span> 表示给定任务的索引，<span class="math-inline">T</span> 表示任务的总数。任务按顺序引入，模型应从当前任务 <span class="math-inline">D_{t}</span> 中学习，而没有机会重新访问先前任务的数据。持续学习模型被概念化为 <span class="math-inline">H={\theta,\phi}</span>，其中包括特征提取器 <span class="math-inline">\theta</span> 和分类器 <span class="math-inline">\phi</span>。对于每个任务索引 <span class="math-inline">t</span>，模型遇到数据 <span class="math-inline">D_{t}={X_{t},Y_{t}}</span>，其中 <span class="math-inline">X_{t}</span> 表示输入集，<span class="math-inline">Y_{t}</span> 表示相关标签，每个任务包含 <span class="math-inline">C_{t}</span> 个类别。在 <span class="math-inline">D_{t}</span> 上的训练阶段，输入 <span class="math-inline">X_{t}</span> 通过 <span class="math-inline">\theta</span> 处理为特征向量 <span class="math-inline">f=\theta(X_{t})</span>。随后，这些特征 <span class="math-inline">f</span> 被馈送到 <span class="math-inline">\phi</span> 以生成预 softmax logits <span class="math-inline">z=\phi(f)</span>。在这种设置中，<span class="math-inline">H</span> 倾向于在未保留过去样本的情况下灾难性地遗忘先前知识。</p>
<p>为了对抗灾难性遗忘，通常使用记忆缓冲区 <span class="math-inline">M</span> 来保留先前任务的一部分样本，以便在新任务学习期间进行记忆回放。本文已被接受发表在期刊的未来一期中。内容以呈现的形式为最终版本，除分页外。</p>
<h2 id="3-持续学习与-kd-的范式">3. 持续学习与 KD 的范式<a class="anchor-link" href="#3-持续学习与-kd-的范式" title="Permanent link">&para;</a></h2>
<p>在本节中，我们对 KD 在持续学习方法中的应用范式进行了深入分析。我们发现，KD 最初是作为一种独立的正则化技术引入持续学习中的，旨在通过约束模型参数的变化来防止遗忘先前学到的知识。随着持续学习方法的演变，KD 越来越多地与各种其他技术（如数据回放和特征回放）结合使用。基于此，我们将 KD 在持续学习中的应用分为三种范式：KD 作为正则化、KD 与数据回放的结合以及 KD 与特征回放的结合。图 3 展示了我们的分类框架的详细图示。</p>
<div align=center><img src="https://markdownimg-hw.oss-cn-beijing.aliyuncs.com/20250206215610.png" style="zoom: 80%;" /></div>

<h3 id="31-kd-作为正则化">3.1 KD 作为正则化<a class="anchor-link" href="#31-kd-作为正则化" title="Permanent link">&para;</a></h3>
<p>最初，KD 被引入持续学习作为一种独立的正则化技术，旨在通过约束模型参数的变化来防止遗忘先前学到的知识。这类方法将 KD 作为对抗遗忘的核心机制，其性能高度依赖于 KD 过程的有效性。</p>
<p>LwF [45] 是第一个在持续学习中使用 KD 作为正则化项的方法，通过蒸馏新任务数据在旧模型上的响应来保留旧任务的记忆。类似地，LwM [74] 利用 KD 来抑制遗忘，通过保持旧任务模型的注意力区域并结合基本的 logits 级蒸馏。DMC [59] 进一步强调了 KD 的作用，使用双重蒸馏损失来蒸馏来自新任务专家模型和旧任务模型的组合 logits。BLD [75] 提出了一种批量级蒸馏，其中蒸馏数据从预热阶段收集，并在联合学习阶段进行蒸馏。TPCL [76] 在特征空间中捕获知识作为弹性 Hebbian 图（EHG），节点表示类别原型，边表示类间余弦距离。TPCL 使用拓扑保持损失来惩罚增量学习期间 EHG 结构的变化。在这里，KD 在保持 EHG 结构的完整性方面起着关键作用，确保学到的知识不会被遗忘。PRD [77] 通过监督对比学习持续学习特征提取器，这被证明不易遗忘，并通过旧任务原型和新任务样本之间的关系蒸馏损失将旧任务原型演化到新的特征空间。属于“KD 作为正则化”范式的方法将 KD 作为缓解遗忘的主要和唯一方法。这种方法的思路简单直接，但其整体防止遗忘的能力相对较差，通常表现较低。</p>
<h3 id="32-kd-与数据回放的结合">3.2 KD 与数据回放的结合<a class="anchor-link" href="#32-kd-与数据回放的结合" title="Permanent link">&para;</a></h3>
<p>近年来，KD 经常与数据回放技术结合使用，以从数据和模型的角度增强记忆保留。数据回放方法需要一个额外的缓冲区来缓存来自先前任务的额外样本，以近似它们的分布，并在持续学习期间不断回放这些样本，以实现持续的记忆保留。将 KD 与数据回放方法结合进一步增强了模型的记忆保留能力。</p>
<p>iCaRL [46] 是第一个将 KD 与数据回放结合的方法。此后，许多将 KD 与数据回放结合的方法将数据回放视为对抗遗忘的基本技术，并探索各种类型的蒸馏技术以进一步增强旧任务的记忆保留。EEIL [78] 引入了任务级知识蒸馏（TKD）损失以避免遗忘。D + R [79] 从旧任务模型和中间专家模型中蒸馏知识以应对新任务。GD [80] 还训练一个中间新任务专家，并使用未标记数据的全局蒸馏从该专家、旧模型及其组合知识中蒸馏。ILOS [66] 提出了一种改进的交叉蒸馏方法以应对在线场景。PODNet [81] 引入了一种基于空间的特征蒸馏，在整个持续学习过程中保持有价值的特征。AFC [82] 设计了一种基于重要性的特征蒸馏方法，在新任务学习期间保留关键特征并允许对不太重要的特征进行更多适应性调整。Co2L [83] 提出了一种实例级关系蒸馏方法，通过保留样本之间的局部拓扑关系来保持记忆。GeoDL [84] 在蒸馏之前将特征投影到低维流形子空间上。COIL [61] 提出了一种双向蒸馏损失，通过前向和后向转移知识来帮助模型快速适应并防止灾难性遗忘。MBP [85] 旨在通过实例邻域保持损失来保持模型行为，防止实例关系的变化，同时通过标签优先级保持损失来避免类别优先级的变化。DER++ [86] 发现对训练过程中的 logits 轨迹进行蒸馏在巩固记忆方面有更好的效果。XDER [60] 改进了 DER++ [86]，通过基于未来任务数据对 logits 的影响更新蒸馏的 logits，从而获得更好的性能。OCD-Net [87] 使用在线响应蒸馏来对抗教师模型偏差，并通过自适应感知调整增强教师响应的质量。除了直接使用额外内存存储旧任务的回放数据外，一些方法通过生成模型 [88, 89] 或模型反演 [90, 91, 92] 技术生成回放数据。这些方法通常对生成的数据应用 KD 以防止生成模型在持续学习过程中遗忘，同时使用基本的 KD 技术对 logits 或特征进行蒸馏以缓解遗忘。对于这些方法，除了 KD 是缓解遗忘的有效手段外，生成数据的质量也在决定整体遗忘缓解效果方面起着至关重要的作用。</p>
<p>由于少量回放数据与新任务数据之间的严重数据不平衡容易导致分类偏差，一些方法除了将 KD 视为记忆保留的标准机制外，更加注重解决分类偏差问题。例如，BiC [93] 通过在平衡验证数据集上训练类别校正参数来明确解决分类器偏差问题，而 RDICL [94] 通过动态阈值移动算法修复此问题。WA [95] 提出权重对齐以在不需额外校正参数的情况下纠正偏差，与 BiC [93] 不同。LUCIR [96] 通过归一化特征并增加类间分离来解决不平衡分类问题。GD [80] 通过在平衡微调阶段使用缩放梯度模拟多次数据馈送来缓解偏差。SS-IL [97] 使用分离的 softmax 来缓解偏差问题。LVT [98] 设计了一个双分类器系统，一个用于新任务特征学习，另一个用于以平衡的方式整合所有任务的知识。DRC [99] 通过设计动态残差分类器来缓解分类器偏差问题。除了分类偏差问题外，一些其他方法将 KD 与数据回放的结合视为记忆保留的标准机制，并更加关注其他问题，例如回放数据的选择 [100, 101] 和结合基于架构的方法 [102, 103, 104] 以保持记忆。</p>
<h3 id="33-kd-与特征回放的结合">3.3 KD 与特征回放的结合<a class="anchor-link" href="#33-kd-与特征回放的结合" title="Permanent link">&para;</a></h3>
<p>除了将 KD 与数据回放结合外，许多方法还将 KD 与特征回放结合，以实现无样本的持续学习。大多数此类方法利用特征级蒸馏中的实例特征对齐来保持特征网络的记忆能力，并采用各种特征生成方法生成回放特征，从而确保分类器的记忆得以保留。GFR [105] 通过训练生成模型存储旧任务的特征，然后在持续学习期间生成回放特征。PASS [106] 将类别原型定义为特征空间数据的均值，并在新类别学习期间引入高斯噪声进行增强，防止对新数据的分类偏差。IL2A [ 107 ]与PASS [ 106 ]一样，用基于均值的原型表示旧的类分布，但也包含了用于特征空间数据增强的分布方差，以在新的类学习过程中保护旧的类边界。FRoST [ 108 ]还重播了从高斯分布中提取的生成式特征，高斯分布是由存储的特征原型和旧类数据的方差定义的。与PASS [ 106 ]不同，SSRE [ 62 ]选择过采样原型，用于长尾识别[ 109 ]生成重放特征。FeTrIL [ 110 ]通过对新的类别特征进行简单的几何转换来为过去的类别生成伪特征，其关键条件是特征提取器在初始阶段保持固定不变。PRAKA [ 111 ]通过在提取的新类特征和存储的旧类原型之间进行随机双向插值来生成重放特征。Fusion [ 112 ]通过引入新的类来观察特征分布的漂移，从而引起原型的变化。为了测量和校正原型漂移，在分类器训练之前，它使用深度神经网络( DNN )来参数化高斯或变分模型。MEIL [ 113 ]通过重放缓存的旧任务特征来对抗遗忘。随着新任务学习后特征空间的漂移，它通过特征自适应模块将这些缓存的特征迁移到更新的特征空间中。此外，MEIL在学习新任务时同时使用logits和特征蒸馏来保持旧模型对新数据的响应。与" KD与数据回放结合"范式中的方法相比，该范式不需要大量额外的内存来存储旧任务中的原始样本。相反，它只需要少量的内存来存储每个类的特征信息。此外，特征重放有助于减少重放数据与新任务数据不平衡导致的分类偏差问题。</p>
<h2 id="4-持续学习与-kd-的知识源">4. 持续学习与 KD 的知识源<a class="anchor-link" href="#4-持续学习与-kd-的知识源" title="Permanent link">&para;</a></h2>
<p>在本节中，我们根据蒸馏过程中使用的知识源对集成 KD 的持续学习方法进行了分类，并详细探讨了不同层次的蒸馏损失函数。我们将知识源分为三个主要层次：logits 级、特征级和数据级。图 4 展示了从不同知识源进行持续学习与 KD 的示意图。</p>
<h3 id="41-logits-级蒸馏">4.1 Logits 级蒸馏<a class="anchor-link" href="#41-logits-级蒸馏" title="Permanent link">&para;</a></h3>
<p>Logits 级蒸馏旨在通过约束分类头的输出来保留知识。这类方法可以分为两个子类：概率匹配和 logits 匹配。</p>
<h4 id="411-概率匹配">4.1.1 概率匹配<a class="anchor-link" href="#411-概率匹配" title="Permanent link">&para;</a></h4>
<p>概率匹配方法通过最小化教师模型和学生模型输出概率分布之间的差异来保留知识。LwF [45] 是第一个在持续学习中使用概率匹配的方法，其蒸馏损失定义为：<br />
<div class="math-display"><br />
    L_{\text{KD}} = -\sum_{i=1}^{C} \pi(\tilde{z}_i) \log \pi(z_i) \tag{7}<br />
</div><br />
其中，<span class="math-inline">\tilde{z}_i</span> 和 <span class="math-inline">z_i</span> 分别表示教师模型和学生模型的输出 logits，<span class="math-inline">\pi(\cdot)</span> 表示 softmax 函数。</p>
<p>EEIL [78] 引入了任务级知识蒸馏（TKD）损失，通过为每个旧任务单独匹配概率来保留知识：<br />
<div class="math-display"><br />
    L_{\text{KD}} = -\sum_{i=1}^{t-1} \sum_{j=1}^{C_i} \pi(\tilde{z}<em>{ij}) \log \pi(z</em>{ij}) \tag{10}<br />
</div><br />
其中，<span class="math-inline">t</span> 是当前任务的索引，<span class="math-inline">C_i</span> 是每个任务的类别数。SS-IL [97] 证明，当与分离的 softmax 分类层结合使用时，TKD 非常有效。</p>
<p>D + R [79] 结合蒸馏和回顾，以在持续学习过程中更好地平衡旧知识的保留和新知识的适应。它从两个教师模型中蒸馏知识：一个是仅从当前新任务数据中学习的中间专家模型，另一个是旧任务模型：<br />
<div class="math-display"><br />
    L_{\text{KD}} = -\sum_{i=1}^{C_{1:t-1}} \pi(\tilde{z}<em>i) \log \pi(z_i) - \sum</em>{i=C_{1:t-1}+1}^{C_{1:t}} \pi(q_i) \log \pi(z_i) \tag{11}<br />
</div><br />
其中，<span class="math-inline">C_{1:t}</span> 是当前任务之前的类别总数，<span class="math-inline">q_i</span> 是专家模型的响应。</p>
<p>GD [80] 设计了一种全局蒸馏损失，通过利用大量未标记的野外数据来保留先前任务的知识。全局蒸馏损失包括三个部分：从旧任务模型 <span class="math-inline">M_{t-1}</span> 蒸馏、从当前任务专家模型 <span class="math-inline">M_{\text{exper}}</span> 蒸馏以及从 <span class="math-inline">M_{t-1}</span> 和 <span class="math-inline">M_{\text{exper}}</span> 的集成知识蒸馏，以通过外部野外数据补充缺失的知识。</p>
<p>MBP [85] 通过一种宽松的概率匹配方案缓解遗忘，该方案不严格匹配新旧任务模型的输出概率分布，而是根据新旧任务模型的概率向量排序后匹配标签优先级向量。这有助于保留模型学习的不同类别之间的语义相关性。</p>
<p>BLD [75] 提出了一种批量级蒸馏损失，以在极端有限的存储条件下平衡在线持续学习中的稳定性和可塑性。它在预热训练阶段计算旧任务的分类概率，并在联合学习阶段通过蒸馏缓存的分类概率来防止灾难性遗忘。</p>
<h4 id="412-logits-匹配">4.1.2 Logits 匹配<a class="anchor-link" href="#412-logits-匹配" title="Permanent link">&para;</a></h4>
<p>DER++ [86] 通过匹配网络预 softmax 输出 logits 在优化轨迹中的样本来蒸馏过去的经验。它经验证明，对训练轨迹进行蒸馏可以收敛到更平坦的损失景观，并实现更好的模型校准。知识通过欧几里得距离损失继承，而不是 KL 散度，以消除来自 softmax 等压缩函数的信息损失：<br />
<div class="math-display"><br />
    L_{\text{KD}} = |\tilde{z} - z|<em>2 \tag{12}<br />
</div><br />
XDER [60] 指出 DER++ [86] 存在两个陷阱。DER++ 中存储的 logits 轨迹对于未来任务没有参考点，因为它们是从已经观察到的数据中学习的，而没有对未来任务数据的预测。XDER 在学习新任务后保持预 softmax logits 的未来部分更新，并从更新的 logits 中蒸馏知识，使用与 DER++ 相同的损失函数。DMC [59] 引入了一种深度模型整合范式，通过双重蒸馏损失从新任务专家模型和旧任务模型中压缩知识。压缩模型通过蒸馏连接的知识在辅助未标记数据的帮助下学习。双重蒸馏损失定义如下：<br />
<div class="math-display"><br />
    L</em>{\text{KD}} = \frac{1}{C_{1:t}} \sum_{i=1}^{C_{1:t}} (z_i - \tilde{z}_i)^2 \tag{13}<br />
</div></p>
<p><div class="math-display"><br />
    \tilde{z}<em>i = \begin{cases} \tilde{z}_i - \frac{1}{C</em>{1:t-1}} \sum_{j=1}^{C_{1:t-1}} \tilde{z}<em>j, &amp; \text{如果 } 1 \leq j \leq C</em>{1:t-1} \ \tilde{z}<em>i - \frac{1}{C_i} \sum</em>{j=C_{1:t-1}+1}^{C_{1:t}} \tilde{z}<em>j, &amp; \text{如果 } C</em>{1:t-1} &lt; j \leq C_{1:t} \end{cases} \tag{14}<br />
</div><br />
其中，<span class="math-inline">z_i</span> 表示目标压缩模型的 logits 输出，<span class="math-inline">\tilde{z}<em>i</span> 是来自旧任务模型和新任务专家模型的连接 logits。如果 <span class="math-inline">1 \leq j \leq C</em>{1:t-1}</span>，则 <span class="math-inline">\tilde{z}<em>i</span> 表示来自旧任务模型的 logits 输出；如果 <span class="math-inline">C</em>{1:t-1} &lt; j \leq C_{1:t}</span>，则 <span class="math-inline">\tilde{z}_i</span> 表示来自新任务专家模型的 logits 输出。</p>
<p>R-DFCIL [91] 引入了硬知识蒸馏（HKD），并将其应用于通过模型反演 [115] 获得的合成旧任务数据的输出 logits，以巩固旧任务数据的分布。R-DFCIL 发现，使用 KL 散度和温度缩放的 softmax 函数来对齐新旧模型上合成数据的输出缺乏足够的约束力。因此，它对预 softmax logits 应用 L1 损失约束，以增强旧知识的巩固：<br />
<div class="math-display"><br />
    L_{\text{KD}} = |\tilde{z} - z|<em>1 \tag{15}<br />
</div><br />
OCD-Net [87] 设计了在线和自适应的预 softmax logits 蒸馏，以对抗离线 KD 中教师模型的固有响应偏差，其中静态教师模型可能由于训练数据中的类别不平衡而发展出分类偏差。OCD-Net 使用动量更新技术 [116] 更新教师模型，确保教师模型的响应是最新的。此外，OCD-Net 采用自适应感知来调制蒸馏的 logits，增强学生模型从教师模型学习高质量响应的能力。以下是带有自适应感知的在线响应蒸馏：<br />
<div class="math-display"><br />
    L</em>{\text{KD}} = \omega |\tilde{z} - z|_2 \tag{16}<br />
</div></p>
<p><div class="math-display"><br />
    \omega = \frac{\exp(z_{\text{gt}}^c / r)}{\sum_{i=1}^{C_{1:t}} \exp(\tilde{z}<em>i / r)} \tag{17}<br />
</div><br />
其中，<span class="math-inline">\omega</span> 是通过 (17) 获得的质量分数，<span class="math-inline">z</em>{\text{gt}}^c</span> 表示输入样本的 ground-truth 类别对应的响应。</p>
<h3 id="42-特征级蒸馏">4.2 特征级蒸馏<a class="anchor-link" href="#42-特征级蒸馏" title="Permanent link">&para;</a></h3>
<p>特征级蒸馏旨在传递网络特征提取阶段产生的内部表示知识。这类方法可以根据网络内特征的特性和位置分为三个子类：实例特征对齐、隐藏特征对齐和关系对齐。</p>
<h4 id="421-实例特征对齐">4.2.1 实例特征对齐<a class="anchor-link" href="#421-实例特征对齐" title="Permanent link">&para;</a></h4>
<p>LUCIR [96] 通过归一化实例特征的蒸馏损失来缓解持续学习中的灾难性遗忘。它使用余弦距离来衡量两个归一化特征之间的相似性，并通过特征余弦距离的约束防止特征发生剧烈变化和旋转：<br />
<div class="math-display"><br />
    L_{\text{KD}} = 1 - \left( \frac{\hat{f}}{|\hat{f}|}, \frac{f}{|f|} \right) \tag{18}<br />
</div><br />
其中，<span class="math-inline">(\hat{f}, f) = \hat{f}^\intercal f</span>，<span class="math-inline">\hat{f}</span> 和 <span class="math-inline">f</span> 分别表示旧任务模型和当前模型的特征。Simon 等人 [84]、Iscen 等人 [113] 和 Lu 等人 [117] 也采用了特征余弦角蒸馏。</p>
<p>GFR [105] 限制用于特征回放的生成特征的变化，以防止灾难性遗忘。它训练一个生成器来记忆学习到的特征，并在持续学习期间回放这些特征，以解决分类器上的不平衡问题。特征提取器通过 L2 损失进行特征蒸馏以保留旧任务知识：<br />
<div class="math-display"><br />
    L_{\text{KD}} = |\hat{f} - f|_2 \tag{19}<br />
</div><br />
参考文献 [62, 106, 107, 108, 110, 112, 118] 和 [111] 也遵循此方法使用 L2 特征蒸馏损失。</p>
<h4 id="422-隐藏特征对齐">4.2.2 隐藏特征对齐<a class="anchor-link" href="#422-隐藏特征对齐" title="Permanent link">&para;</a></h4>
<p>PODNet [81] 通过在中间特征和最终实例特征上应用基于空间的蒸馏损失来对抗灾难性遗忘。PODNet [81] 在卷积层后的池化中间特征上进行蒸馏，并经验发现，在高度和宽度方向上的基于空间的蒸馏模式如 (20) 所示，可以实现更好的稳定性和可塑性权衡。对于特征提取器的最终输出特征，它按照 (19) 进行知识蒸馏：<br />
<div class="math-display"><br />
    L_{\text{KD}} = \sum_{c=1}^{C} \sum_{h=1}^{H} \left| \sum_{w=1}^{W} \hat{f}<em>{l,c,w,h} - \sum</em>{w=1}^{W} \hat{f}<em>{l,c,w,h} \right|_2 + \sum</em>{c=1}^{C} \sum_{w=1}^{W} \left| \sum_{h=1}^{H} \hat{f}<em>{l,c,w,h} - \sum</em>{h=1}^{H} \hat{f}_{l,c,w,h} \right|_2 \tag{20}<br />
</div><br />
其中，<span class="math-inline">c, h</span> 和 <span class="math-inline">w</span> 是中间特征在通道、高度和宽度轴上的索引，<span class="math-inline">l</span> 是中间层的索引。</p>
<p>TwF [119] 在模型的中间层上采用加权特征蒸馏，以解决持续学习中预训练模型（PTMs）未充分利用的问题。直接通过欧几里得距离蒸馏这些特征可能导致模型过度复制 PTM 的中间表示，从而损害灵活性。因此，它使用注意力图作为二进制掩码来指导蒸馏中间特征的哪些方面以及哪些方面豁免，如以下方程所示：<br />
<div class="math-display"><br />
    L_{\text{KD}} = \sum_{l=1}^{L} |\mathbb{M}(\tilde{f}_l) \odot (f_l - \text{ReLU}_m(\tilde{f}_l))|_2 \tag{21}<br />
</div><br />
其中，<span class="math-inline">\mathbb{M}(\cdot)</span> 是计算注意力图的模块，<span class="math-inline">\odot</span> 是 Hadamard 积，<span class="math-inline">\text{ReLU}_m</span> 是边际修正线性单元（ReLU）激活函数。</p>
<p>AFC [82] 也采用加权蒸馏解决方案对中间特征图进行蒸馏，以限制持续学习中重要特征的变化。它通过最小化损失增加的上界来估计每个特征图的重要性，并通过泰勒近似进行了理论证明。</p>
<h4 id="423-关系对齐">4.2.3 关系对齐<a class="anchor-link" href="#423-关系对齐" title="Permanent link">&para;</a></h4>
<p>TPCIL [76] 引入了一种拓扑保持损失，通过在特征空间中惩罚类别原型关系的变化来保持流形结构。它使用弹性 Hebbian 图（EHG）对特征空间的拓扑结构进行建模，节点表示类别原型，边表示它们之间的余弦距离。为了保留先验知识，新形成的 EHG 的拓扑结构被约束为与之前的相似。</p>
<p>ERL [70] 使用样本关系图（ERG）来编码和保留缓存样本之间的局部关系，应用样本关系蒸馏损失以保持旧知识。在 ERG 中，每个顶点表示特征空间中的样本特征，边是连接顶点的单位向量。模型通过 ERG 中三个顶点形成的角度定义特征空间样本之间的关系。通过在持续学习期间约束角度的变化，ERL 调节特征空间的变化，增强先前学习信息的记忆。</p>
<p>Co2L [83] 采用自蒸馏对实例级关系进行蒸馏，以保持学习到的表示。它结合了非对称监督对比损失进行表示学习，旨在在学习新任务时保持批次样本内的关系完整。该方法计算每个样本与批次中其他样本之间的相似性，创建相似性向量。新旧模型之间的这种相似性关系用于从先前任务中蒸馏知识。由于此过程基于学习到的特征，因此被视为特征级蒸馏方法。</p>
<p>MBP [85] 通过保持特征空间中实例之间距离的相对顺序来保留模型的特征提取行为，使用实例邻域保持损失。MBP 计算所有实例之间的成对距离，识别每个实例的 top K 近邻。通过确保近邻点的顺序保持一致，MBP 在允许发展更具适应性的特征的同时，保持了语义实例关系，增强了模型的可塑性。</p>
<p>OCD-Net [87] 通过监督对比学习 [125] 整合教师模型的内部实例结构信息。它使用对比关系蒸馏损失将同一类别的嵌入聚类，并将不同类别的嵌入分离，利用余弦距离和温度缩放。教师模型的嵌入作为锚点，引导学生模型的嵌入朝向教师模型中的同一类别嵌入。</p>
<p>R-DFCL [91] 采用角度关系 KD 损失来学习新类别的表示，同时保留旧类别的表示。它通过稳定特征空间中新数据三元组的相互空间关系来实现这一点，该关系通过可学习的线性层进行转换。对于三元组 <span class="math-inline">(x_a, x_b, x_c)</span>，关系 KD 如下：<br />
<div class="math-display"><br />
    L_{\text{KD}} = |\cos{\angle t_a b_t e} - \angle s_a s_b s_c|_1 \tag{22}<br />
</div></p>
<p><div class="math-display"><br />
    \cos{\angle r_a r_b r_c} = (e^{ab}, e^{cb}), e^{ij} = \frac{r_i - r_j}{|r_i - r_j|_2} \tag{23}<br />
</div><br />
其中，<span class="math-inline">t</span> 是旧模型的转换表示，<span class="math-inline">s</span> 是新模型的转换表示。</p>
<h3 id="43-数据级蒸馏">4.3 数据级蒸馏<a class="anchor-link" href="#43-数据级蒸馏" title="Permanent link">&para;</a></h3>
<p>数据级蒸馏可以分为两种类型：显式数据对齐和隐式数据对齐。显式数据对齐涉及蒸馏由生成模型生成的合成数据。相比之下，隐式数据对齐侧重于蒸馏数据中的潜在信息，如生成模型的注意力图或潜在代码。</p>
<h4 id="431-显式数据对齐">4.3.1 显式数据对齐<a class="anchor-link" href="#431-显式数据对齐" title="Permanent link">&para;</a></h4>
<p>MeRGAN [88] 通过在持续学习期间对齐模型生成的回放数据，使用 L2 损失来确保生成对抗网络（GANs）中的记忆保留。具体来说，当在学习新任务期间向生成模型输入相同类别和潜在信息时，新生成模型生成的数据内容应与旧生成模型生成的数据内容一致。这种数据对齐是一种数据蒸馏形式，已被其他基于生成模型的持续学习方法采用，如 [89] 和 [126]。</p>
<h4 id="432-隐式数据对齐">4.3.2 隐式数据对齐<a class="anchor-link" href="#432-隐式数据对齐" title="Permanent link">&para;</a></h4>
<p>LwM [74] 通过稳定模型的注意力来对抗遗忘。使用 Grad-CAM [127]，它计算注意力图并在学习新任务时保留旧任务的注意力区域，确保特征提取能力得以保留。此外，LwM 实现了类似于 LwF 的 logits 级蒸馏，以加强旧任务知识的巩固。它按照以下方程蒸馏注意力图，其中 <span class="math-inline">\hat{Q}</span> 和 <span class="math-inline">Q</span> 分别表示旧学习模型和新学习模型的向量化注意力图：<br />
<div class="math-display"><br />
    L_{\text{KD}} = \left| \frac{\hat{Q}}{|\hat{Q}|_2} - \frac{Q}{|Q|_2} \right|_1 \tag{24}<br />
</div><br />
PGMA [89] 通过利用基于变分自编码器（VAE）的生成器 [128] 合成先前任务数据来缓解遗忘。VAE 具有一个将输入压缩为潜在表示的编码器和一个从该代码重建输入的解码器。由于生成器本身也必须持续学习以合成新任务数据，PGMA 在 VAE 的持续学习期间对编码器的样本特定潜在代码应用 L2 损失进行蒸馏。通过调节潜在空间，该策略有助于抑制 VAE 模型中的遗忘。</p>
<h3 id="44-讨论">4.4 讨论<a class="anchor-link" href="#44-讨论" title="Permanent link">&para;</a></h3>
<p>对于这三个层次的 KD，logits 级蒸馏约束了分类头的最终输出，提供了丰富的信息，但其有效性取决于教师模型的质量和知识转移的形式。特征级蒸馏侧重于特征空间，允许蒸馏不同维度的特征和空间关系，这有利于语义保留，但缺乏对分类头的记忆保留。数据级蒸馏较少见，主要用于生成合成回放数据或某些特殊场景。</p>
<h2 id="5-实验">5. 实验<a class="anchor-link" href="#5-实验" title="Permanent link">&para;</a></h2>
<p>在本节中，我们在三个图像分类数据集上对十种集成 KD 的持续学习方法进行了实验，并通过广泛的消融研究探讨了 KD 在持续学习中的作用。</p>
<h3 id="51-数据集">5.1 数据集<a class="anchor-link" href="#51-数据集" title="Permanent link">&para;</a></h3>
<p>我们选择了三个在持续学习领域广泛使用的图像分类数据集：CIFAR-100、TinyImageNet 和 ImageNet-100，涵盖了从 32×32、64×64 到 224×224 像素的图像分辨率。CIFAR-100 [129] 来自“8000 万小图像”集合 [130]，包含 100 个不同类别，每个类别有 500 张训练图像和 100 张测试图像，分辨率为 32×32 像素。ImageNet [131] 是一个大规模数据集，包含 128 万张训练图像和 5 万张验证图像，分布在 1000 个类别中。ImageNet 数据集衍生出各种变体，在持续学习研究中有时命名不一致。我们提供统一的命名以明确：ImageNet-1000 或 ImageNet-Full 指完整数据集，而 ImageNet-100 由 iCaRL [46] 引入，也称为 ImageNet-Subset，是前 100 个 ImageNet 类别的固定随机种子洗牌。研究 [82, 98, 100, 103] 和 [81] 通常将 ImageNet-100 视为遵循 iCaRL 设置的标准基准。TinyImageNet [132] 是斯坦福大学创建的 ImageNet 缩小版，包含 200 个类别，图像下采样为 64×64 像素。</p>
<h3 id="52-协议和场景">5.2 协议和场景<a class="anchor-link" href="#52-协议和场景" title="Permanent link">&para;</a></h3>
<p>我们的实验集中在 CIL 上，使用离线和平衡协议来评估不同的基线方法。在平衡和离线的 CIL 设置中，两种主要策略模拟数据增量场景：第一种将数据集划分为具有相等类别数的任务进行顺序学习。第二种从初步基础训练开始，使用剩余类别进行增量。为了清楚地描述这些场景，我们采用 [8] 中的符号。具体来说，第一种场景表示为（<span class="math-inline">AB</span>），其中 <span class="math-inline">A</span> 表示任务数，<span class="math-inline">B</span> 表示每个任务的类别数。例如，将 CIFAR-100 划分为十个顺序任务，每个任务十个类别，表示为（10/10）。第二种场景，涉及基础训练后类别增量，表示为（<span class="math-inline">AC-B</span>）。这里，<span class="math-inline">A</span> 表示总任务数，<span class="math-inline">C</span> 表示初始基础训练类别数（第一个任务），<span class="math-inline">B</span> 表示每个后续增量任务的类别数。例如，在 CIFAR-100 数据集中，（11/50-5）表示划分为 11 个任务——初始基础训练 50 个类别，随后将剩余的 50 个类别均匀分配到十个增量任务中，每个任务五个类别。</p>
<h3 id="53-指标">5.3 指标<a class="anchor-link" href="#53-指标" title="Permanent link">&para;</a></h3>
<p>在图像分类任务的持续学习中有许多评估指标。iCaRL [46] 引入了<strong>平均增量准确率</strong>（AIA），它捕捉了在所有任务完成后聚合平均准确率（AA）的平均值。同时，GEM [133] 引入了<strong>AA</strong>、<strong>后向转移</strong>（BWT）和<strong>前向转移</strong>（FWT）来评估灾难性遗忘的程度和知识的可转移性。此外，RWalk [134] 提出了<strong>遗忘度量</strong>（FM）和<strong>顽固度量</strong>（IM）来评估模型的平均遗忘和无法学习新任务的能力。</p>
<p>我们对表 I 中列出的文章进行了统计分析，发现<strong>AA</strong>是 CIL 中最常用的指标。其他指标最初是为 TIL 设计的，对 CIL 的适用性有限 [8]。因此，我们采用<strong>AA</strong>作为主要指标。<strong>AA</strong>评估学习第 <span class="math-inline">t</span> 个任务后的平均性能，可以定义为：<br />
<div class="math-display"><br />
    \text{AA}<em>t = \sum</em>{i=1}^{t} \frac{C_i}{C_{1:t}} a_{t,i} \tag{25}<br />
</div><br />
其中，<span class="math-inline">a_{t,i}</span> 是在学习任务 <span class="math-inline">t</span> 后对任务 <span class="math-inline">i</span> 的测试集评估的准确率，且 <span class="math-inline">i \leq t</span>。<span class="math-inline">C_i</span> 表示任务 <span class="math-inline">i</span> 包含的类别数，而 <span class="math-inline">C_{1:t}</span> 表示到任务 <span class="math-inline">t</span> 为止所有任务涵盖的类别累计数。</p>
<h3 id="54-基线方法">5.4 基线方法<a class="anchor-link" href="#54-基线方法" title="Permanent link">&para;</a></h3>
<p>我们从表 I 中选择了十种集成 KD 的持续学习方法，以便进行详尽的比较分析。这些选定的方法包括 LwF [45]、LwM [74]、IL2A [107]、PASS [106]、PRAKA [111]、iCaRL [46]、EEIL [78]、BiC [93]、LUCIR [96] 和 SS-IL [97]。每种方法都体现了第 III 和 IV 节讨论的 KD 集成持续学习的不同方面。更具体地说，LwF 和 LwM 属于“KD 作为正则化”范式。iCaRL、EEIL、BiC、LUCIR 和 SS-IL 属于“KD 与数据回放结合”范式，而 PASS、IL2A 和 PRAKA 属于“KD 与特征回放结合”范式。此外，当按知识源类型分类时，LwF、iCaRL、EEIL、BiC 和 SS-IL 被归类为 logits 级蒸馏技术。LUCIR、PASS 和 IL2A 被归类为特征级蒸馏，而 LwM 被视为数据级蒸馏方法。</p>
<h3 id="55-训练细节">5.5 训练细节<a class="anchor-link" href="#55-训练细节" title="Permanent link">&para;</a></h3>
<p>我们在所有基线方法中采用 ResNet-18 [135] 作为标准骨干网络，因为它在图像分类和持续学习基准中广泛使用。ResNet-18 专为大规模和高分辨率图像数据集（如 ImageNet）设计，在本研究中进行了修改以更好地适应较小分辨率的数据集。我们通过将初始卷积层的核大小从 <span class="math-inline">7 \times 7</span> 减小到 <span class="math-inline">3 \times 3</span> 并省略初始的最大池化操作来调整 ResNet-18。修改后的 ResNet-18 用于 CIFAR-100 和 TinyImageNet 的训练，而原始架构保留用于 ImageNet-100 以适应其高分辨率图像。</p>
<p>我们使用 FACIL [8] 框架实现了第 V-D 节中选择的所有方法，该框架在 PyTorch 中实现。对于除 IL2A、PASS 和 PRAKA 之外的所有方法，我们使用初始学习率为 0.1、动量为 0.9、权重衰减为 0.0002 的随机梯度下降（SGD）优化器。IL2A、PASS 和 PRAKA 使用初始学习率为 0.001、动量为 0.9 的 Adam 优化器。学习率每 45 个 epoch 减少 0.1 倍。对于所有基于样本的方法，我们使用 herding 采样策略。所有实验结果通过五次试验获得，并计算结果的均值和标准差。</p>
<h3 id="56-结果">5.6 结果<a class="anchor-link" href="#56-结果" title="Permanent link">&para;</a></h3>
<p>在本节中，我们首先在不同数据集上对基线方法进行了实验比较。随后，我们深入探讨了 KD 在缓解遗忘中的作用的详细实验和深入分析。</p>
<h4 id="561-数据集上的表现">5.6.1 数据集上的表现<a class="anchor-link" href="#561-数据集上的表现" title="Permanent link">&para;</a></h4>
<p>在本节中，我们评估了基线方法在不同分辨率的数据集上的表现：CIFAR-100（100 个类别，32×32）、TinyImageNet（200 个类别，64×64）和 ImageNet-100（100 个类别，224×224）。我们在两种场景下进行比较：没有基础训练的十任务场景和有基础训练的十一任务场景。对于数据回放方法，我们使用一个增长的内存，每个任务保留 20 个样本。</p>
<p>表 II 展示了几种基线策略在不同分辨率数据集上的实验结果：CIFAR-100、TinyImageNet 和 ImageNet-100。在没有基础训练的十任务场景中，BiC 方法在所有数据集上表现最佳。在有基础训练的十一任务场景中，PRAKA 在所有数据集上表现最佳。在有或没有基础训练的场景中，“KD 与数据回放结合”范式的方法表现良好。在没有基础训练的场景中，“KD 与特征回放结合”范式的方法表现略逊于数据回放范式的方法。然而，在有基础训练的情况下，特征回放方法的性能显著提高，PRAKA 在所有数据集上优于使用数据回放范式的方法。相比之下，“KD 作为正则化”范式的方法仅使用 KD 技术，在所有数据集上的表现明显较差。在有基础训练的场景中，LwF 和 LwM 的表现低于没有基础训练的场景。这种差异归因于 LwF 和 LwM 在获取新知识时使用的局部分类损失，其中仅学习新任务的分类头。相反，其他方法通常在包含基础训练时表现更好，除了 BiC 和 SS-IL 在 ImageNet-100 上表现更好。值得注意的是，随着数据集分辨率的增加，基础训练对 BiC 和 SS-IL 的相对益处减弱。</p>
<h4 id="562-kd-效果">5.6.2 KD 效果<a class="anchor-link" href="#562-kd-效果" title="Permanent link">&para;</a></h4>
<p>本节通过进行消融研究来深入探讨 KD 在持续学习方法中的作用，这些研究省略了 KD 损失。我们分析了十种方法，主要使用单一的蒸馏损失函数，除了 LwM，它采用了两种形式的蒸馏损失。我们移除了 LwF、iCaRL 和 BiC 使用的 logits 级蒸馏损失以评估其影响。对于 EEIL，我们消除了其在平衡和不平衡训练阶段使用的 TKD 损失。SS-IL 同样通过移除其补充分离 softmax 的 TKD 损失进行调整。对于 IL2A、PASS 和 PRAKA，我们取消了 L2 基于特征蒸馏损失，这对于实例特征对齐至关重要。LUCIR 的修改包括移除余弦特征蒸馏损失。在 LwM 中，我们仅移除了注意力图蒸馏损失——这被视为隐式数据蒸馏——以隔离注意力蒸馏的效果，保留其 logits 级蒸馏。</p>
<p>表 III 突出了 KD 对 CIFAR-100 上不同持续学习方法在（10/10）和（11/50-5）场景中的影响。从表 III 可以看出，KD 在遵循“KD 与特征回放结合”范式的方法中起着至关重要的作用。无论在有或没有基础训练的场景中，移除 KD 都会导致性能急剧下降。同样，KD 在 LwF 方法中也起着重要作用，而在 LwM 方法中，使用注意力图蒸馏可以略微增强抗遗忘能力。然而，对于“KD 与数据回放结合”范式的方法，结果有所不同。表 III 显示，在有基础训练的场景中，KD 对缓解遗忘有显著贡献，一旦移除蒸馏，所有方法都表现出性能下降。在没有基础训练的场景中，EEIL、BiC 和 SS-IL 在移除 KD 后也表现出性能下降。相反，iCaRL 和 LUCIR 表现出性能提升，iCaRL 显示出显著增加，LUCIR 显示出较小的增加。在“KD 与数据回放结合”范式的所有方法中，BiC 和 SS-IL 对蒸馏的依赖性最强，一旦蒸馏被禁用，两种场景中均表现出明显的性能下降。</p>
<h4 id="563-kd-损失">5.6.3 KD 损失<a class="anchor-link" href="#563-kd-损失" title="Permanent link">&para;</a></h4>
<p>为了评估不同 KD 损失在缓解遗忘中的有效性，我们对各种 KD 损失进行了独立评估，未使用任何额外的防止遗忘技术。我们评估了 logits 级的交叉熵、KL 散度和 L2 距离损失，以及基于 L2 距离和余弦相似度的实例特征对齐损失。对于持续学习中的分类损失，我们采用了 LwF [45] 的方法，其中仅训练当前任务的分类头，而先前任务的分类头仅参与蒸馏，因为在不使用先前任务数据的情况下使用全局分类损失会导致严重的分类偏差问题，并显著降低 KD 的有效性。</p>
<p>表 IV 展示了不同 KD 损失在缓解遗忘中的能力。可以观察到，所有 KD 损失都表现出一定程度的遗忘缓解。其中，logits 级 KD 损失在缓解遗忘方面明显优于特征级 KD 损失。这是因为 logits 级 KD 损失对最终分类头施加了约束，而特征级 KD 损失仅对网络的特征提取部分添加了约束。因此，logits 级 KD 损失比特征级 KD 损失更有效。这一发现表明，在图像分类任务的持续学习中，对分类头添加遗忘缓解约束可以进一步增强模型的整体抗遗忘能力。在所有 logits 级 KD 损失中，具有更强约束能力的 L2 距离损失在缓解遗忘方面优于 KL 散度，而交叉熵蒸馏损失的效果最差。对于特征级 KD 损失，包含更多语义信息的余弦相似度损失在缓解遗忘方面优于 L2 距离损失。</p>
<h4 id="564-kd-与数据回放">5.6.4 KD 与数据回放<a class="anchor-link" href="#564-kd-与数据回放" title="Permanent link">&para;</a></h4>
<p>为了进一步理解 KD 与数据回放结合时的作用，并探索不同 KD 损失的效果，我们比较了几种 KD 损失与使用 herding 算法进行增长内存的基本回放范式，每个类别保留 20 个样本。我们评估了与第 V-F3 节相同的 KD 损失。对于持续学习中的分类损失，我们采用了大多数回放方法 [46, 78, 96] 中常用的全局分类损失。通过这一比较，我们旨在更深入地了解每种 KD 损失在持续学习与数据回放中的具体贡献。</p>
<p>表 V(a) 显示了 KD 与数据回放的结合。令人惊讶的是，我们发现无论是否应用基础训练，引入 logits 级 KD 都会导致性能下降，这与其他研究 [8, 136, 137] 的观察结果一致。在没有基础训练的情况下，logits 级 KD 对性能的负面影响尤为显著。在没有基础训练的情况下，KL 散度 KD 损失造成的损害最大，而交叉熵 KD 损失的损害略小。相比之下，特征级 KD 在两种场景中都显示出一定的遗忘缓解效果，尽管这种改善的程度有限。在有基础训练的情况下，余弦相似度损失在保留学习特征方面显示出优势。然而，在没有基础训练的情况下，余弦相似度损失在保持记忆方面的效果不如 L2 损失。</p>
<p>受 SS-IL [97] 和第 V-F3 节的启发，我们假设这也可能是由于分类头引入的分类偏差。为了验证我们的假设，我们遵循 SS-IL 并使用分离的 softmax 损失来学习分类头，即使用回放数据联合训练所有旧任务分类头，而新任务数据仅用于训练新任务分类头。表 V(b) 证实了我们的假设，即分类头引入的分类偏差确实影响了 KD 的性能。令人惊讶的是，即使不使用 KD，带有分离 softmax 的数据回放也优于带有全局分类的数据回放。当添加 KD 时，除了在（10/10）场景中使用交叉熵外，所有配置都对防止遗忘产生了积极影响。在有基础训练的场景中，logits 级 KD 显示出显著的性能提升。这强烈表明分类偏差影响了 KD 的有效性，尤其是 logits 级 KD。在 logits 级 KD 中，L2 损失仍然是最有效的，其次是 KL 散度，交叉熵的效果最差。L2 损失和 KL 散度甚至优于 SS-IL 中使用的 TKD。此外，logits 级 KD 始终比特征级 KD 更有效，这与第 V-F3 节中获得的结果一致。此外，BiC 和 SS-IL 是“KD 与数据回放结合”范式中对 KD 依赖性最强的方法，这进一步支持了分类偏差显著影响 KD 有效性的结论。</p>
<h2 id="6-kd-在其他任务中的应用">6. KD 在其他任务中的应用<a class="anchor-link" href="#6-kd-在其他任务中的应用" title="Permanent link">&para;</a></h2>
<p>除了图像分类，KD 还被广泛应用于其他视觉任务中的持续学习，如目标检测和语义分割。为了讨论与图像分类中 KD 应用的异同，并评估 KD 在这些不同任务中缓解遗忘的有效性，我们进行了比较实验以评估 KD 在这些任务中的影响。</p>
<h3 id="61-方法和实验设置">6.1 方法和实验设置<a class="anchor-link" href="#61-方法和实验设置" title="Permanent link">&para;</a></h3>
<p>我们选择了四种集成 KD 的方法：两种用于持续目标检测 [138, 139]，两种用于持续语义分割 [140, 141]。对于持续目标检测任务，Faster ILOD [138] 使用了三种蒸馏损失：一种应用于特征图，使用归一化自适应蒸馏和 L1 损失；另一种应用于区域提议网络（RPN）输出，使用 L2 损失；第三种应用于分类和边界框预测头 [区域分类和回归网络（RCN）] 的输出，使用 L2 损失。在 Faster ILOD 的基础上，ABR [139] 引入了注意力区域感兴趣（RoI）蒸馏损失以增强特征蒸馏，并引入包容性蒸馏损失以改进 RCN 输出的蒸馏。对于持续语义分割任务，REMINDER [140] 在分割输出上应用类别相似性 KD 损失，以修正可能因与新类别相似而被遗忘的旧类别知识，并结合局部池化输出蒸馏（Local POD）[142] 应用于中间层的特征。LGKD [141] 也将 Local POD 损失应用于网络的中间层特征。对于分割输出，它引入了标签引导的 KD 损失，以帮助模型在蒸馏过程中正确建立新类别与背景之间的对应关系。</p>
<p>我们对两种持续目标检测方法进行了消融研究，分别评估了特征、RPN 和 RCN 输出的蒸馏效果。对于持续语义分割，我们评估了特征和分割输出的蒸馏效果。这些实验旨在衡量每种蒸馏损失在缓解遗忘中的有效性。为了隔离 KD 的效果，我们从 ABR 方法中移除了回放模块。使用 Pascal 视觉对象类（VOC）数据集，我们测试了两种持续学习场景：（2/15-5）和（6/15-1）。性能使用平均精度（mAP）进行持续目标检测，使用平均交并比（mIoU）进行持续语义分割。对于这两种任务，我们计算了初始任务 1-15 类别的平均指标、后续增量任务的平均指标以及学习所有类别后的最终平均指标。所有实验均基于各自方法的原始代码进行。</p>
<h3 id="62-结果与讨论">6.2 结果与讨论<a class="anchor-link" href="#62-结果与讨论" title="Permanent link">&para;</a></h3>
<p>可以观察到，对于持续目标检测和持续语义分割，蒸馏损失可以大致分为特征级蒸馏和输出级蒸馏（类似于图像分类任务中的 logits 级）。在持续目标检测中，特征蒸馏和 RPN 蒸馏可以被视为特征级蒸馏，而 RCN 蒸馏是对模型输出的蒸馏。为了与图像分类任务中的 logits 级蒸馏区分开来，我们将其称为输出级蒸馏。同样，对于两种持续语义分割方法，使用的 Local POD 损失属于特征级 KD，而对最终分割结果的蒸馏属于输出级蒸馏。</p>
<p>表 VI 显示了在 Faster ILOD 和 ABR 中使用不同蒸馏方法的效果，而表 VII 展示了在 REMINDER 和 LGKD 中使用不同蒸馏损失的效果。两组结果都表明，KD 在这两种任务中缓解遗忘的关键作用。对于持续目标检测任务，从表 VI 可以看出，RCN 蒸馏损失（蒸馏最终输出）在缓解遗忘方面比特征蒸馏和 RPN 蒸馏（均属于特征级蒸馏）起着更重要的作用。对于持续语义分割任务，特征级和输出级 KD 都可以在一定程度上缓解遗忘。特别是在更复杂的持续学习场景（6/15-1）中，特征级 KD 在缓解遗忘方面显著优于输出级 KD。</p>
<h2 id="7-持续学习与-kd-的未来趋势">7. 持续学习与 KD 的未来趋势<a class="anchor-link" href="#7-持续学习与-kd-的未来趋势" title="Permanent link">&para;</a></h2>
<p>本节主要从三个不同的视角展望了持续学习与 KD 的未来趋势。</p>
<h3 id="71-高质量知识的-kd">7.1 高质量知识的 KD<a class="anchor-link" href="#71-高质量知识的-kd" title="Permanent link">&para;</a></h3>
<p>KD 在缓解持续学习中的灾难性遗忘方面显示出潜力，但仍有很大的改进空间。有效的知识转移取决于被蒸馏的知识的质量。高质量的知识转移对于提高 KD 在持续学习中的性能至关重要。</p>
<p>最近的进展突出了各种旨在提高蒸馏知识质量的方法。DER++ [86] 匹配优化轨迹中的 logits 样本。XDER [60] 植入 logits 以防止教师模型丢失有价值的次要信息。OCD-Net [87] 从通过随机动量更新训练的在线教师中学习知识。这些方法专注于保留关键的历史知识以提高记忆保留。在 KD 领域，许多方法旨在实现更高效的知识转移，例如在多层次上传递 logits 中的知识 [143]，logits 中目标类和非目标类知识的不同影响 [144]，以及通过逆概率加权蒸馏尊重转移差距 [145]。这些多样化的方法突出了各种蒸馏方法在提高知识转移质量方面的潜力。未来的持续学习与 KD 研究应优先开发更复杂的技术以识别高质量知识。</p>
<h3 id="72-针对特定任务的-kd">7.2 针对特定任务的 KD<a class="anchor-link" href="#72-针对特定任务的-kd" title="Permanent link">&para;</a></h3>
<p>持续学习已从最初的分类任务扩展到涵盖广泛的其他任务，如目标检测 [138, 139, 146, 147, 148]、语义分割 [140, 141, 142] 在视觉领域，语言学习 [149, 150]、机器翻译 [151, 152]、意图检测 [153, 154] 和命名实体识别 [155] 在 NLP 领域。</p>
<p>KD 在这些各种任务中缓解遗忘也起着至关重要的作用。这些持续学习领域中的方法以类似于图像分类的方式使用 KD，利用特征级或任务输出级（图像分类任务中的 logits 级）的蒸馏。然而，由于任务领域内问题的特殊性，许多蒸馏方法是基于任务特性专门设计的。例如，Shmelkov 等人 [147] 提出了在持续目标检测中对分类和边界框回归网络输出的 RCN 蒸馏。Peng 等人 [138] 通过将 KD 应用于目标检测框架中 RPN 内的特征来缓解遗忘。ABR [139] 使用注意力 RoI 蒸馏，利用 RoI 特征的空间注意力。LGKD [141] 提出了标签引导的 KD，以帮助模型在持续语义分割过程中正确建立新类别与背景之间的对应关系。在 NLP 领域，DnR [149] 执行三种不同的蒸馏方法以匹配持续语言学习中的内部表示。CL-NMT [151] 提出了动态 KD 损失，以平衡持续学习中对旧知识和新知识的注意力。在意图检测任务中，CID [153] 采用分层 KD 以保留先前类别的特征和概率分布。未来，KD 将继续在这些持续学习任务中发挥重要作用。设计更符合这些任务特性的蒸馏损失将是至关重要的。此外，识别容易遗忘的任务关键组件，并利用 KD 来缓解遗忘，也将是至关重要的。</p>
<h3 id="73-更好的教师模型的-kd">7.3 更好的教师模型的 KD<a class="anchor-link" href="#73-更好的教师模型的-kd" title="Permanent link">&para;</a></h3>
<p>近年来，基于预训练模型（PTM）和大语言模型（LLM）的持续学习引起了越来越多的关注。KD 是一种天然有利于缓解 PTM 和 LLM 持续学习中遗忘的方法。这是因为 KD 遵循教师 - 学生框架，而 PTM 和 LLM 已经拥有丰富的知识，有效地从经验丰富的教师开始其持续学习。</p>
<p>然而，当前基于 PTM 的持续学习方法 [63, 156, 157, 158] 主要集成了参数高效微调（PEFT）技术 [159, 160, 161, 162]，通过微调少量任务相关参数来实现新任务的持续学习，同时保持 PTM 的基础知识不变。在基于 PTM 的持续学习中，KD 的探索有限。未来的研究可以探索如何利用 KD 来保持 PTM 的基础知识，同时最小化 PEFT 在新知识获取过程中引入的参数变化。</p>
<p>关于 LLM，KD 已经在 LLM 训练中发挥了重要作用，通过弥合专有商业 LLM 和开源 LLM 之间由于预训练数据量差异而导致的性能差距 [163]。对于 LLM 持续学习，KD 也是缓解整个持续学习过程中遗忘的重要策略，包括持续预训练、领域自适应预训练和持续微调 [164]。未来，LLM 的持续学习不仅涉及通过新数据持续学习未知任务，还旨在通过从具有不同架构的专家 LLM 中蒸馏知识到一个统一的 LLM 中实现整体知识增长。因此，异构架构 KD [165] 将变得尤为重要。此外，多模态 LLM 预计将成为趋势，使得跨模态 KD [166, 167] 成为这些多模态模型持续学习的关键技术。</p>
<h2 id="8-结论">8. 结论<a class="anchor-link" href="#8-结论" title="Permanent link">&para;</a></h2>
<p>本研究对利用 KD 的持续学习方法进行了深入调查。我们详细分析了 KD 在持续学习方法中的应用，并将其应用分为三种不同的范式。此外，我们根据知识源对这些方法进行了分类，并概述了不同的蒸馏损失以防止遗忘。在三个数据集上的十种集成 KD 方法的广泛实验突出了 KD 在持续学习中的作用，我们还证实了分类偏差会损害 KD 的性能，而分离的 softmax 损失可以缓解这一问题。此外，我们探讨了 KD 在其他视觉任务中缓解遗忘的有效性，并讨论了持续学习与 KD 的未来方向。本文旨在加深对 KD 在持续学习中影响的理解，并为该领域的持续研究提供信息。</p>
                </div>

                <!-- Comments Section (Giscus) -->
                <section class="comments-section">
                    <h3><i class="fas fa-comments"></i> 评论</h3>
                    <script src="https://giscus.app/client.js"
                        data-repo="Geeks-Z/Geeks-Z.github.io"
                        data-repo-id=""
                        data-category="Announcements"
                        data-category-id=""
                        data-mapping="pathname"
                        data-strict="0"
                        data-reactions-enabled="1"
                        data-emit-metadata="0"
                        data-input-position="bottom"
                        data-theme="preferred_color_scheme"
                        data-lang="zh-CN"
                        crossorigin="anonymous"
                        async>
                    </script>
                </section>
            </article>

            <footer class="post-footer">
                <p>© 2025 Hongwei Zhao. Built with ❤️</p>
            </footer>
        </main>
    </div>

    <!-- Theme Toggle Button -->
    <button class="theme-toggle" id="themeToggle" aria-label="切换主题">
        <i class="fas fa-moon"></i>
    </button>

    <script>
        // Theme Toggle
        const themeToggle = document.getElementById('themeToggle');
        const html = document.documentElement;
        const icon = themeToggle.querySelector('i');
        const hljsDark = document.getElementById('hljs-theme-dark');
        const hljsLight = document.getElementById('hljs-theme-light');
        
        // Check saved theme or system preference
        const savedTheme = localStorage.getItem('theme');
        const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
        
        if (savedTheme === 'dark' || (!savedTheme && prefersDark)) {
            html.setAttribute('data-theme', 'dark');
            icon.className = 'fas fa-sun';
            hljsDark.disabled = false;
            hljsLight.disabled = true;
        }
        
        themeToggle.addEventListener('click', () => {
            const isDark = html.getAttribute('data-theme') === 'dark';
            if (isDark) {
                html.removeAttribute('data-theme');
                icon.className = 'fas fa-moon';
                localStorage.setItem('theme', 'light');
                hljsDark.disabled = true;
                hljsLight.disabled = false;
            } else {
                html.setAttribute('data-theme', 'dark');
                icon.className = 'fas fa-sun';
                localStorage.setItem('theme', 'dark');
                hljsDark.disabled = false;
                hljsLight.disabled = true;
            }
            
            // Update Giscus theme
            const giscusFrame = document.querySelector('iframe.giscus-frame');
            if (giscusFrame) {
                giscusFrame.contentWindow.postMessage({
                    giscus: {
                        setConfig: {
                            theme: isDark ? 'light' : 'dark'
                        }
                    }
                }, 'https://giscus.app');
            }
        });
        
        // Highlight.js
        document.addEventListener('DOMContentLoaded', () => {
            hljs.highlightAll();
        });
        
        // KaTeX auto-render
        document.addEventListener('DOMContentLoaded', () => {
            if (typeof renderMathInElement !== 'undefined') {
                renderMathInElement(document.body, {
                    delimiters: [
                        {left: '$$', right: '$$', display: true},
                        {left: '$', right: '$', display: false},
                        {left: '\\[', right: '\\]', display: true},
                        {left: '\\(', right: '\\)', display: false}
                    ],
                    throwOnError: false
                });
            }
        });
        
        // TOC active state
        const tocLinks = document.querySelectorAll('.toc-container a');
        const headings = document.querySelectorAll('.post-content h2, .post-content h3, .post-content h4');
        
        function updateTocActive() {
            let current = '';
            headings.forEach(heading => {
                const rect = heading.getBoundingClientRect();
                if (rect.top <= 100) {
                    current = heading.getAttribute('id');
                }
            });
            
            tocLinks.forEach(link => {
                link.classList.remove('active');
                if (link.getAttribute('href') === '#' + current) {
                    link.classList.add('active');
                }
            });
        }
        
        window.addEventListener('scroll', updateTocActive);
        updateTocActive();
    </script>
</body>
</html>
