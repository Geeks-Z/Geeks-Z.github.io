<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Untitled</title>
    <meta name="description" content="Untitled - Hongwei Zhao's Blog">
    <meta name="author" content="Hongwei Zhao">
    
    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Noto+Sans+SC:wght@300;400;500;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    
    <!-- Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <!-- Code Highlighting -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css" id="hljs-theme-dark">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css" id="hljs-theme-light" disabled>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    
    <!-- KaTeX for Math -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>
    
    <style>
        :root {
            /* Light Theme - 明亮清新配色 */
            --primary-color: #4A90D9;
            --primary-hover: #3678C2;
            --link-color: #E86B5F;
            --text-color: #2D2D2D;
            --text-light: #5A5A5A;
            --text-muted: #8A8A8A;
            --bg-color: #FFFFFF;
            --bg-secondary: #F5F7FA;
            --bg-code: #F8F9FC;
            --border-color: #E8ECF0;
            --shadow: 0 2px 8px rgba(0,0,0,0.06);
            --shadow-lg: 0 8px 24px rgba(0,0,0,0.08);
        }

        [data-theme="dark"] {
            --primary-color: #5dade2;
            --primary-hover: #85c1e9;
            --link-color: #e74c3c;
            --text-color: #e5e7eb;
            --text-light: #9ca3af;
            --text-muted: #6b7280;
            --bg-color: #1a1a2e;
            --bg-secondary: #16213e;
            --bg-code: #0f0f23;
            --border-color: #374151;
            --shadow: 0 1px 3px rgba(0,0,0,0.3);
            --shadow-lg: 0 4px 15px rgba(0,0,0,0.4);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            scroll-behavior: smooth;
        }

        body {
            font-family: 'Inter', 'Noto Sans SC', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            font-size: 16px;
            line-height: 1.8;
            color: var(--text-color);
            background: var(--bg-color);
            transition: background-color 0.3s, color 0.3s;
        }

        a {
            color: var(--primary-color);
            text-decoration: none;
            transition: color 0.2s;
        }

        a:hover {
            color: var(--primary-hover);
            text-decoration: underline;
        }

        /* Layout */
        .page-wrapper {
            display: flex;
            max-width: 1400px;
            margin: 0 auto;
            padding: 2rem;
            gap: 3rem;
        }

        /* Sidebar TOC */
        .toc-sidebar {
            width: 260px;
            flex-shrink: 0;
            position: sticky;
            top: 2rem;
            height: fit-content;
            max-height: calc(100vh - 4rem);
            overflow-y: auto;
        }

        .toc-container {
            background: var(--bg-secondary);
            border-radius: 12px;
            padding: 1.5rem;
            border: 1px solid var(--border-color);
        }

        .toc-container h3 {
            font-size: 0.85rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-muted);
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .toc-container ul {
            list-style: none;
        }

        .toc-container li {
            margin-bottom: 0.5rem;
        }

        .toc-container a {
            font-size: 0.9rem;
            color: var(--text-light);
            display: block;
            padding: 0.25rem 0;
            border-left: 2px solid transparent;
            padding-left: 0.75rem;
            transition: all 0.2s;
        }

        .toc-container a:hover,
        .toc-container a.active {
            color: var(--primary-color);
            border-left-color: var(--primary-color);
            text-decoration: none;
        }

        .toc-container ul ul {
            margin-left: 1rem;
        }

        /* Main Content */
        .main-content {
            flex: 1;
            min-width: 0;
            max-width: 800px;
        }

        /* Header */
        .post-header {
            margin-bottom: 2rem;
            padding-bottom: 1.5rem;
            border-bottom: 1px solid var(--border-color);
        }

        .back-link {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.9rem;
            color: var(--text-light);
            margin-bottom: 1.5rem;
        }

        .back-link:hover {
            color: var(--primary-color);
            text-decoration: none;
        }

        .post-header h1 {
            font-size: 2.25rem;
            font-weight: 700;
            line-height: 1.3;
            margin-bottom: 1rem;
            color: var(--text-color);
        }

        .post-meta {
            display: flex;
            flex-wrap: wrap;
            gap: 1.5rem;
            font-size: 0.9rem;
            color: var(--text-light);
        }

        .post-meta span {
            display: flex;
            align-items: center;
            gap: 0.4rem;
        }

        .post-meta i {
            color: var(--text-muted);
        }

        .tags {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-top: 1rem;
        }

        .tag {
            display: inline-block;
            font-size: 0.8rem;
            background: var(--bg-secondary);
            color: var(--text-light);
            padding: 0.25rem 0.75rem;
            border-radius: 20px;
            border: 1px solid var(--border-color);
            transition: all 0.2s;
        }

        .tag:hover {
            background: var(--primary-color);
            color: white;
            border-color: var(--primary-color);
        }

        /* Article Content */
        .post-content {
            font-size: 1rem;
            line-height: 1.9;
        }

        .post-content h1,
        .post-content h2,
        .post-content h3,
        .post-content h4,
        .post-content h5,
        .post-content h6 {
            margin-top: 2rem;
            margin-bottom: 1rem;
            font-weight: 600;
            line-height: 1.4;
            color: var(--text-color);
        }

        .post-content h1 { font-size: 1.875rem; }
        .post-content h2 { 
            font-size: 1.5rem; 
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--border-color);
        }
        .post-content h3 { font-size: 1.25rem; }
        .post-content h4 { font-size: 1.125rem; }

        .post-content p {
            margin-bottom: 1.25rem;
        }

        .post-content ul,
        .post-content ol {
            margin: 1.25rem 0;
            padding-left: 1.5rem;
        }

        .post-content li {
            margin-bottom: 0.5rem;
        }

        .post-content blockquote {
            margin: 1.5rem 0;
            padding: 1rem 1.5rem;
            background: var(--bg-secondary);
            border-left: 4px solid var(--primary-color);
            border-radius: 0 8px 8px 0;
            color: var(--text-light);
            font-style: italic;
        }

        .post-content blockquote p:last-child {
            margin-bottom: 0;
        }

        /* Code */
        .post-content code {
            font-family: 'JetBrains Mono', 'Fira Code', Consolas, monospace;
            font-size: 0.9em;
            background: var(--bg-code);
            padding: 0.2em 0.4em;
            border-radius: 4px;
            color: var(--link-color);
        }

        .post-content pre {
            margin: 1.5rem 0;
            padding: 1.25rem;
            background: var(--bg-code);
            border-radius: 10px;
            overflow-x: auto;
            border: 1px solid var(--border-color);
        }

        .post-content pre code {
            background: none;
            padding: 0;
            color: inherit;
            font-size: 0.875rem;
            line-height: 1.6;
        }

        /* Images */
        .post-content img {
            max-width: 100%;
            height: auto;
            border-radius: 10px;
            margin: 1.5rem 0;
            box-shadow: var(--shadow-lg);
        }

        /* Tables */
        .post-content table {
            width: 100%;
            margin: 1.5rem 0;
            border-collapse: collapse;
            font-size: 0.95rem;
        }

        .post-content th,
        .post-content td {
            padding: 0.75rem 1rem;
            border: 1px solid var(--border-color);
            text-align: left;
        }

        .post-content th {
            background: var(--bg-secondary);
            font-weight: 600;
        }

        .post-content tr:nth-child(even) {
            background: var(--bg-secondary);
        }

        /* Math */
        .math-display {
            margin: 1.5rem 0;
            overflow-x: auto;
            padding: 1rem;
            background: var(--bg-secondary);
            border-radius: 8px;
        }

        /* Anchor links */
        .anchor-link {
            opacity: 0;
            margin-left: 0.5rem;
            color: var(--text-muted);
            font-weight: 400;
            transition: opacity 0.2s;
        }

        .post-content h2:hover .anchor-link,
        .post-content h3:hover .anchor-link,
        .post-content h4:hover .anchor-link {
            opacity: 1;
        }

        /* Theme Toggle */
        .theme-toggle {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: var(--primary-color);
            color: white;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.25rem;
            box-shadow: var(--shadow-lg);
            transition: transform 0.2s, background 0.2s;
            z-index: 1000;
        }

        .theme-toggle:hover {
            transform: scale(1.1);
            background: var(--primary-hover);
        }

        /* Comments Section */
        .comments-section {
            margin-top: 3rem;
            padding-top: 2rem;
            border-top: 1px solid var(--border-color);
        }

        .comments-section h3 {
            font-size: 1.25rem;
            margin-bottom: 1.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        /* Footer */
        .post-footer {
            margin-top: 3rem;
            padding-top: 1.5rem;
            border-top: 1px solid var(--border-color);
            text-align: center;
            font-size: 0.9rem;
            color: var(--text-muted);
        }

        /* Responsive */
        @media (max-width: 1024px) {
            .toc-sidebar {
                display: none;
            }
            
            .page-wrapper {
                padding: 1.5rem;
            }
        }

        @media (max-width: 768px) {
            .post-header h1 {
                font-size: 1.75rem;
            }
            
            .post-meta {
                flex-direction: column;
                gap: 0.5rem;
            }
            
            .theme-toggle {
                bottom: 1rem;
                right: 1rem;
                width: 44px;
                height: 44px;
            }
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-secondary);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--text-muted);
        }
    </style>
</head>
<body>
    <div class="page-wrapper">
        <!-- TOC Sidebar -->
        <aside class="toc-sidebar">
            <div class="toc-container">
                <h3><i class="fas fa-list"></i> 目录</h3>
                <div class="toc">
<ul>
<li><a href="#0-摘要">0. 摘要</a></li>
<li><a href="#1-引言">1. 引言</a></li>
<li><a href="#2-预备知识">2. 预备知识</a><ul>
<li><a href="#21-持续学习">2.1 持续学习</a></li>
<li><a href="#22-预训练模型">2.2 预训练模型</a></li>
<li><a href="#23-预训练模型带来的持续学习新见解">2.3 预训练模型带来的持续学习新见解</a></li>
</ul>
</li>
<li><a href="#3-使用预训练模型的持续学习">3. 使用预训练模型的持续学习</a><ul>
<li><a href="#31-提示法方法">3.1 提示法方法</a></li>
</ul>
</li>
</ul>
</div>

            </div>
        </aside>

        <!-- Main Content -->
        <main class="main-content">
            <article>
                <header class="post-header">
                    <a href="../../../../index.html" class="back-link">
                        <i class="fas fa-arrow-left"></i> 返回博客列表
                    </a>
                    <h1>Untitled</h1>
                    <div class="post-meta">
                        <span><i class="fas fa-calendar-alt"></i> 2026-02-04</span>
                        <span><i class="fas fa-folder"></i> AINotes/40.CIL/00.Survey</span>
                        <span><i class="fas fa-user"></i> Hongwei Zhao</span>
                    </div>
                    <div class="tags">
                        
                    </div>
                </header>

                <div class="post-content">
                    <h2 id="0-摘要">0. 摘要<a class="anchor-link" href="#0-摘要" title="Permanent link">&para;</a></h2>
<p>在当今世界的应用中，经常面临流数据，这要求学习系统随着数据的演变而吸收新知识。持续学习（Continual Learning, CL）旨在实现这一目标，并同时克服在学习新知识时对以前知识的巨大遗忘。典型的CL方法从零开始构建模型以适应新数据。然而，随着预训练模型（Pre-Trained Models, PTM）时代的来临，在利用PTMs的强大表示能力进行CL方面激发了巨大的研究兴趣。本文综述了基于PTM的CL的最新进展。我们将现有方法分为三个不同的组，并提供了它们之间的相似性、差异性以及各自的优势和劣势的比较分析。此外，我们提供了一个实证研究，比较了各种最先进方法，突出了比较中的公平性问题。可以在 https://github.com/sun-hailong/LAMDA-PILOT 找到重现这些评估的源代码。</p>
<h2 id="1-引言">1. 引言<a class="anchor-link" href="#1-引言" title="Permanent link">&para;</a></h2>
<p>随着深度神经网络的快速发展，深度学习模型在各种应用中展现出了有希望的结果 [He et al., 2016]。然而，现实世界情景通常以流格式呈现数据。隐私问题和存储限制等挑战阻碍了流数据的永久保留，需要一个能够适应和进化的持续学习系统，这个过程被称为持续学习 [van de Ven et al., 2022; De Lange et al., 2021; Masana et al., 2023]。CL中的一个关键问题是灾难性遗忘现象，即获取新知识会导致在以前学习的任务上的性能显著下降 [McCloskey and Cohen, 1989]。为了解决CL中的这一问题，已有许多研究投入其中 [Gunasekara et al., 2023; Fortin and Chaib-draa, 2022; Shibata et al., 2021; Sun et al., 2023; Wiwatcharakoses and Berrar, 2019; Li et al., 2022]。传统上，CL方法从“从头开始训练”的模型开始，即从随机初始化的权重开始。然而，预训练技术的繁荣开辟了新的途径。利用从大量数据集和复杂技术中开发的PTMs，已经显示出对CL的巨大希望。这些PTMs天生就具有对各种下游任务的强大泛化能力，使得基于PTM的CL成为日益流行的研究领域。图1展示了PTM基于和传统持续学习方法的差异。两种方法都在数据流中使用CL模型来适应一系列不断到来的任务。目标是使模型在学习新任务的同时保留以前获得的知识。这就需要在每个新任务学习后，对所有见过的任务进行模型评估。PTM基于和传统CL之间的主要区别在于CL模型的初始设置。PTM基于策略从大规模预训练模型开始，而传统方法则是从零开始训练的模型。这种差异可以类比于人类学习：传统方法类似于训练一个婴儿成长并学习新知识，而PTM基于方法则像利用成年人的专业知识来进行同样的学习任务。随着这个领域的快速发展，现有的关于CL的综述主要集中在不包含预训练模型的典型算法上 [van de Ven et al., 2022; De Lange et al., 2021; Masana et al., 2023]。然而，在当前的PTM时代，PTM基于CL正成为一个日益受到关注的中心领域。观察结果表明，基于PTM的CL的性能正在接近持续学习潜力的上限 [Zhou et al., 2023a]，这表明了一个有希望的实用应用途径。因此，迫切需要一个全面、当前的综述来推动CL领域的发展。我们的综述的具体贡献如下：</p>
<ol>
<li>
<p>我们首次全面综述了基于预训练模型的持续学习的最新进展，包括问题定义、基准数据集和评估协议。我们根据这些方法的定义特征将它们系统地分类为三个子类别，提供了一个全面和结构化的概述。</p>
</li>
<li>
<p>我们的评估扩展到了每个子类别中的代表性方法，跨越七个基准数据集。此外，我们确定了可能影响PTM持续学习比较公平性的关键因素，为方法评估提供了见解。</p>
</li>
<li>
<p>我们强调了基于PTM的持续学习当前的挑战和潜在的未来方向。我们旨在揭示研究不足的方面，以激发进一步的调查，探索该领域内的各种可能路径及其相互关系。</p>
</li>
</ol>
<h2 id="2-预备知识">2. 预备知识<a class="anchor-link" href="#2-预备知识" title="Permanent link">&para;</a></h2>
<h3 id="21-持续学习">2.1 持续学习<a class="anchor-link" href="#21-持续学习" title="Permanent link">&para;</a></h3>
<p>持续学习（Continual Learning, CL）专注于涉及一系列任务 <span class="math-inline">D_1, D_2, \ldots, D_B</span> 的学习场景。第 <span class="math-inline">b</span> 个数据集 <span class="math-inline">D_b = { X_b, Y_b }</span> 包含输入实例及其标签的集合，即 <span class="math-inline">X_b = { x_i }<em>{i=1}^{n_b}</span> 和 <span class="math-inline">Y_b = { y_i }</em>{i=1}^{n_b}</span>。其中 <span class="math-inline">x_i \in \mathbb{R}^D</span> 是类 <span class="math-inline">y_i \in Y_b</span> 的一个实例，<span class="math-inline">Y_b</span> 是任务 <span class="math-inline">b</span> 的标签空间。在第 <span class="math-inline">b</span> 个训练阶段，我们只能访问 <span class="math-inline">D_b</span> 中的数据。持续学习的目标是持续获取所有见过任务的知识，即拟合一个模型 <span class="math-inline">f(x)</span>，并最小化期望风险：<br />
<div class="math-display"><br />
    f^* = \arg\min_{f \in \mathcal{H}} \mathbb{E}<em>{(x,y) \sim D_1 \cup \ldots \cup D_B} \left[ I(y \neq f(x)) \right] \tag{1}<br />
</div><br />
在公式 (1) 中，<span class="math-inline">\mathcal{H}</span> 是假设空间，<span class="math-inline">I(\cdot)</span> 是指示函数，如果表达式成立则输出 1，否则输出 0。<span class="math-inline">D_b^t</span> 表示任务 <span class="math-inline">b</span> 的数据分布。因此，CL 模型应该在所有见过的任务上表现良好，即不仅要学习新任务，还要记住以前的任务。CL 的变体：基于“任务”的定义，有许多具体的 CL 变体 [van de Ven et al., 2022]，例如，类增量学习（Class-Incremental Learning, CIL）、任务增量学习（Task-Incremental Learning, TIL）和领域增量学习（Domain-Incremental Learning, DIL）。具体来说，在 CIL 和 TIL 的训练阶段，我们有 <span class="math-inline">p(X_b) \neq p(X</em>{b'})</span>, <span class="math-inline">Y_b \cap Y_{b'} = \emptyset</span> 对于 <span class="math-inline">b \neq b'</span>。换句话说，新任务包含以前未见过的类别，模型预期在学习新类别的同时不忘记以前的类别。然而，它们之间的差异在于测试阶段，TIL 为测试实例提供了任务 ID（即 <span class="math-inline">b</span>），而 CIL 则没有。另一方面，DIL 专注于 <span class="math-inline">p(X_b) \neq p(X_{b'})</span>, <span class="math-inline">Y_b = Y_{b'}</span> 对于 <span class="math-inline">b \neq b'</span> 的场景。例如，新任务包含同一类别的图像，但存在领域偏移，例如卡通画和油画。</p>
<h3 id="22-预训练模型">2.2 预训练模型<a class="anchor-link" href="#22-预训练模型" title="Permanent link">&para;</a></h3>
<p>在 PTM 的繁荣之前，持续学习方法主要依赖于残差网络（例如，ResNet [He et al., 2016]）作为骨干网络。然而，近年来，基于 Transformer 的骨干网络发展迅速，并且大多数基于 PTM 的 CL 方法使用在 ImageNet21K [Deng et al., 2009] 上预训练的 Vision Transformer (ViT) [Dosovitskiy et al., 2020] 作为嵌入函数。因此，本文也将重点关注 ViT 作为代表性的 PTM，因为它具有强大的表示能力。具体来说，在 ViT 中，输入图像首先被划分为不重叠的小块。然后将这些小块附加上类别标记 [CLS]，并输入到嵌入层，随后通过视觉 Transformer 块。我们表示嵌入的小块特征为 <span class="math-inline">x_e \in \mathbb{R}^{L \times d}</span>，其中 <span class="math-inline">L</span> 是序列的长度，<span class="math-inline">d</span> 是嵌入维度。在每个视觉 Transformer 块中，有两个主要模块，即多头自注意力层（MSA）和两层 MLP。小块特征通过 <span class="math-inline">N</span> 个级联的 Transformer 块前向传递，我们使用最终的 [CLS] 标记作为识别的特征。在接下来的讨论中，我们假设在 ImageNet 上预训练的 ViT 作为 <span class="math-inline">f(x)</span> 的初始化。我们将分类模型分解为两部分：<span class="math-inline">f(x) = W^T \phi(x)</span>，其中 <span class="math-inline">\phi(\cdot) : \mathbb{R}^D \rightarrow \mathbb{R}^d</span> 是嵌入函数（即，嵌入的 [CLS] 标记）和 <span class="math-inline">W \in \mathbb{R}^{d \times |\bigcup_{b=1}^{B} Y_b|}</span> 是分类头。</p>
<h3 id="23-预训练模型带来的持续学习新见解">2.3 预训练模型带来的持续学习新见解<a class="anchor-link" href="#23-预训练模型带来的持续学习新见解" title="Permanent link">&para;</a></h3>
<p>与从头开始训练嵌入函数相比，使用预训练模型带来了两个主要特点。首先，与随机初始化的模型相比，PTMs 具有“泛化能力”。从表示学习的角度来看，持续学习的最终目标是学习一个合适的嵌入来捕获所有见过的任务，而 PTMs 在开始时就提供了一个强大且通用的特征提取器。因此，可以在冻结的骨干网络上以非持续的方式设计算法 [Zhou et al., 2023b]。另一方面，ViTs 的结构使得在保持泛化能力的同时可以进行轻量级调整。像视觉提示调整 [Jia et al., 2022] 和适配器学习 [Chen et al., 2022] 这样的技术使得 PTMs 能够快速适应下游任务。因此，与从头开始训练相比，使用 PTMs 的持续学习在抵抗遗忘方面展现出更强的性能 [Cao et al., 2023]。</p>
<h2 id="3-使用预训练模型的持续学习">3. 使用预训练模型的持续学习<a class="anchor-link" href="#3-使用预训练模型的持续学习" title="Permanent link">&para;</a></h2>
<p>我们将当前基于 PTM 的 CL 研究分为三类，基于它们解决学习问题的不同思想，即提示法（prompt-based methods）、表示法（representation-based methods）和模型混合法（model mixture-based methods）。这些类别利用预训练模型的不同方面来促进持续学习。例如，鉴于 PTMs 的强大泛化能力，提示法方法通过提示调整（prompt tuning）来进行轻量级更新的 PTM。由于预训练权重保持不变，因此可以保留 PTMs 的泛化能力，从而减轻了遗忘。类似地，表示法方法直接利用 PTMs 的泛化能力来构建分类器。最后，模型混合法方法在学习能力过程中设计一组模型，并在推理过程中使用模型合并、模型集成和其他混合技术来得出最终预测。我们在图 2 中展示了基于 PTM 的 CL 的分类法，并列出了一些代表性的工作。在接下来的部分中，我们将介绍每个类别，并深入讨论它们的优缺点。</p>
<h3 id="31-提示法方法">3.1 提示法方法<a class="anchor-link" href="#31-提示法方法" title="Permanent link">&para;</a></h3>
<p>观察到 PTMs 的强大泛化能力，如何调整 PTM 导致了一个权衡——完全微调权重以捕获下游任务将抹去泛化特征，而固定主干则无法将下游信息编码到主干中。为此，视觉提示调整（Visual Prompt Tuning, VPT）[Jia et al., 2022] 揭示了一个有希望的方式，即使用轻量级可训练模块，例如提示，来调整 PTM。具体来说，它在小块特征 <span class="math-inline">x_e</span> 前置一组可学习参数 <span class="math-inline">P \in \mathbb{R}^{p \times d}</span>（即，提示）。因此，模型将 <span class="math-inline">[P, x_e]</span> 的连接作为视觉 Transformer 块的输入，并最小化交叉熵损失，以使用冻结的预训练权重将任务特定信息编码到这些提示中：<br />
<div class="math-display"><br />
    \min_{P, W} \sum_{(x,y) \in D_b} \ell \left( W^T \phi(x; P), y \right), \tag{2}<br />
</div><br />
其中 <span class="math-inline">\phi(x; P)</span> 表示通过前置提示得到的提示特征。优化公式 (2) 使模型能够将任务特定信息（即，对于 <span class="math-inline">D_b</span> 的关键特征）编码到提示中。因此，许多工作被设计为利用提示调整进行 CL。提示池：尽管公式 (2) 使得预训练模型的轻量级调整成为可能，但使用单一提示与新任务顺序优化将遭受灾难性遗忘，即，重写以前任务的提示权重导致前后任务之间的表示不兼容。因此，许多工作 [Wang et al., 2022c; Wang et al., 2022b; Smith et al., 2023] 提出了设计提示池的想法，它收集了一组提示 <span class="math-inline">P = {P_1, P_2, \ldots, P_M}</span>，其中 <span class="math-inline">M</span> 是池的大小。提示池可以被视为 CL 模型的外部记忆，能够在训练和推理期间进行实例特定的提示。因此，单个提示的遗忘可以被减轻，同时它需要一个适当的提示选择机制。<br />
提示选择：有了一组提示之后，我们需要决定为特定实例使用哪个（些）提示，即定义一个检索函数 <span class="math-inline">g(x)</span> 来选择实例特定的提示。提示检索成为基于提示方法的核心问题，许多工作设计了不同的变体。L2P [Wang et al., 2022c] 设计了一个键 - 查询匹配策略，为每个提示分配了一个可学习的键 <span class="math-inline">k \in \mathbb{R}^d</span>。在这种情况下，提示池被制定为 <span class="math-inline">P = {(k_1, P_1), (k_2, P_2), \ldots, (k_M, P_M)}</span>。为了检索与实例特定的提示，它使用无提示的 PTM（即 <span class="math-inline">\phi(\cdot)</span>）将特征编码到键的嵌入空间，并选择与键相似的提示：<br />
<div class="math-display"><br />
    K_x = \arg\min_{s_i \subseteq [1, M]} \sum_{i=1}^{N} \gamma (\phi(x), k_{s_i}), \tag{3}<br />
</div><br />
其中 <span class="math-inline">{s_i}<em>{i=1}^{N}</span> 是选定的索引集，<span class="math-inline">K_x</span> 是选定的前 N 个键。<span class="math-inline">\gamma(\cdot, \cdot)</span> 表示余弦距离。公式 (3) 选择了与查询实例最相似的键，并且在学习过程中优化相应的值（即，提示）：<br />
<div class="math-display"><br />
    \min</em>{K, P, W} \sum_{(x,y) \in D_b} \ell \left( W^T \phi(x; P_{K_x}), y \right) + \lambda \sum_{x \in D_b} \gamma (\phi(x), k_{K_x}). \tag{4}<br />
</div><br />
因此，优化公式 (4) 也强制键与编码特征相似。上述查询 - 键匹配过程是一个期望最大化（EM）过程 [Moon, 1996; Yadav et al., 2023]。具体来说，在 E 步骤中，基于它们与查询特征的相似性，选择前 N 个键。在 M 步骤中，然后使键更接近查询。受 L2P 启发，许多工作被提出来改进选择过程。DualPrompt [Wang et al., 2022b] 探讨了提示深度的重要性，通过在不同层附加提示。它还将提示解耦为通用和专家提示。其中，通用提示旨在编码任务通用信息，在所有任务中共享。相比之下，专家提示是任务特定的，其数量等于任务数。它在推理期间使用与公式 (3) 相同的检索策略。PP-TF [Yadav et al., 2023] 在代码生成模型中应用了类似的策略。S-Prompt [Wang et al., 2022a] 也考虑了任务特定提示策略，在学习新任务时通过进行 K-means 聚类扩展提示池，并使用 KNN 搜索找到最相似的任务以获取提示。MoP-CLIP [Nicolas et al., 2024] 通过在推理期间组合多个提示来扩展 S-Prompt。提示组合：虽然从提示池中选择提示听起来合理，但公式 (3) 中的匹配过程仍然是硬匹配，可以重现的选择有限。相应地，CODA-Prompt[Smith et al., 2023] 建议从提示池中构建基于注意力的提示。</p>
<p><div class="math-display"><br />
    P = \sum_{m=1}^{M} \gamma(\phi(x) \odot a_m, k_m) P_m, \tag{5}<br />
</div><br />
其中 <span class="math-inline">a_m \in \mathbb{R}^d</span> 是相应提示的可学习注意力向量，<span class="math-inline">\odot</span> 表示哈达玛德积。公式 (5) 通过元素乘法计算输入特征和提示键之间的注意力分数。因此，如果查询实例与某个键向量更相似，相应的提示值将在最终构建的提示中发挥更重要的作用。由于它将提示视为提示空间中的‘基’，因此它还设计了一个额外的正交性损失来增强提示多样性。</p>
<p>提示生成：虽然 CODA-Prompt 解决了基于注意力的提示组合问题，但组合过程仍受限于提示池。因此，许多工作进一步设计了元网络，可以生成特定于实例的提示。相应地，DAP [Jung et al., 2023] 通过将提示生成编码到 MLP 网络中来实现这一目标。它通过以下方式生成特定于实例的提示：<br />
<div class="math-display"><br />
    P = \sum \gamma_e \text{MLP} (\text{LN}(\phi(x)))^T + \beta_e^T, \tag{6}<br />
</div><br />
其中 LN 表示层归一化，<span class="math-inline">\gamma_e, \beta_e</span> 由任务预测的线性变换产生，作为提示生成中的权重和偏置。与公式 (6) 中的输入级提示生成不同，APG [Tang et al., 2023] 利用注意力机制在 ViT 的中间层进行提示生成。</p>
<p><strong>提示法方法的总结</strong>： 我们总结了图 3 中的提示选择方式，包括 L2P 中的键 - 值匹配、DualPrompt 中的任务特定和通用检索、CODA-Prompt 中的基于注意力的组合以及 DAP 中的提示生成。而不是选择提示，一些工作 [Liu et al., 2022; Razdaibiedina et al., 2023] 还考虑将所有提示附加到查询实例或学习视觉提示（即像素级参数）[Liu et al., 2023; Gan et al., 2023]。除了单一视觉模态，模型还可以利用文本信息 [Radford et al., 2021] 在预训练的视觉 - 语言模型 [Khan et al., 2023; Villa et al., 2023; Wang et al., 2023b; Khattak et al., 2023] 中进行学习和选择适当的提示。</p>
<p><strong>优点与缺点</strong>： 提示法方法通过轻量级提示在预训练知识与下游任务之间取得平衡，带来许多优点。首先，提示有助于弥合领域差距并有效编码任务特定知识。其次，由于这些轻量级模块与特征具有相同的维度，保存提示是参数高效的，这自然适合于一些边缘场景，如联邦学习 [Guo et al., 2024]。最后，学习提示池作为 PTM 的外部记忆，实现自适应知识检索和特定实例预测。然而，也有一些缺点。首先，一些工作 [Moon et al., 2023] 发现在公式 (3) 中的提示选择过程会收敛到一个点，使得提示选择只关注特定子集。此外，由于键和提示值在训练过程中不断变化，这些参数的更新将抹去以前任务的更新。这进一步导致匹配级别和提示级别的遗忘，使得提示选择过程成为持续学习中的瓶颈。此外，如果我们使用固定大小的提示池，其表示能力将受到限制。相比之下，如果提示池随着数据的演变而增长，将导致训练和测试之间的不匹配，因为新提示可能被检索用于旧任务。最后，尽管提示法方法为基于 PTM 的 CL 揭示了一个有希望的解决方案，但一些工作 [Zhou et al., 2023b] 发现它们的表现低于简单的原型基线（在第 3.2 节中讨论）。虽然一些基于提示的方法 [Jung et al., 2023] 显示出惊人的结果，但由于批量提示部分（在第 4 节中讨论），存在比较公平性方面的一些担忧。</p>
                </div>

                <!-- Comments Section (Giscus) -->
                <section class="comments-section">
                    <h3><i class="fas fa-comments"></i> 评论</h3>
                    <script src="https://giscus.app/client.js"
                        data-repo="Geeks-Z/Geeks-Z.github.io"
                        data-repo-id=""
                        data-category="Announcements"
                        data-category-id=""
                        data-mapping="pathname"
                        data-strict="0"
                        data-reactions-enabled="1"
                        data-emit-metadata="0"
                        data-input-position="bottom"
                        data-theme="preferred_color_scheme"
                        data-lang="zh-CN"
                        crossorigin="anonymous"
                        async>
                    </script>
                </section>
            </article>

            <footer class="post-footer">
                <p>© 2025 Hongwei Zhao. Built with ❤️</p>
            </footer>
        </main>
    </div>

    <!-- Theme Toggle Button -->
    <button class="theme-toggle" id="themeToggle" aria-label="切换主题">
        <i class="fas fa-moon"></i>
    </button>

    <script>
        // Theme Toggle
        const themeToggle = document.getElementById('themeToggle');
        const html = document.documentElement;
        const icon = themeToggle.querySelector('i');
        const hljsDark = document.getElementById('hljs-theme-dark');
        const hljsLight = document.getElementById('hljs-theme-light');
        
        // Check saved theme or system preference
        const savedTheme = localStorage.getItem('theme');
        const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
        
        if (savedTheme === 'dark' || (!savedTheme && prefersDark)) {
            html.setAttribute('data-theme', 'dark');
            icon.className = 'fas fa-sun';
            hljsDark.disabled = false;
            hljsLight.disabled = true;
        }
        
        themeToggle.addEventListener('click', () => {
            const isDark = html.getAttribute('data-theme') === 'dark';
            if (isDark) {
                html.removeAttribute('data-theme');
                icon.className = 'fas fa-moon';
                localStorage.setItem('theme', 'light');
                hljsDark.disabled = true;
                hljsLight.disabled = false;
            } else {
                html.setAttribute('data-theme', 'dark');
                icon.className = 'fas fa-sun';
                localStorage.setItem('theme', 'dark');
                hljsDark.disabled = false;
                hljsLight.disabled = true;
            }
            
            // Update Giscus theme
            const giscusFrame = document.querySelector('iframe.giscus-frame');
            if (giscusFrame) {
                giscusFrame.contentWindow.postMessage({
                    giscus: {
                        setConfig: {
                            theme: isDark ? 'light' : 'dark'
                        }
                    }
                }, 'https://giscus.app');
            }
        });
        
        // Highlight.js
        document.addEventListener('DOMContentLoaded', () => {
            hljs.highlightAll();
        });
        
        // KaTeX auto-render
        document.addEventListener('DOMContentLoaded', () => {
            if (typeof renderMathInElement !== 'undefined') {
                renderMathInElement(document.body, {
                    delimiters: [
                        {left: '$$', right: '$$', display: true},
                        {left: '$', right: '$', display: false},
                        {left: '\\[', right: '\\]', display: true},
                        {left: '\\(', right: '\\)', display: false}
                    ],
                    throwOnError: false
                });
            }
        });
        
        // TOC active state
        const tocLinks = document.querySelectorAll('.toc-container a');
        const headings = document.querySelectorAll('.post-content h2, .post-content h3, .post-content h4');
        
        function updateTocActive() {
            let current = '';
            headings.forEach(heading => {
                const rect = heading.getBoundingClientRect();
                if (rect.top <= 100) {
                    current = heading.getAttribute('id');
                }
            });
            
            tocLinks.forEach(link => {
                link.classList.remove('active');
                if (link.getAttribute('href') === '#' + current) {
                    link.classList.add('active');
                }
            });
        }
        
        window.addEventListener('scroll', updateTocActive);
        updateTocActive();
    </script>
</body>
</html>
