<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Untitled</title>
    <meta name="description" content="Untitled - Hongwei Zhao's Blog">
    <meta name="author" content="Hongwei Zhao">
    
    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Noto+Sans+SC:wght@300;400;500;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    
    <!-- Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <!-- Code Highlighting -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css" id="hljs-theme-dark">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css" id="hljs-theme-light" disabled>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    
    <!-- KaTeX for Math -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>
    
    <style>
        :root {
            /* Light Theme */
            --primary-color: #2980b9;
            --primary-hover: #1a5276;
            --link-color: #c0392b;
            --text-color: #333;
            --text-light: #666;
            --text-muted: #999;
            --bg-color: #fff;
            --bg-secondary: #f8f9fa;
            --bg-code: #f5f5f5;
            --border-color: #e5e7eb;
            --shadow: 0 1px 3px rgba(0,0,0,0.1);
            --shadow-lg: 0 4px 15px rgba(0,0,0,0.1);
        }

        [data-theme="dark"] {
            --primary-color: #5dade2;
            --primary-hover: #85c1e9;
            --link-color: #e74c3c;
            --text-color: #e5e7eb;
            --text-light: #9ca3af;
            --text-muted: #6b7280;
            --bg-color: #1a1a2e;
            --bg-secondary: #16213e;
            --bg-code: #0f0f23;
            --border-color: #374151;
            --shadow: 0 1px 3px rgba(0,0,0,0.3);
            --shadow-lg: 0 4px 15px rgba(0,0,0,0.4);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            scroll-behavior: smooth;
        }

        body {
            font-family: 'Inter', 'Noto Sans SC', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            font-size: 16px;
            line-height: 1.8;
            color: var(--text-color);
            background: var(--bg-color);
            transition: background-color 0.3s, color 0.3s;
        }

        a {
            color: var(--primary-color);
            text-decoration: none;
            transition: color 0.2s;
        }

        a:hover {
            color: var(--primary-hover);
            text-decoration: underline;
        }

        /* Layout */
        .page-wrapper {
            display: flex;
            max-width: 1400px;
            margin: 0 auto;
            padding: 2rem;
            gap: 3rem;
        }

        /* Sidebar TOC */
        .toc-sidebar {
            width: 260px;
            flex-shrink: 0;
            position: sticky;
            top: 2rem;
            height: fit-content;
            max-height: calc(100vh - 4rem);
            overflow-y: auto;
        }

        .toc-container {
            background: var(--bg-secondary);
            border-radius: 12px;
            padding: 1.5rem;
            border: 1px solid var(--border-color);
        }

        .toc-container h3 {
            font-size: 0.85rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-muted);
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .toc-container ul {
            list-style: none;
        }

        .toc-container li {
            margin-bottom: 0.5rem;
        }

        .toc-container a {
            font-size: 0.9rem;
            color: var(--text-light);
            display: block;
            padding: 0.25rem 0;
            border-left: 2px solid transparent;
            padding-left: 0.75rem;
            transition: all 0.2s;
        }

        .toc-container a:hover,
        .toc-container a.active {
            color: var(--primary-color);
            border-left-color: var(--primary-color);
            text-decoration: none;
        }

        .toc-container ul ul {
            margin-left: 1rem;
        }

        /* Main Content */
        .main-content {
            flex: 1;
            min-width: 0;
            max-width: 800px;
        }

        /* Header */
        .post-header {
            margin-bottom: 2rem;
            padding-bottom: 1.5rem;
            border-bottom: 1px solid var(--border-color);
        }

        .back-link {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.9rem;
            color: var(--text-light);
            margin-bottom: 1.5rem;
        }

        .back-link:hover {
            color: var(--primary-color);
            text-decoration: none;
        }

        .post-header h1 {
            font-size: 2.25rem;
            font-weight: 700;
            line-height: 1.3;
            margin-bottom: 1rem;
            color: var(--text-color);
        }

        .post-meta {
            display: flex;
            flex-wrap: wrap;
            gap: 1.5rem;
            font-size: 0.9rem;
            color: var(--text-light);
        }

        .post-meta span {
            display: flex;
            align-items: center;
            gap: 0.4rem;
        }

        .post-meta i {
            color: var(--text-muted);
        }

        .tags {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-top: 1rem;
        }

        .tag {
            display: inline-block;
            font-size: 0.8rem;
            background: var(--bg-secondary);
            color: var(--text-light);
            padding: 0.25rem 0.75rem;
            border-radius: 20px;
            border: 1px solid var(--border-color);
            transition: all 0.2s;
        }

        .tag:hover {
            background: var(--primary-color);
            color: white;
            border-color: var(--primary-color);
        }

        /* Article Content */
        .post-content {
            font-size: 1rem;
            line-height: 1.9;
        }

        .post-content h1,
        .post-content h2,
        .post-content h3,
        .post-content h4,
        .post-content h5,
        .post-content h6 {
            margin-top: 2rem;
            margin-bottom: 1rem;
            font-weight: 600;
            line-height: 1.4;
            color: var(--text-color);
        }

        .post-content h1 { font-size: 1.875rem; }
        .post-content h2 { 
            font-size: 1.5rem; 
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--border-color);
        }
        .post-content h3 { font-size: 1.25rem; }
        .post-content h4 { font-size: 1.125rem; }

        .post-content p {
            margin-bottom: 1.25rem;
        }

        .post-content ul,
        .post-content ol {
            margin: 1.25rem 0;
            padding-left: 1.5rem;
        }

        .post-content li {
            margin-bottom: 0.5rem;
        }

        .post-content blockquote {
            margin: 1.5rem 0;
            padding: 1rem 1.5rem;
            background: var(--bg-secondary);
            border-left: 4px solid var(--primary-color);
            border-radius: 0 8px 8px 0;
            color: var(--text-light);
            font-style: italic;
        }

        .post-content blockquote p:last-child {
            margin-bottom: 0;
        }

        /* Code */
        .post-content code {
            font-family: 'JetBrains Mono', 'Fira Code', Consolas, monospace;
            font-size: 0.9em;
            background: var(--bg-code);
            padding: 0.2em 0.4em;
            border-radius: 4px;
            color: var(--link-color);
        }

        .post-content pre {
            margin: 1.5rem 0;
            padding: 1.25rem;
            background: var(--bg-code);
            border-radius: 10px;
            overflow-x: auto;
            border: 1px solid var(--border-color);
        }

        .post-content pre code {
            background: none;
            padding: 0;
            color: inherit;
            font-size: 0.875rem;
            line-height: 1.6;
        }

        /* Images */
        .post-content img {
            max-width: 100%;
            height: auto;
            border-radius: 10px;
            margin: 1.5rem 0;
            box-shadow: var(--shadow-lg);
        }

        /* Tables */
        .post-content table {
            width: 100%;
            margin: 1.5rem 0;
            border-collapse: collapse;
            font-size: 0.95rem;
        }

        .post-content th,
        .post-content td {
            padding: 0.75rem 1rem;
            border: 1px solid var(--border-color);
            text-align: left;
        }

        .post-content th {
            background: var(--bg-secondary);
            font-weight: 600;
        }

        .post-content tr:nth-child(even) {
            background: var(--bg-secondary);
        }

        /* Math */
        .math-display {
            margin: 1.5rem 0;
            overflow-x: auto;
            padding: 1rem;
            background: var(--bg-secondary);
            border-radius: 8px;
        }

        /* Anchor links */
        .anchor-link {
            opacity: 0;
            margin-left: 0.5rem;
            color: var(--text-muted);
            font-weight: 400;
            transition: opacity 0.2s;
        }

        .post-content h2:hover .anchor-link,
        .post-content h3:hover .anchor-link,
        .post-content h4:hover .anchor-link {
            opacity: 1;
        }

        /* Theme Toggle */
        .theme-toggle {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: var(--primary-color);
            color: white;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.25rem;
            box-shadow: var(--shadow-lg);
            transition: transform 0.2s, background 0.2s;
            z-index: 1000;
        }

        .theme-toggle:hover {
            transform: scale(1.1);
            background: var(--primary-hover);
        }

        /* Comments Section */
        .comments-section {
            margin-top: 3rem;
            padding-top: 2rem;
            border-top: 1px solid var(--border-color);
        }

        .comments-section h3 {
            font-size: 1.25rem;
            margin-bottom: 1.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        /* Footer */
        .post-footer {
            margin-top: 3rem;
            padding-top: 1.5rem;
            border-top: 1px solid var(--border-color);
            text-align: center;
            font-size: 0.9rem;
            color: var(--text-muted);
        }

        /* Responsive */
        @media (max-width: 1024px) {
            .toc-sidebar {
                display: none;
            }
            
            .page-wrapper {
                padding: 1.5rem;
            }
        }

        @media (max-width: 768px) {
            .post-header h1 {
                font-size: 1.75rem;
            }
            
            .post-meta {
                flex-direction: column;
                gap: 0.5rem;
            }
            
            .theme-toggle {
                bottom: 1rem;
                right: 1rem;
                width: 44px;
                height: 44px;
            }
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-secondary);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--text-muted);
        }
    </style>
</head>
<body>
    <div class="page-wrapper">
        <!-- TOC Sidebar -->
        <aside class="toc-sidebar">
            <div class="toc-container">
                <h3><i class="fas fa-list"></i> 目录</h3>
                <div class="toc">
<ul>
<li><a href="#packnet-adding-multiple-tasks-to-a-single-network-by-iterative-pruning">PackNet: Adding Multiple Tasks to a Single Network by Iterative Pruning</a></li>
<li><a href="#kimi全文翻译-arrow_down">Kimi全文翻译 :arrow_down:</a></li>
<li><a href="#0-摘要">0. 摘要</a></li>
<li><a href="#1-引言">1. 引言</a></li>
<li><a href="#2-相关工作">2. 相关工作</a></li>
<li><a href="#3-方法">3. 方法</a></li>
<li><a href="#4-实验和结果">4. 实验和结果</a></li>
<li><a href="#5-详细分析">5. 详细分析</a><ul>
<li><a href="#51-训练顺序的影响">5.1. 训练顺序的影响</a></li>
<li><a href="#52-剪枝比例的影响">5.2. 剪枝比例的影响</a></li>
<li><a href="#53-训练单独偏差的影响">5.3. 训练单独偏差的影响</a></li>
<li><a href="#54-训练所有层是否必要">5.4. 训练所有层是否必要？</a></li>
<li><a href="#55-与基于滤波器的剪枝比较">5.5. 与基于滤波器的剪枝比较</a></li>
</ul>
</li>
<li><a href="#6-结论">6. 结论</a></li>
</ul>
</div>

            </div>
        </aside>

        <!-- Main Content -->
        <main class="main-content">
            <article>
                <header class="post-header">
                    <a href="../../../../index.html" class="back-link">
                        <i class="fas fa-arrow-left"></i> 返回博客列表
                    </a>
                    <h1>Untitled</h1>
                    <div class="post-meta">
                        <span><i class="fas fa-calendar-alt"></i> 2026-01-28</span>
                        <span><i class="fas fa-folder"></i> AINotes/40.CIL/21.Neuron Expansion</span>
                        <span><i class="fas fa-user"></i> Hongwei Zhao</span>
                    </div>
                    <div class="tags">
                        
                    </div>
                </header>

                <div class="post-content">
                    <h2 id="packnet-adding-multiple-tasks-to-a-single-network-by-iterative-pruning">PackNet: Adding Multiple Tasks to a Single Network by Iterative Pruning<a class="anchor-link" href="#packnet-adding-multiple-tasks-to-a-single-network-by-iterative-pruning" title="Permanent link">&para;</a></h2>
<h2 id="kimi全文翻译-arrow_down">Kimi全文翻译 :arrow_down:<a class="anchor-link" href="#kimi全文翻译-arrow_down" title="Permanent link">&para;</a></h2>
<h2 id="0-摘要">0. 摘要<a class="anchor-link" href="#0-摘要" title="Permanent link">&para;</a></h2>
<p>本文提出了一种将多个任务添加到单个深度神经网络的方法，同时避免了灾难性遗忘。受网络剪枝技术的启发，我们利用大型深度网络中的冗余来释放可以用于学习新任务的参数。通过执行迭代剪枝和网络重新训练，我们能够顺序地将多个任务“打包”到单个网络中，同时确保性能的最小下降和最小的存储开销。与使用代理损失来维持旧任务准确性的先前工作不同，我们始终优化手头的任务。我们在各种网络架构和大规模数据集上进行了广泛的实验，并观察到比以前的工作更好地抵御了灾难性遗忘。特别是，我们能够在单个 ImageNet 训练的 VGG-16 网络上添加三个细粒度分类任务，并实现了接近于单独训练网络的准确性。代码可在 https://github.com/arunmallya/packnet 上找到。</p>
<h2 id="1-引言">1. 引言<a class="anchor-link" href="#1-引言" title="Permanent link">&para;</a></h2>
<p>终身学习或持续学习 [1, 14, 22] 是通用人工智能代理的一个关键要求。在这种设置下，代理需要在保持之前学习任务的性能的同时，获得新任务的专业知识，理想情况下无需为每个单独任务存储大型专用模型。在深度神经网络的情况下，学习新任务的最常见方式是对网络进行微调。然而，随着与新任务相关的特征通过修改网络权重来学习，对于先前任务重要的权重可能会被改变，导致性能下降，这种现象被称为“灾难性遗忘”[4]。由于存储空间不足、数据权限或代理部署性质的限制，无法访问旧的训练数据，这些都是非常现实的限制，简单的微调并不是持续学习的可行选项。目前克服灾难性遗忘的方法，如无遗忘学习（LwF）[18] 和弹性权重巩固（EWC）[14]，已经尝试通过使用代理损失来保留对先前任务重要的知识。前者试图在训练新数据时保留初始网络的激活，而后者惩罚对先前任务重要的参数的修改。与此类先前工作不同，我们从网络压缩方法中汲取灵感，这些方法已经显示出通过消除冗余参数来减少网络大小和计算足迹的令人印象深刻的结果 [8, 17, 19, 20]。我们提出了一种使用基于权重的剪枝技术 [7, 8] 在任务训练后释放深度网络所有层中的冗余参数的方法，精度损失最小。保持存活参数不变，释放的参数被修改以学习新任务。这个过程可以重复进行，以添加多个任务，如图 1 所示。通过使用剪枝生成的任务特定参数掩码，我们的模型能够在添加多个任务后保持相同的准确性水平，并且每个新任务的存储开销非常低。</p>
<h2 id="2-相关工作">2. 相关工作<a class="anchor-link" href="#2-相关工作" title="Permanent link">&para;</a></h2>
<p>一些先前的工作及其变体，例如无遗忘学习（LwF）[18, 22, 27] 和弹性权重巩固（EWC）[14, 16]，旨在按顺序对网络进行多任务训练。在添加新任务时，LwF 通过使用蒸馏损失 [10] 来保留网络对旧任务的响应，其中响应目标是使用当前任务的数据计算的。结果，LwF 不需要存储旧的训练数据，然而，这种策略如果新任务的数据属于与先前任务不同的分布，可能会导致问题。随着向网络添加更多不相似的任务，先前任务的性能迅速下降 [18]。EWC 试图通过使用二次约束来最小化对先前任务重要的权重的变化，以确保它们不会偏离初始值太远。与 LwF 和 EWC 类似，我们不需要存储旧数据。像 EWC 一样，我们希望避免改变对先前任务重要的权重。然而，我们不使用软约束，而是采用网络剪枝技术来识别最重要的参数，稍后解释。与这些先前的工作不同，即使使用我们的方法添加一个非常不相关的新任务，也不会改变旧任务的性能。随着神经网络变得更深更大，一些工作出现了，旨在通过减少存储网络权重所需的数值精度 [5, 6, 12, 23] 或剪枝不重要的网络权重 [7, 8, 17, 19, 20] 来减少训练模型的大小和推理所需的计算量。我们的关键思想是使用网络剪枝方法来释放网络中的参数，然后使用这些参数来学习新任务。我们采用了 [7, 8] 中引入的简单的基于权重大小的剪枝方法，因为它能够剪枝掉初始网络的 50% 以上的参数。正如我们将在第 5.5 节讨论的，我们还尝试了 [20] 中的基于滤波器的剪枝，由于无法积极剪枝，取得了有限的成功。我们的工作与 Han 等人 [7] 提出的最新方法有关，该方法表明，稀疏化和重新训练网络权重是一种正则化形式，可以提高同一任务的性能。与此相反，我们使用迭代剪枝和重新训练来添加多个不同的任务。</p>
<h2 id="3-方法">3. 方法<a class="anchor-link" href="#3-方法" title="Permanent link">&para;</a></h2>
<p>我们方法的基本思想是使用网络剪枝技术创建可以用于学习新任务的空闲参数，而不增加额外的网络容量。训练。图 1 给出了我们方法的概述。我们从一个用于初始任务的标准网络开始，例如在 ImageNet[25] 分类上训练的 VGG-16[28]，称为任务 I。滤波器的初始权重在图 1(a) 中以灰色显示。然后，我们剪枝掉网络的一定比例的权重，即将其设置为零。剪枝网络会导致性能损失，由于网络连接性的突然变化，这种损失尤为明显，尤其是当剪枝比例较高时。为了在剪枝后恢复精度，我们需要重新训练网络，训练的轮数少于训练所需的轮数。在一轮剪枝和重新训练后，我们获得了具有稀疏滤波器和在任务 I 上性能最小下降的网络。任务 I 的存活参数，如图 1(b) 中的灰色参数，此后保持固定。接下来，我们对新任务，任务 II，进行网络训练，并让剪枝的权重从零恢复，获得如图 1(c) 所示的橙色权重。请注意，任务 II 的滤波器同时使用了灰色和橙色权重，即可用权重属于先前的任务。我们再次剪枝网络，释放仅用于任务 II 的一些参数，并重新训练任务 II 以从剪枝中恢复。这给出了图 1(d) 中用于评估任务 II 的滤波器（请注意，任务 I 的权重，灰色，不考虑剪枝）。此后，任务 I 和 II 的权重保持固定。然后，可用的剪枝参数被用于学习另一个新任务，导致图 1(e) 中显示的绿色权重。这个过程一直重复，直到添加了所有所需任务或没有更多空闲参数为止。在我们的实验中，剪枝和重新训练大约比简单的微调长 1.5 倍，因为我们通常重新训练一半的训练周期。</p>
<p>剪枝过程。在每一轮剪枝中，我们从每个卷积层和全连接层中移除固定百分比的合格权重。层中的权重按其绝对大小排序，最低的 50% 或 75% 被选为移除，类似于 [7]。我们使用一次性剪枝方法以简化，尽管增量剪枝已被证明可以取得更好的性能 [8]。如前所述，我们只剪枝属于当前任务的权重，并且不修改属于先前任务的权重。例如，在图 1 中从滤波器 (c) 到 (d) 的过程中，我们只剪枝属于任务 II 的橙色权重，而任务 I 的灰色权重保持固定。这确保了在添加新任务时先前任务的性能没有变化。我们没有发现学习任务特定的偏差与 EWC[14] 相似是必要的，并且在网络剪枝和重新训练后保持所有层的偏差固定。同样，在网络使用批量归一化的情况下，我们不在第一轮剪枝和重新训练后更新参数（增益、偏差）或运行平均值（均值、方差）。这种选择有助于减少每项任务的额外开销，并且我们的下一部分结果和进一步分析在第 5 节中证明了这一点。添加多个任务的唯一开销是存储一个稀疏掩码，指示哪些参数对特定任务处于活动状态。通过遵循迭代训练过程，对于特定的任务 K，我们获得了一个滤波器，它是为该特定任务和所有先前任务 1, ..., K-1 学习到的权重的叠加。如果一个参数最初由任务 K 使用，它将被所有任务 K, ..., N 使用，其中 N 是任务的总数。因此，我们最多需要 log2(N) 位来编码每个参数的掩码，而不是每个任务的每个参数 1 位。向初始 ImageNet 训练的 VGG-16 网络（conv1 1 到 fc 7）添加一个和三个任务的开销仅为∼17 MB 和∼34 MB。因此，具有四个任务的网络总共增加了 1/16，与初始大小相比，因为一个典型的参数使用 4 字节，或 32 位表示。1</p>
<p>推理。在对选定任务进行推理时，网络参数被掩码，以使网络状态与训练期间学习的状态相匹配，即图 1(b) 用于任务 I 的推理，图 1(d) 用于任务 II 的推理，依此类推。没有额外的运行时开销，因为不需要额外的计算；权重只需要在乘法期间以二进制开/关的方式进行掩码，这可以很容易地在矩阵 - 矩阵乘法内核中实现。重要的是要注意，我们的基于剪枝的方法无法同时对所有任务进行推理，因为滤波器的响应会根据其稀疏性水平而变化，并且在通过 ReLU 等非线性后不再可分离。执行滤波器级别的剪枝，即整个滤波器被打开/关闭，而不是单个参数，可以允许同时推理。然而，我们在第 5.5 节中展示了这种方法目前有限的剪枝能力，无法在不显著降低性能的情况下适应多个任务。</p>
<h2 id="4-实验和结果">4. 实验和结果<a class="anchor-link" href="#4-实验和结果" title="Permanent link">&para;</a></h2>
<p>数据集和训练设置。我们在两个大规模图像数据集和三个细粒度分类数据集上评估我们的方法，如表 1 所总结。</p>
<table>
<thead>
<tr>
<th>数据集</th>
<th>训练集数量</th>
<th>评估集数量</th>
<th>类别数量</th>
</tr>
</thead>
<tbody>
<tr>
<td>ImageNet [25]</td>
<td>1,281,144</td>
<td>50,000</td>
<td>1,000</td>
</tr>
<tr>
<td>Places365 [30]</td>
<td>1,803,460</td>
<td>36,500</td>
<td>365</td>
</tr>
<tr>
<td>CUBS Birds [29]</td>
<td>5,994</td>
<td>5,794</td>
<td>200</td>
</tr>
<tr>
<td>Stanford Cars [15]</td>
<td>8,144</td>
<td>8,041</td>
<td>196</td>
</tr>
<tr>
<td>Flowers [21]</td>
<td>2,040</td>
<td>6,149</td>
<td>102</td>
</tr>
</tbody>
</table>
<p>表 1：使用的数据集摘要。</p>
<p>在 Stanford Cars 和 CUBS 数据集的情况下，我们从输入图像中裁剪出对象边界框，并将它们调整到 224×224 大小。对于其他数据集，我们将输入图像调整为 256×256 大小，并取随机裁剪的大小为 224×224 作为输入。对于所有数据集，我们进行左右翻转以增强数据。在所有实验中，我们从一个 ImageNet 训练的网络开始，因为拥有一个好的参数起始集是至关重要的。我们对网络的唯一更改是为每个新任务添加一个新的输出层。在剪枝初始 ImageNet 训练的网络后，我们在 ImageNet 数据集上对其进行 10 个周期的微调，学习率在前 5 个周期后衰减 10 倍。对于添加细粒度数据集，我们使用相同的初始学习率，在 10 个周期后衰减，并总共训练 20 个周期。对于更大的 Places365 数据集，我们总共微调 10 个周期，在 5 个周期后学习率衰减。当网络在新任务训练后被剪枝时，我们进一步在 1e-4 的恒定学习率下对网络进行 10 个周期的微调。我们使用 32 的批量大小和所有网络上的默认 dropout 率。基线。最简单的基线方法，称为 Classifier Only，是从初始网络中提取 fc7 或预分类器特征，并仅针对每个特定任务训练一个新的分类器，这意味着在 ImageNet 上的性能保持不变。对于每个新分类器层的训练，我们使用 1e-3 的恒定学习率进行 20 个周期。第二个基线，称为 Individual Networks，为每个任务训练单独的模型，通过为单个任务分配网络的所有资源来实现最高可能的准确性。为了获得各个细粒度任务的模型，我们从 ImageNet 训练的网络开始，并在相应任务上进行总共 20 个周期的微调，学习率在 10 个周期后衰减 10 倍。另一个在先前工作中使用的基线是多任务的联合训练。然而，当数据集大小不同时（例如 ImageNet 和 CUBS），联合微调相当棘手，因此我们没有尝试在细粒度数据集的实验中使用它，因为在任何情况下，单独训练的网络都提供了更高的参考准确性。联合训练对于大小相似的数据集效果更好，因此，在结合 ImageNet 和 Places 时，我们与 [30] 的作者提供的联合训练网络进行了比较。我们的最终基线是我们自己的 LwF[18] 的重新实现。我们使用 [18] 中的相同默认设置，包括在新任务的训练数据的损失和蒸馏损失之间的单位权衡参数。对于使用 LwF 添加细粒度数据集，我们使用在 10 个周期后衰减的初始学习率 1e-3，并总共训练 20 个周期。在前 5 个周期中，我们仅训练新的分类器层，如 [18] 中所建议。</p>
<p>多个细粒度分类任务。表 2 总结了我们将 CUBS、Cars 和 Flowers 的三个细粒度任务以不同顺序添加到 VGG-16 网络的实验。通过比较 Classifier Only 和 Individual Networks 列，我们可以清楚地看到，细粒度任务通过允许较低的卷积层改变而受益匪浅，汽车和鸟类分类的 top-1 错误率分别从 56.42% 下降到 13.97%，从 36.76% 下降到 22.57%。这三个任务可以以六种不同的顺序添加到初始网络中。表 2 的 Pruning 列报告了我们方法在这六种顺序中获得的 top-1 错误的平均值，每个顺序进行了三次独立运行。我们将在下一部分详细探讨顺序的影响。通过对 ImageNet 训练的 VGG-16 网络进行 50% 和 75% 的剪枝和重新训练，top-1 错误率从最初的 28.42% 略微增加到 29.33% 和 30.87%，top-5 错误率从 9.61% 略微增加到 9.99% 和 10.93%。当三个任务被添加到 75% 剪枝的初始网络时，我们实现了 CUBS、Stanford Cars 和 Flowers 的错误率，仅比 Individual Networks 最佳情况差 2.38%、1.78% 和 1.10%。与此同时，与 Classifier Only 基线相比，错误率分别降低了 11.04%、30.41% 和 10.41%。不足为奇的是，从更高的剪枝比例开始的网络在细粒度任务上表现更好，因为它为它们提供了更多的参数。这特别有助于具有挑战性的汽车分类，将 top-1 错误率从 18.08% 降低到 15.75%，初始剪枝比例从 50% 增加到 75%。我们的方法还在所有数据集上一致性地击败了 LwF。如图 2 所示，尽管在 LwF 的情况下，训练新任务时旧任务的错误率持续增加，但我们的方法保持不变。LwF 对旧任务准确性的不可预测变化是有问题的，特别是当我们想要保证特定性能水平时。最后，如表 2 最后一行所示，我们的基于剪枝的模型比单独训练每个任务的网络小得多（595 MB 对 2,173 MB），并且仅比分类器基线大 33 MB。</p>
<p>添加另一个大规模数据集任务。表 3 显示了将大规模 Places365 分类任务添加到剪枝的 ImageNet 网络的结果。通过将比 ImageNet 更大的 Places365（1.8 M 图像对 1.3 M 图像）添加到 75% 剪枝的 ImageNet 训练网络，我们实现了与单独训练网络的 top-1 错误率仅相差 0.64% 和 top-5 错误率仅相差 0.10%。相比之下，联合训练基线在 ImageNet 上的性能比单独网络差得多（33.49% 对 28.42% top-1 错误率）。这突出了联合训练的一个常见问题，即需要平衡多个数据集之间的混合比例，这些数据集可能或可能不互补，并适应它们可能不同的超参数要求。相比之下，迭代剪枝允许控制先前任务性能的下降，并允许每个任务使用不同的训练超参数设置。此外，我们只在 Places365 上训练了 10 个周期的剪枝网络，而联合和单独的网络则训练了 60-90 个周期 [30]。</p>
<p>扩展到其他网络。到目前为止，我们展示的结果都是针对香草 VGG-16 网络的，这是一个简单且庞大的网络，众所周知充满了冗余 [2]。像 ResNets[9] 和 DenseNets[11] 这样的新架构更加紧凑、更深且性能更好。不清楚剪枝在后两个参数高效的网络上的表现如何。此外，人们可能会怀疑在不同任务之间共享批量归一化参数是否会限制准确性。表 4 显示，我们的方法确实可以应用于所有这些架构，包括残差连接、跳跃连接和批量归一化。如第 3 节所述，批量归一化参数（增益、偏差、运行均值和方差）在网络剪枝和重新训练 ImageNet 后被冻结。尽管有这种限制，我们仍然实现了比仅训练最后分类器层的基线低得多的错误率。在几乎所有情况下，我们获得了与每个任务的一个网络的最佳情况相差 1-2% 的错误率。尽管我们尝试了每个任务学习单独的批量归一化参数，并且这进一步提高了性能，但我们选择冻结批量归一化参数，因为它更简单，避免了存储这些单独参数的开销（每个批量归一化层 4 个向量）。更深的 ResNet 和 DenseNet 网络分别有 50 层和 121 层，对剪枝非常健壮，分别只损失了 0.45% 和 0.04% 的 ImageNet top-1 准确性。ResNet 的 top-5 错误率增加了 0.05%，而 DenseNet 的 top-5 错误率减少了 0.13%。在 Flowers 分类的情况下，我们的表现比单独的网络更好，可能是因为训练整个网络导致它对 Flowers 数据集过拟合，这是最小的。通过使用剪枝后可用的较少参数，我们可能避免了这个问题。除了在各种网络上获得良好的性能外，我们的基于剪枝的方法的额外好处是，对于给定的任务，网络可以逐步以小量剪枝，以便实现当前任务准确性损失和为后续任务提供空闲参数之间的理想权衡。请注意，参数越少，我们方法的掩码存储开销就越低，如表 4 中的 Size 行所示。</p>
<h2 id="5-详细分析">5. 详细分析<a class="anchor-link" href="#5-详细分析" title="Permanent link">&para;</a></h2>
<p>在本节中，我们研究了使用我们方法时影响性能的因素，并为我们所做的选择（例如冻结网络的偏差）提供了理由。我们还比较了我们的基于权重的剪枝方法与基于滤波器的剪枝方法，并确认了前者的优势。</p>
<h3 id="51-训练顺序的影响">5.1. 训练顺序的影响<a class="anchor-link" href="#51-训练顺序的影响" title="Permanent link">&para;</a></h3>
<p>当更多的任务被添加到网络时，更大的网络部分对于随后添加的任务变得不可用。考虑 VGG-16 网络的 0.50, 0.75, 0.75 剪枝比例序列。从 conv1 1 到 fc 7 的层包含大约 134 M 参数。在任务 I（ImageNet 分类）的初始 50% 剪枝后，我们有大约 67 M 空闲参数。在第二轮训练后，进行 75% 剪枝和重新训练，任务 II 使用了 16.75 M 参数，为后续任务留下了 50.25 M 空闲参数。同样，任务 III 使用了大约 13 M 参数，为任务 IV 留下了大约 37 M 空闲参数。因此，我们观察到随着训练顺序的增加，准确性降低，如图 3 所示。例如，随着我们将 Stanford Cars 数据集的添加延迟到网络，其 top-1 错误率从 16.00% 增加到 18.34% 和 19.91%。对于所考虑的数据集，当添加顺序从第一变为第三时，错误平均增加了 3%。请注意，表 2 中报告的结果是对特定数据集的所有顺序进行了平均的。这些发现表明，如果能够事先决定任务的顺序，那么最具有挑战性或最不相关的任务应该首先添加。</p>
<h3 id="52-剪枝比例的影响">5.2. 剪枝比例的影响<a class="anchor-link" href="#52-剪枝比例的影响" title="Permanent link">&para;</a></h3>
<p>在图 4 中，我们测量了当任务首次添加到 50% 剪枝的 VGG-16 网络时（除了初始的 ImageNet 任务外），剪枝和重新训练对任务的影响。我们考虑这种特定情况是为了将剪枝的影响与上述训练顺序的影响隔离开来。我们观察到，由于网络连接性的突然变化，任务的错误率在剪枝后立即增加（⋆标记）。然而，在重新训练后，错误率降低，甚至可能低于原始未剪枝的错误率，如图 4 中除 ImageNet 外的所有数据集在 50% 剪枝比例下所示，与先前的工作 [7] 一致，该工作表明剪枝和重新训练可以作为有效的正则化。多步骤剪枝肯定会帮助减少 ImageNet 上的错误，如 [8] 中报告的。这个图表显示，重新训练至关重要，特别是当剪枝比例较大时。有趣的是，对于新添加的任务，50% 和 75% 的剪枝在不重新训练的情况下并没有显著增加错误。更令人惊讶的是，即使是非常激进的一次性剪枝比例 90%，随后进行重新训练，与未剪枝的错误相比，错误增加也很小（top-1 错误从 15.75% 增加到 17.84%，对于 Stanford Cars，从 24.13% 增加到 24.72%，对于 CUBS，从 8.96% 增加到 9.48%）。这表明有效的迁移学习，因为非常少的参数修改（在剪枝后可用的 50% 的总参数的 10%，或 VGG-16 总参数的 5%）就足以获得良好的准确性。</p>
<h3 id="53-训练单独偏差的影响">5.3. 训练单独偏差的影响<a class="anchor-link" href="#53-训练单独偏差的影响" title="Permanent link">&para;</a></h3>
<p>我们没有观察到通过学习每层的任务特定偏差来改善性能的任何显著改进，如表 5 所示。共享偏差减少了我们提出的方法的存储开销，因为每个卷积、全连接或批量归一化层都可以包含相关的偏差项。因此，我们选择不在报告的结果中学习任务特定的偏差。</p>
<h3 id="54-训练所有层是否必要">5.4. 训练所有层是否必要？<a class="anchor-link" href="#54-训练所有层是否必要" title="Permanent link">&para;</a></h3>
<p>图 5 测量了为学习新任务而修改各种层中释放的参数的影响。在这个实验中，我们从 50% 剪枝的 ImageNet 训练的纯 VGG-16 网络开始，并添加一个新任务。对于新任务，我们仅训练指定层中剪枝的神经元。微调全连接层提高了所有任务的准确性，超过了仅分类器的基线。此外，微调卷积层提供了最大的准确性提升，并且显然需要获得良好的性能。通过我们的方法，我们可以控制每层的剪枝参数数量，允许根据可用的任务特定要求进行利用。</p>
<h3 id="55-与基于滤波器的剪枝比较">5.5. 与基于滤波器的剪枝比较<a class="anchor-link" href="#55-与基于滤波器的剪枝比较" title="Permanent link">&para;</a></h3>
<p>为了完整性，我们报告了基于滤波器的剪枝 [20] 的实验，这种剪枝消除了整个滤波器，而不是稀疏化它们。这种策略的最大优势是它允许同时为所有训练任务执行推理。对于在一轮剪枝中存活的滤波器，所有没有存活的滤波器（因此可用于后续任务）的传入权重被设置为 0。因此，当为新任务学习新滤波器时，它们的输出不会被先前任务的滤波器使用。因此，先前任务的滤波器的输出将始终保持不变，无论为后续任务学习了哪些滤波器。[20] 的方法基于与损失函数的泰勒展开相关的度量，对网络中的所有滤波器进行排名。我们在每个大约 40,000 次迭代的周期中剪枝 400 个滤波器，总共 10 个周期。总的来说，这从 VGG-16 的总共 12,416 个滤波器中消除了 4,000 个，即∼30% 的剪枝。如果没有大幅降低 ImageNet 的准确性，我们无法更积极地剪枝。一个更不利的观察是，大多数剪枝的滤波器（4,000 中的 3,730 个）是从全连接层中选择的（Liu 等人 [19] 提出了一种不同的基于滤波器的剪枝方法，并为 VGG-16 发现了类似的结果）。这在网络的较低层中释放了太少的参数，无法有效地微调新任务。因此，基于滤波器的剪枝只允许我们将一个额外的任务添加到 ImageNet 训练的 VGG-16 网络中，如表 6 所示。基于滤波器的剪枝方法的最终缺点是，它们更复杂，并且在残差网络和跳跃连接的情况下需要仔细实现，如 Li 等人 [17] 所指出的。</p>
<h2 id="6-结论">6. 结论<a class="anchor-link" href="#6-结论" title="Permanent link">&para;</a></h2>
<p>在这项工作中，我们提出了一种将多个任务“打包”到单个网络的方法，对先前任务的性能损失最小。提出的方法允许我们修改网络的所有层，并影响大量的滤波器和特征，这对于获得与每个任务单独训练的网络相当的准确性是必要的。它不仅适用于相对“宽松”的 VGG-16 架构，也适用于更紧凑的参数高效的网络，如 ResNets 和 DenseNets。在未来，我们有兴趣探索一个更通用的框架，用于在单个网络中联合训练网络权重和与各个任务相关的二进制稀疏掩码。在当前方法中，每个任务的稀疏掩码是剪枝的结果，但可能可以使用类似于学习具有二进制权重的网络的技术来学习这样的掩码。</p>
<p>致谢：我们要感谢 Maxim Raginsky，他的讨论激发了本文的最初想法，并感谢 Greg Shakhnarovich 建议了 PackNet 这个名字。这项材料部分基于国家科学基金会资助的工作，编号为 1563727 和 1718221。</p>
                </div>

                <!-- Comments Section (Giscus) -->
                <section class="comments-section">
                    <h3><i class="fas fa-comments"></i> 评论</h3>
                    <script src="https://giscus.app/client.js"
                        data-repo="Geeks-Z/Geeks-Z.github.io"
                        data-repo-id=""
                        data-category="Announcements"
                        data-category-id=""
                        data-mapping="pathname"
                        data-strict="0"
                        data-reactions-enabled="1"
                        data-emit-metadata="0"
                        data-input-position="bottom"
                        data-theme="preferred_color_scheme"
                        data-lang="zh-CN"
                        crossorigin="anonymous"
                        async>
                    </script>
                </section>
            </article>

            <footer class="post-footer">
                <p>© 2025 Hongwei Zhao. Built with ❤️</p>
            </footer>
        </main>
    </div>

    <!-- Theme Toggle Button -->
    <button class="theme-toggle" id="themeToggle" aria-label="切换主题">
        <i class="fas fa-moon"></i>
    </button>

    <script>
        // Theme Toggle
        const themeToggle = document.getElementById('themeToggle');
        const html = document.documentElement;
        const icon = themeToggle.querySelector('i');
        const hljsDark = document.getElementById('hljs-theme-dark');
        const hljsLight = document.getElementById('hljs-theme-light');
        
        // Check saved theme or system preference
        const savedTheme = localStorage.getItem('theme');
        const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
        
        if (savedTheme === 'dark' || (!savedTheme && prefersDark)) {
            html.setAttribute('data-theme', 'dark');
            icon.className = 'fas fa-sun';
            hljsDark.disabled = false;
            hljsLight.disabled = true;
        }
        
        themeToggle.addEventListener('click', () => {
            const isDark = html.getAttribute('data-theme') === 'dark';
            if (isDark) {
                html.removeAttribute('data-theme');
                icon.className = 'fas fa-moon';
                localStorage.setItem('theme', 'light');
                hljsDark.disabled = true;
                hljsLight.disabled = false;
            } else {
                html.setAttribute('data-theme', 'dark');
                icon.className = 'fas fa-sun';
                localStorage.setItem('theme', 'dark');
                hljsDark.disabled = false;
                hljsLight.disabled = true;
            }
            
            // Update Giscus theme
            const giscusFrame = document.querySelector('iframe.giscus-frame');
            if (giscusFrame) {
                giscusFrame.contentWindow.postMessage({
                    giscus: {
                        setConfig: {
                            theme: isDark ? 'light' : 'dark'
                        }
                    }
                }, 'https://giscus.app');
            }
        });
        
        // Highlight.js
        document.addEventListener('DOMContentLoaded', () => {
            hljs.highlightAll();
        });
        
        // KaTeX auto-render
        document.addEventListener('DOMContentLoaded', () => {
            if (typeof renderMathInElement !== 'undefined') {
                renderMathInElement(document.body, {
                    delimiters: [
                        {left: '$$', right: '$$', display: true},
                        {left: '$', right: '$', display: false},
                        {left: '\\[', right: '\\]', display: true},
                        {left: '\\(', right: '\\)', display: false}
                    ],
                    throwOnError: false
                });
            }
        });
        
        // TOC active state
        const tocLinks = document.querySelectorAll('.toc-container a');
        const headings = document.querySelectorAll('.post-content h2, .post-content h3, .post-content h4');
        
        function updateTocActive() {
            let current = '';
            headings.forEach(heading => {
                const rect = heading.getBoundingClientRect();
                if (rect.top <= 100) {
                    current = heading.getAttribute('id');
                }
            });
            
            tocLinks.forEach(link => {
                link.classList.remove('active');
                if (link.getAttribute('href') === '#' + current) {
                    link.classList.add('active');
                }
            });
        }
        
        window.addEventListener('scroll', updateTocActive);
        updateTocActive();
    </script>
</body>
</html>
