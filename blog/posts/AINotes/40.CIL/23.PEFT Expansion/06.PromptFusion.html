<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Untitled</title>
    <meta name="description" content="Untitled - Hongwei Zhao's Blog">
    <meta name="author" content="Hongwei Zhao">
    
    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Noto+Sans+SC:wght@300;400;500;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    
    <!-- Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <!-- Code Highlighting -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css" id="hljs-theme-dark">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css" id="hljs-theme-light" disabled>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    
    <!-- KaTeX for Math -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>
    
    <style>
        :root {
            /* Light Theme */
            --primary-color: #2980b9;
            --primary-hover: #1a5276;
            --link-color: #c0392b;
            --text-color: #333;
            --text-light: #666;
            --text-muted: #999;
            --bg-color: #fff;
            --bg-secondary: #f8f9fa;
            --bg-code: #f5f5f5;
            --border-color: #e5e7eb;
            --shadow: 0 1px 3px rgba(0,0,0,0.1);
            --shadow-lg: 0 4px 15px rgba(0,0,0,0.1);
        }

        [data-theme="dark"] {
            --primary-color: #5dade2;
            --primary-hover: #85c1e9;
            --link-color: #e74c3c;
            --text-color: #e5e7eb;
            --text-light: #9ca3af;
            --text-muted: #6b7280;
            --bg-color: #1a1a2e;
            --bg-secondary: #16213e;
            --bg-code: #0f0f23;
            --border-color: #374151;
            --shadow: 0 1px 3px rgba(0,0,0,0.3);
            --shadow-lg: 0 4px 15px rgba(0,0,0,0.4);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            scroll-behavior: smooth;
        }

        body {
            font-family: 'Inter', 'Noto Sans SC', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            font-size: 16px;
            line-height: 1.8;
            color: var(--text-color);
            background: var(--bg-color);
            transition: background-color 0.3s, color 0.3s;
        }

        a {
            color: var(--primary-color);
            text-decoration: none;
            transition: color 0.2s;
        }

        a:hover {
            color: var(--primary-hover);
            text-decoration: underline;
        }

        /* Layout */
        .page-wrapper {
            display: flex;
            max-width: 1400px;
            margin: 0 auto;
            padding: 2rem;
            gap: 3rem;
        }

        /* Sidebar TOC */
        .toc-sidebar {
            width: 260px;
            flex-shrink: 0;
            position: sticky;
            top: 2rem;
            height: fit-content;
            max-height: calc(100vh - 4rem);
            overflow-y: auto;
        }

        .toc-container {
            background: var(--bg-secondary);
            border-radius: 12px;
            padding: 1.5rem;
            border: 1px solid var(--border-color);
        }

        .toc-container h3 {
            font-size: 0.85rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-muted);
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .toc-container ul {
            list-style: none;
        }

        .toc-container li {
            margin-bottom: 0.5rem;
        }

        .toc-container a {
            font-size: 0.9rem;
            color: var(--text-light);
            display: block;
            padding: 0.25rem 0;
            border-left: 2px solid transparent;
            padding-left: 0.75rem;
            transition: all 0.2s;
        }

        .toc-container a:hover,
        .toc-container a.active {
            color: var(--primary-color);
            border-left-color: var(--primary-color);
            text-decoration: none;
        }

        .toc-container ul ul {
            margin-left: 1rem;
        }

        /* Main Content */
        .main-content {
            flex: 1;
            min-width: 0;
            max-width: 800px;
        }

        /* Header */
        .post-header {
            margin-bottom: 2rem;
            padding-bottom: 1.5rem;
            border-bottom: 1px solid var(--border-color);
        }

        .back-link {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.9rem;
            color: var(--text-light);
            margin-bottom: 1.5rem;
        }

        .back-link:hover {
            color: var(--primary-color);
            text-decoration: none;
        }

        .post-header h1 {
            font-size: 2.25rem;
            font-weight: 700;
            line-height: 1.3;
            margin-bottom: 1rem;
            color: var(--text-color);
        }

        .post-meta {
            display: flex;
            flex-wrap: wrap;
            gap: 1.5rem;
            font-size: 0.9rem;
            color: var(--text-light);
        }

        .post-meta span {
            display: flex;
            align-items: center;
            gap: 0.4rem;
        }

        .post-meta i {
            color: var(--text-muted);
        }

        .tags {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-top: 1rem;
        }

        .tag {
            display: inline-block;
            font-size: 0.8rem;
            background: var(--bg-secondary);
            color: var(--text-light);
            padding: 0.25rem 0.75rem;
            border-radius: 20px;
            border: 1px solid var(--border-color);
            transition: all 0.2s;
        }

        .tag:hover {
            background: var(--primary-color);
            color: white;
            border-color: var(--primary-color);
        }

        /* Article Content */
        .post-content {
            font-size: 1rem;
            line-height: 1.9;
        }

        .post-content h1,
        .post-content h2,
        .post-content h3,
        .post-content h4,
        .post-content h5,
        .post-content h6 {
            margin-top: 2rem;
            margin-bottom: 1rem;
            font-weight: 600;
            line-height: 1.4;
            color: var(--text-color);
        }

        .post-content h1 { font-size: 1.875rem; }
        .post-content h2 { 
            font-size: 1.5rem; 
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--border-color);
        }
        .post-content h3 { font-size: 1.25rem; }
        .post-content h4 { font-size: 1.125rem; }

        .post-content p {
            margin-bottom: 1.25rem;
        }

        .post-content ul,
        .post-content ol {
            margin: 1.25rem 0;
            padding-left: 1.5rem;
        }

        .post-content li {
            margin-bottom: 0.5rem;
        }

        .post-content blockquote {
            margin: 1.5rem 0;
            padding: 1rem 1.5rem;
            background: var(--bg-secondary);
            border-left: 4px solid var(--primary-color);
            border-radius: 0 8px 8px 0;
            color: var(--text-light);
            font-style: italic;
        }

        .post-content blockquote p:last-child {
            margin-bottom: 0;
        }

        /* Code */
        .post-content code {
            font-family: 'JetBrains Mono', 'Fira Code', Consolas, monospace;
            font-size: 0.9em;
            background: var(--bg-code);
            padding: 0.2em 0.4em;
            border-radius: 4px;
            color: var(--link-color);
        }

        .post-content pre {
            margin: 1.5rem 0;
            padding: 1.25rem;
            background: var(--bg-code);
            border-radius: 10px;
            overflow-x: auto;
            border: 1px solid var(--border-color);
        }

        .post-content pre code {
            background: none;
            padding: 0;
            color: inherit;
            font-size: 0.875rem;
            line-height: 1.6;
        }

        /* Images */
        .post-content img {
            max-width: 100%;
            height: auto;
            border-radius: 10px;
            margin: 1.5rem 0;
            box-shadow: var(--shadow-lg);
        }

        /* Tables */
        .post-content table {
            width: 100%;
            margin: 1.5rem 0;
            border-collapse: collapse;
            font-size: 0.95rem;
        }

        .post-content th,
        .post-content td {
            padding: 0.75rem 1rem;
            border: 1px solid var(--border-color);
            text-align: left;
        }

        .post-content th {
            background: var(--bg-secondary);
            font-weight: 600;
        }

        .post-content tr:nth-child(even) {
            background: var(--bg-secondary);
        }

        /* Math */
        .math-display {
            margin: 1.5rem 0;
            overflow-x: auto;
            padding: 1rem;
            background: var(--bg-secondary);
            border-radius: 8px;
        }

        /* Anchor links */
        .anchor-link {
            opacity: 0;
            margin-left: 0.5rem;
            color: var(--text-muted);
            font-weight: 400;
            transition: opacity 0.2s;
        }

        .post-content h2:hover .anchor-link,
        .post-content h3:hover .anchor-link,
        .post-content h4:hover .anchor-link {
            opacity: 1;
        }

        /* Theme Toggle */
        .theme-toggle {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: var(--primary-color);
            color: white;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.25rem;
            box-shadow: var(--shadow-lg);
            transition: transform 0.2s, background 0.2s;
            z-index: 1000;
        }

        .theme-toggle:hover {
            transform: scale(1.1);
            background: var(--primary-hover);
        }

        /* Comments Section */
        .comments-section {
            margin-top: 3rem;
            padding-top: 2rem;
            border-top: 1px solid var(--border-color);
        }

        .comments-section h3 {
            font-size: 1.25rem;
            margin-bottom: 1.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        /* Footer */
        .post-footer {
            margin-top: 3rem;
            padding-top: 1.5rem;
            border-top: 1px solid var(--border-color);
            text-align: center;
            font-size: 0.9rem;
            color: var(--text-muted);
        }

        /* Responsive */
        @media (max-width: 1024px) {
            .toc-sidebar {
                display: none;
            }
            
            .page-wrapper {
                padding: 1.5rem;
            }
        }

        @media (max-width: 768px) {
            .post-header h1 {
                font-size: 1.75rem;
            }
            
            .post-meta {
                flex-direction: column;
                gap: 0.5rem;
            }
            
            .theme-toggle {
                bottom: 1rem;
                right: 1rem;
                width: 44px;
                height: 44px;
            }
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-secondary);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--text-muted);
        }
    </style>
</head>
<body>
    <div class="page-wrapper">
        <!-- TOC Sidebar -->
        <aside class="toc-sidebar">
            <div class="toc-container">
                <h3><i class="fas fa-list"></i> 目录</h3>
                <div class="toc">
<ul>
<li><a href="#promptfusion-decoupling-stability-and-plasticity-for-continual-learning">PromptFusion: Decoupling Stability and Plasticity for Continual Learning</a></li>
<li><a href="#0-摘要">0. 摘要</a></li>
<li><a href="#1-引言">1. 引言</a></li>
<li><a href="#2-相关工作">2. 相关工作</a><ul>
<li><a href="#21-连续学习">2.1. 连续学习</a></li>
<li><a href="#22-提示学习">2.2. 提示学习</a></li>
</ul>
</li>
<li><a href="#3-预备知识">3. 预备知识</a><ul>
<li><a href="#31-coop">3.1 CoOp</a></li>
<li><a href="#32-vpt">3.2 VPT</a></li>
<li><a href="#33-提示调整用于连续学习">3.3 提示调整用于连续学习</a></li>
</ul>
</li>
<li><a href="#4-先导研究">4. 先导研究</a><ul>
<li><a href="#41-解耦稳定性和可塑性">4.1 解耦稳定性和可塑性</a></li>
<li><a href="#42-提示或主干">4.2 提示或主干？</a></li>
</ul>
</li>
<li><a href="#5-promptfusion">5. PromptFusion</a></li>
<li><a href="#7-结论">7. 结论</a></li>
</ul>
</div>

            </div>
        </aside>

        <!-- Main Content -->
        <main class="main-content">
            <article>
                <header class="post-header">
                    <a href="../../../../index.html" class="back-link">
                        <i class="fas fa-arrow-left"></i> 返回博客列表
                    </a>
                    <h1>Untitled</h1>
                    <div class="post-meta">
                        <span><i class="fas fa-calendar-alt"></i> 2026-01-28</span>
                        <span><i class="fas fa-folder"></i> AINotes/40.CIL/23.PEFT Expansion</span>
                        <span><i class="fas fa-user"></i> Hongwei Zhao</span>
                    </div>
                    <div class="tags">
                        
                    </div>
                </header>

                <div class="post-content">
                    <h2 id="promptfusion-decoupling-stability-and-plasticity-for-continual-learning"><a href="http://arxiv.org/abs/2303.07223">PromptFusion: Decoupling Stability and Plasticity for Continual Learning</a><a class="anchor-link" href="#promptfusion-decoupling-stability-and-plasticity-for-continual-learning" title="Permanent link">&para;</a></h2>
<h2 id="0-摘要">0. 摘要<a class="anchor-link" href="#0-摘要" title="Permanent link">&para;</a></h2>
<p>连续学习指的是从数据流中持续学习的能力。当前研究主要集中在缓解灾难性遗忘上，而大部分的成功都是以限制新任务的性能为代价的。这种权衡被称为稳定性 - 可塑性困境，对连续学习来说是一个更普遍和更具挑战性的问题。然而，这两个概念之间固有的冲突使得似乎不可能同时对它们两个都找到一个令人满意的解决方案。因此，我们提出一个问题：“是否可能将它们分成两个问题来独立征服？”为此，我们提出了一种基于提示调整的方法，称为 PromptFusion，以实现稳定性和可塑性的解耦。具体来说，PromptFusion 由一个精心设计的稳定器（Stabilizer）模块组成，负责处理灾难性遗忘，以及一个助推器（Booster）模块，同时学习新知识。在训练期间，PromptFusion 先将输入图像分别传递给两个模块。然后，得到的对数几率（logits）进一步通过一个可学习的权重参数融合。最后，对派生出的对数几率应用权重掩码以平衡旧类和新类。广泛的实验表明，我们的方法在流行的连续学习数据集上，无论是类增量还是域增量设置，都取得了有希望的结果。特别是在 Split-Imagenet-R 上，这是类增量学习中最富挑战性的数据集之一，我们的方法超过了最先进的基于提示的方法 L2P 和 DualPrompt 超过 10%。</p>
<h2 id="1-引言">1. 引言<a class="anchor-link" href="#1-引言" title="Permanent link">&para;</a></h2>
<p>尽管深度神经网络取得了巨大进步，它们通常以一种静态的监督方式进行训练，即所有训练数据一次性可用 [19, 13, 34]。相反，连续学习 [7, 12, 26] 研究了神经网络在更加现实的场景下的行为，即数据以连续和动态的方式到达。理想情况下，当面对新数据时，最先进的模型应该既稳定以防止以前任务的性能下降，又具有可塑性以学习新任务的足够信息 [43]。然而，在实践中很难甚至不可能保持这样的平衡，这种现象被称为稳定性 - 可塑性困境 [1, 29]。因此，大多数当前文献主要关注问题的一方面，即缓解灾难性遗忘的问题，但忽视了另一方面的未看到牺牲。一个典型的例子是基于正则化的方法，如 EWC[18]。在 EWC 中，为以前任务的重要参数保持不变，这不可避免地限制了学习新知识的能力。由于直接平衡这种权衡极其具有挑战性，我们反而从不同的视角来解决这个问题。具体来说，受到补充学习系统 [28, 20] 的启发，这是一种生物学理论，表明智能代理必须拥有两个学习系统，我们假设通过利用两个不同的架构独立解决稳定性和可塑性，可以以类似的方式解决困境。然而，额外架构的引入引起了计算上的担忧，因为它可能会严重复杂化优化过程。所以现在的问题变成了，是否有计算效率高的方式来实现这个想法？最近，提示调整 [24, 21, 42] 已成为以计算效率高的方式对下游任务进行微调模型的新兴趋势。由于提示调整只训练一组额外的小参数，并冻结预训练的主干，它为上述问题提供了一个潜在的解决方案。实际上，由于其强大的转移能力，提示调整已经在连续学习中被探索 [41, 40, 39]。第一个这样做的工作是训练一个提示池，然后为每个任务优化一个提示选择过程，并取得了显著的表现。因此，引入了各种后续方法。然而，如图 1 所示，它们的可塑性受到严重限制。</p>
<h2 id="2-相关工作">2. 相关工作<a class="anchor-link" href="#2-相关工作" title="Permanent link">&para;</a></h2>
<h3 id="21-连续学习">2.1. 连续学习<a class="anchor-link" href="#21-连续学习" title="Permanent link">&para;</a></h3>
<p>在连续学习中，原则是顺序地在多个任务上训练一个模型，而不会忘记以前学习的任务的知识，在训练新任务时，旧任务的数据不可用。文献中连续学习有三个基本设置，即任务增量 [7, 18, 33]、类增量 [9, 45] 和域增量 [10, 37] 设置。对于任务增量学习，输入样本的任务身份在测试时提供，因此被认为是最宽松的条件。相反，类增量和域增量学习在推理期间将所有样本视为相同，而不考虑任务身份的先验知识。这两者的区别在于，在类增量学习中，每个任务的数据通常来自相同的分布但属于不同的类别，而在域增量学习中，每个任务的数据属于不同的分布但具有相同的类别标签。多年来，许多努力致力于解决连续学习问题，这些方法主要可以分为三组：基于复习的方法 [4, 33, 25, 36, 14]，其中使用记忆存储过去的示例；基于架构的方法 [9, 45, 15, 35, 38, 30, 27]，其中网络为新任务扩展；基于正则化的方法 [18, 23, 2, 46, 8]，其中以前任务的重要参数保持不变。然而，这些方法大多数主要关注灾难性遗忘的问题，而没有考虑新任务的学习性能。相反，在本文中，我们关注的是一个更普遍的连续学习问题，旨在解决稳定性 - 可塑性困境。</p>
<h3 id="22-提示学习">2.2. 提示学习<a class="anchor-link" href="#22-提示学习" title="Permanent link">&para;</a></h3>
<p>最近，NLP 领域的研究人员表明，通过在输入文本前添加指令，可以处理广泛的下游任务，即使只有很少甚至没有样本 [22, 24, 21]。这些指令文本被称为提示。因此，可以调整提示而不是整个网络的权重，以更高效地适应下游任务。提示学习在 NLP 中的成功也引起了视觉社区的注意，激励了许多相关方法的建立 [17, 11, 6, 16, 47]。例如，DAPL[11] 在无监督领域适应中应用提示学习，通过为每个源 - 目标域对训练一个提示。MPA[6] 通过两阶段对齐过程扩展了它，以适应多源场景。在连续学习的背景下，一系列基于提示的工作取得了巨大的成功。在 L2P[41] 和 DualPrompt[40] 中，训练了一个提示池，以便每个任务从中采样一组特定于任务的提示，使用键 - 值选择过程。然而，它们不能端到端地训练，因为键是局部优化的。此外，它们假设每个小批量数据都使用相同的一组提示，这在推理期间是有问题的，因为同一小批量中可能存在来自不同任务的数据。类似地，S-Prompt[39] 以类似的方式在 CoOp 的基础上提出，但它专门设计用于域增量学习。</p>
<h2 id="3-预备知识">3. 预备知识<a class="anchor-link" href="#3-预备知识" title="Permanent link">&para;</a></h2>
<p>由于我们使用 CoOp 和 VPT 这两种类型的提示学习方法来实例化 PromptFusion，我们首先简要回顾这两种方法，然后详细介绍它们如何在稳定器和助推器模块中被利用。</p>
<h3 id="31-coop">3.1 CoOp<a class="anchor-link" href="#31-coop" title="Permanent link">&para;</a></h3>
<p>CoOp[47] 是建立在 CLIP[32] 之上的大规模视觉 - 语言表示学习模型。它由图像编码器 <span class="math-inline">f</span> 和文本编码器 <span class="math-inline">g</span> 组成，将输入图像与文本提示对齐。与 CLIP 中提示通常以“a photo of a [CLS]”的形式不同，CoOp 中的提示是可训练的标记参数 <span class="math-inline">V_i</span>，长度为 <span class="math-inline">M</span>，形式为“[V1]...[VM][CLS]”。给定一个带有标签 <span class="math-inline">y</span> 的图像 <span class="math-inline">x</span> 和类别 <span class="math-inline">k</span> 的文本提示 <span class="math-inline">P_k</span>，CoOp 首先将它们映射到相同的嵌入空间。然后，它们以对比的方式对齐，使得<br />
<div class="math-display"><br />
    p(y = k | x) = \frac{\exp(&lt; g(P_k), f(x) &gt; / T)}{\sum_{i=1}^{K} \exp(&lt; g(P_i), f(x) &gt; / T)}<br />
</div><br />
在输入图像 <span class="math-inline">x</span> 属于类别 <span class="math-inline">k</span> 时最大化。这里，<span class="math-inline">K</span> 是类别总数，<span class="math-inline">T</span> 是温度参数，<span class="math-inline">&lt; \cdot, \cdot &gt;</span> 表示余弦相似度。在推理期间，测试图像 <span class="math-inline">x</span> 的预测标签是：<br />
<div class="math-display"><br />
    \arg \max_k &lt; g(P_k), f(x) &gt;, k \in {1, ..., K}.<br />
</div></p>
<h3 id="32-vpt">3.2 VPT<a class="anchor-link" href="#32-vpt" title="Permanent link">&para;</a></h3>
<p>与 CoOp 不同，CoOp 寻求两种模态之间的对齐，VPT 只依赖于视觉变换器（ViT），以纯视觉的方式利用提示学习 [16]。在 VPT 中，输入图像首先被划分为 <span class="math-inline">m</span> 个固定大小的补丁 <span class="math-inline">I_i</span>。与类别标记一起，输入首先被嵌入到具有位置嵌入的潜在空间中。然后，可学习的提示标记 <span class="math-inline">U_i</span> 长度为 <span class="math-inline">p</span> 被附加到输入的形式为“[CLS][U1]...[Up][I1]...[Im]”。在浅层 VPT 中，提示只插入到第一个变换器层的输入中，而对于深层 VPT，提示插入到每个变换器层。在这项工作中，采用了浅层 VPT。</p>
<h3 id="33-提示调整用于连续学习">3.3 提示调整用于连续学习<a class="anchor-link" href="#33-提示调整用于连续学习" title="Permanent link">&para;</a></h3>
<p>在当前研究中，我们关注类增量和域增量设置。形式上，给定 <span class="math-inline">N</span> 个任务 <span class="math-inline">T = (T_1, T_2, ..., T_N)</span>，其中任务 <span class="math-inline">T_t</span> 的数据表示为 <span class="math-inline">D(X_t, Y_t)</span>，在类增量场景中，<span class="math-inline">Y_i \cap Y_j = \emptyset</span>，且 <span class="math-inline">P(X_i) = P(X_j)</span>，而在域增量场景中，<span class="math-inline">Y_i = Y_j</span>，且 <span class="math-inline">P(X_i) \neq P(X_j)</span>，<span class="math-inline">i, j \in {1, ..., N}</span>，且 <span class="math-inline">i \neq j</span>。这里 <span class="math-inline">P(\cdot)</span> 表示概率密度函数。由于我们的方法使用了复演记忆，因此在每个训练阶段，模型可以访问当前任务的数据和一些存储的过去示例，目标是在不忘记过去知识（稳定性）的同时，持续更新模型以获得当前任务的好结果（可塑性）。我们观察到 CoOp 和 VPT 之间的一个区别是，CoOp 中的提示是类别依赖的，而 VPT 没有这样的限制。因此，对于新进入的类别，VPT 被允许重用相同的一组提示，而 CoOp 则必须学习新的提示。因此，对于每个任务 <span class="math-inline">T_t</span>，为 CoOp 初始化了一组新的文本提示 <span class="math-inline">P_{\text{stab}<em>t} \in \mathbb{R}^{K_N \times M \times \text{estab}}</span>，其中 <span class="math-inline">K_N</span> 是每个任务中的类别数，<span class="math-inline">\text{estab}</span> 是嵌入维度。如果 <span class="math-inline">t &gt; 1</span>，<span class="math-inline">P</em>{\text{stab}<em>t}</span> 与之前学习的提示 <span class="math-inline">P</em>{\text{stab}} = \text{Concat}[P_{\text{stab}1}, ..., P_{\text{stab}t}]</span> 连接，以便与图像特征在嵌入空间中对齐。注意，<span class="math-inline">P_{\text{stab}1}, ..., P_{\text{stab}t-1}</span> 保持冻结。至于 VPT，另一组提示 <span class="math-inline">P_{\text{boost}} \in \mathbb{R}^{p \times e_{\text{boost}}}</span> 在第一个任务 <span class="math-inline">T_1</span> 的训练之前初始化，并持续更新每个任务 <span class="math-inline">T_t</span>。虽然我们可以使用 VPT 为每个任务训练一个提示，并将其与之前学习的提示连接起来，但实验表明这种方法会导致性能不佳。因此，我们坚持上述设计。</p>
<h2 id="4-先导研究">4. 先导研究<a class="anchor-link" href="#4-先导研究" title="Permanent link">&para;</a></h2>
<p>在本节中，我们进行先导研究，探索是否可以通过利用提出的稳定器和助推器模块来解耦稳定性和可塑性。为此，我们系统地分析了 CoOp 和 VPT 在连续学习设置下的性能。</p>
<h3 id="41-解耦稳定性和可塑性">4.1 解耦稳定性和可塑性<a class="anchor-link" href="#41-解耦稳定性和可塑性" title="Permanent link">&para;</a></h3>
<p>我们首先通过证明我们设计的 CoOp 适合稳定性，而 VPT 适合可塑性来开始分析。在图 2 中，展示了任务 T2、T4 和 T5 在 Split-Cifar100 数据集上的三个准确率曲线。很明显，CoOp 受到的遗忘影响要小得多，平均性能下降了 9.9%。相比之下，VPT 的平均下降达到了 23.0%，表明 VPT 的稳定性有限。此外，图 3 中绘制了任务 T1 的特征分布变化，使用了高斯核密度估计（KDE）。KDE 是一种流行的非参数方法，用于基于核作为权重估计概率密度函数。如图中所示，与 VPT 相比，CoOp 的分布变化要小得多，这与图 2 中的结果一致。图 4 另一方面描述了每个新学习任务的性能。虽然 VPT 的准确率一致地达到了大约 95%，但 CoOp 表现出明显的恶化模式。它们的性能差距在 T10 时达到了 24.8%，并且随着更多任务的跟进，可能会更糟。尽管这两个图的证据支持我们的假设，但仍然需要最后一个部分来完成整个画面。那就是，CoOp 和 VPT 之间的另一个主要区别是它们的主干网络。</p>
<h3 id="42-提示或主干">4.2 提示或主干？<a class="anchor-link" href="#42-提示或主干" title="Permanent link">&para;</a></h3>
<p>为了测试图 2 和图 4 中的模式是否真的来自不同设计的提示，我们进行了一个额外的实验，其中我们将 CoOp 的图像编码器的预训练权重应用于 VPT。图 5 中的结果显示，它们的性能大致相同，并且都表现出对可塑性的偏好而不是稳定性，因为最后一个任务 T10 的性能很高。此外，图 5 中另一个有趣的发现是，使用 CoOp 的主干实际上导致了更差的性能。这相当令人惊讶，因为 CoOp 的主干，CLIP[32]，通常被认为比 Imagenet 预训练的 ViT 更强大。实际上，[40] 报告了当用更强的主干替换最先进的连续学习方法时，性能下降的趋势，这表明更强的网络并不一定导致更好的连续学习能力，因为主干是完全监督的方式训练的。同时，我们在不同类型的数据集上测试两个模块时发现，CoOp 在复杂的数据集上更先进，尤其是当存在大的类内变化时。另一方面，VPT 处理更简单的数据集更好。为了证明这一发现，图 6 中提供了 Split-Cifar100、Split-Imagenet-R 和 Core50 的 t-SNE 可视化。这里，Split-Cifar100 是一个相对简单的数据集，而 Split-Imagenet-R 和 Core50 包含了数据分布中的协变量偏移。如图 6 所示，CoOp 在 Imagenet-R 和 Core-50 上的特征比 VPT 更聚集，表明它对类内变化更鲁棒。或者，在 Cifar100 上，VPT 的特征更聚集。因此，通过融合两个模块，另一个潜在的好处是得到的模型可以适应不同数据集的变化特性。</p>
<h2 id="5-promptfusion">5. PromptFusion<a class="anchor-link" href="#5-promptfusion" title="Permanent link">&para;</a></h2>
<p>根据先导研究的结果，我们证实稳定性和可塑性可以使用提出的稳定器模块和助推器模块来解耦。基于这一观察，我们提出了我们的方法。PromptFusion 的伪代码和概述分别在算法 1 和图 7 中给出。形式上，将稳定器模型表示为 <span class="math-inline">S</span>，助推器模型表示为 <span class="math-inline">B</span>。给定一个输入图像 <span class="math-inline">x_i</span>，带有标签 <span class="math-inline">y_i</span>，<span class="math-inline">x_i</span> 首先传递给两个模块 <span class="math-inline">S</span> 和 <span class="math-inline">B</span>。它们各自的输出 <span class="math-inline">S(x_i)</span> 和 <span class="math-inline">B(x_i)</span> 然后通过可训练参数 <span class="math-inline">\lambda</span> 通过加权平均融合。结果进一步逐元素乘以权重掩码 <span class="math-inline">W</span> 以平衡旧类和新类。具体来说，我们希望旧类被纠正，新类被削弱。因此，我们将 <span class="math-inline">W</span> 的学习分成两个矩阵，<span class="math-inline">\alpha</span> 和 <span class="math-inline">\beta</span>，使得：<br />
<div class="math-display"><br />
    W = \text{Concat}\left[ \frac{1}{\sigma(\beta)}, \sigma(\alpha) \right],<br />
</div><br />
其中 <span class="math-inline">\sigma(\cdot) = \frac{1}{1+e^{-x}}</span> 是 sigmoid 函数。将它们结合起来，最终输出 <span class="math-inline">z_i</span> 得出为：<br />
<div class="math-display"><br />
    z_i = W \odot \left[ (1 - \sigma(\lambda)) \cdot S(x_i) + \sigma(\lambda) \cdot B(x_i) \right],<br />
</div><br />
其中 <span class="math-inline">\odot</span> 表示逐元素乘法操作。此外，受到 [3] 的启发，该文指出 CLIP 可以通过图像提示增强，我们以类似的方式增强 CoOp，通过插入提示 <span class="math-inline">\tilde{P}<em>{\text{stab}}</span> 到图像补丁中。我们经验性地将 <span class="math-inline">\tilde{P}</em>{\text{stab}}</span> 的大小设置为与 <span class="math-inline">P_{\text{boost}}</span> 相同。最后，整个训练阶段的学习目标是一个简单的交叉熵损失：<br />
<div class="math-display"><br />
    \min_{\Theta} \sum_{i=1}^{N} \text{CrossEntropy}(z_i, y_i),<br />
</div><br />
$\Theta := {\alpha, \beta, \lambda, P_{\text{stab}}, \tilde{P}<em>{\text{stab}}, P</em>{\text{boost}}}.<br />
<div class="math-display"><br />
    ## 6. 实验 ### 6.1. 实验设置 <strong>数据集</strong> 实验在三个流行的连续学习基准数据集上进行，即 CIFAR100、Imagenet-R 和 Core50，其中 CIFAR100 和 Imagenet-R 在类增量设置下评估，Core50 在域增量设置下评估。Cifar100 是一个相对简单的数据集，包含 100 个类别，被分成 10 个任务，每个任务 10 个类别。Imagenet-R 由 200 个类别组成，包括不同风格的数据，如卡通、涂鸦和折纸，也被分成 10 个任务。它被认为是类增量学习中最难的数据集之一，因为语义和协变量偏移都发生了。另一方面，Core50 是域增量学习的一个流行数据集，包含来自 11 个域的 50 个对象。特别是，其中 8 个用于训练，其余 3 个用于测试。在训练期间没有看到 Core50 的 3 个域中的任何图像。对于所有三个数据集，我们使用与 [41, 40] 相同的类别顺序，以便进行公平比较。 <strong>评估指标</strong> 按照传统设置，我们报告在所有任务训练后的平均准确率，以评估模型的连续学习能力。形式上，设<span class="math-inline">RT,i</span> 在任务<span class="math-inline">TT</span> 训练后任务<span class="math-inline">Ti</span> 分类准确率，则平均准确率<span class="math-inline">AT</span> 义为<br />
</div><br />
AT = \frac{1}{T} \sum_{i=1}^{T} RT,i. $$ <strong>实现细节</strong> 我们对 CoOp 和 VPT 的图像编码器都采用 ViT-B-16 主干，并在整个训练阶段保持冻结。对于提示大小，CoOp 中的<span class="math-inline">M</span> 置为 4，而 VPT 中的<span class="math-inline">p</span> 置为 30。所有提示都使用 0.01 的学习率的 mini-batch AdamW 优化器一起训练，并为所有数据集配备余弦退火调度器。考虑到它们的不同难度，Cifar100 每个任务训练 3 个周期，而 Imagenet-R 和 Core50 每个任务训练 5 个周期。所有这些都配备了 2,000 大小的记忆缓冲区。 ### 6.2. 与最先进方法的比较 我们与经典和最新的最先进连续学习方法进行比较：EWC[18]、LwF[23]、BiC[44]、GDumb[31]、DER++[45]、Co2L[5]、L2P[41]、SPrompt[39] 和 DualPrompt[40]。特别是，DER++ 是非提示基础方法中表现最好的，而 L2P、S-Prompt 和 DualPrompt 都是基于提示的方法。由于 S-Prompt 专门设计用于域增量学习，我们只报告其在 Core50 数据集上的性能。Split-Cifar100、Split-Imagenet-R 和 Core50 的结果在表 1 中显示，PromptFusion 明显优于所有其他备选方案。对于 Split-Cifar100，我们的方法以不到 2% 的总训练数据的缓冲区大小达到了 87.4% 的平均准确率。性能比 L2P 和 DualPrompt 分别高出 4.1% 和 1.7%。考虑到 Cifar100 相对简单，我们认为改进相当显著。对于 Split-Imagenet-R，我们的方法超过了所有其他方法超过 10%。特别是，与最好的基于提示的方法 DualPrompt 相比，我们的方法比它高出 12.2%。这种性能提升的一个主要原因是，纳入 CoOp 使我们的方法对类内变化具有鲁棒性，如第 4 节所讨论的。在这里，Split-Cifar100 和 Split-Imagenet-R 都是类增量学习场景中常用的数据集，结果表明 PromptFusion 在这种特定设置中表现令人满意。我们还在流行的 Core50 数据集上测试了域增量学习场景下的 PromptFusion。值得注意的是，L2P 和 DualPrompt 的性能都不如 S-Prompt，因为它们的关注点主要是类增量学习。然而，PromptFusion 仍然比 S-Prompt 高出 5.9%，表明 PromptFusion 的能力不仅限于任何特定类型的连续学习设置。考虑到 S-Prompt 也是基于 CoOp 的，这是强有力的证据，表明我们方法的成功不仅仅是来自这个特定模块。虽然可能有人对我们方法的计算复杂性提出担忧，但我们表明它实际上与其他基于提示的方法相似。这是因为对于 L2P 和 DualPrompt，使用了额外的原始预训练 ViT 来提取其 [CLS] 特征作为从提示池中选择提示的查询。S-Prompt 另一方面，需要对所有训练数据执行 K-NN，因此随着数据集的增大，计算成本很高。 ### 6.3. 记忆大小的影响 | 记忆大小 | 1K | 2K | 3K | 4K | 5K | | --- | --- | --- | --- | --- | --- | | Core50 | 95.0 | 85.5 | 79.1 | 95.0 | 87.4 | | Cifar100 | 80.7 | 95.1 | 87.4 | 81.6 | 95.1 | | Imagenet-R | 88.0 | 82.1 | 95.1 | 88.4 | 82.2 | 由于记忆缓冲区是我们方法的一个主要组成部分，我们希望测试 PromptFusion 在不同缓冲区大小时的表现。我们选择分析所有三个测试数据集的 1K、2K、3K、4K 和 5K 大小，并在图 8 中报告结果。总的来说，缓冲区大小对整体性能的影响相当小，与最先进的基于复习的方法 [45, 9] 相比。具体来说，对于 Split-Cifar100，当记忆大小从 5K 变为 1K 时，性能下降了 2.9%。注意，当大小从 2K 变为 1K 时突然下降，而从 2K 增加到 5K 时变化很小。这种趋势也在 Split-Imagenet-R 数据集上发现，随着缓冲区大小的增加，额外记忆的性能提升逐渐减少。在 Core50 上，缓冲区大小似乎对 PromptFusion 的性能没有影响。实际上并不奇怪，因为 Core50 的测试数据是一个恒定的集合，在训练期间没有看到。因此，影响性能的唯一因素是模型从训练集的顺序训练中积累域不变知识的能力，PromptFusion 在这方面表现出色。 ### 6.4. 消融研究 <strong>权重<span class="math-inline">\lambda</span> 掩码<span class="math-inline">W</span></strong> 我们在表 2 中报告了权重<span class="math-inline">\lambda</span> 掩码<span class="math-inline">W</span> 消融研究，结果表明这两个部分对 PromptFusion 的成功至关重要。具体来说，对于掩码<span class="math-inline">W</span>，其对 Split-Cifar100 的影响远大于对 Split-Imagenet-R 的影响。我们认为这是因为 Imagenet-R 数据集中的新旧类别更加多样化，因为语义和协变量偏移都发生了，导致类间干扰较弱。至于<span class="math-inline">\lambda</span>，不包括它意味着对两个结果进行简单的求和，表 2 中的结果显示这是次优的。如第 4 节所讨论的，我们期望<span class="math-inline">\lambda</span> 据被评估的数据集不同而不同。实际上，实验表明<span class="math-inline">\lambda = 0.95</span> 于 Split-Cifar100 和<span class="math-inline">\lambda = -0.21</span> 于 Split-Imagenet-R。这也与我们在图 6 中的实证发现一致，其中 VPT 在 Split-Cifar100 上表现更好，在 Split-Imagenet-R 上表现更差。 <strong>表 2：可训练权重的消融研究</strong> | 掩码<span class="math-inline">W</span>| 权重<span class="math-inline">\lambda</span>| Split-Cifar100 | Split-Imagenet-R | | --- | --- | --- | --- | | ✗ | ✗ | 82.8 | 79.8 | | ✗ | ✓ | 85.9 | 79.4 | | ✓ | ✗ | 87.3 | 80.7 | | ✓ | ✓ | 87.4 | 80.7 | <strong>提示长度</strong> 我们还检查了提示长度如何影响整体性能，结果报告在表 3 中。如所示，我们选择的<span class="math-inline">M = 4</span> <span class="math-inline">p = 30</span> 生了最佳的平均水平。这将在 Split-Cifar100 上需要总共 0.33M 个可训练参数，与其他方法相比微不足道。 <strong>表 3：提示长度<span class="math-inline">M</span> <span class="math-inline">p</span> 消融研究</strong> | 文本提示<span class="math-inline">M</span>| 图像提示<span class="math-inline">p</span> | Split-Cifar100 |<br />
| --- | --- | --- |<br />
| 2 | 20 | 86.8 |<br />
| 6 | 40 | 86.5 |<br />
| 4 | 30 | 87.4 |</p>
<p><strong>CoOp 增强</strong> 如第 5 节所述，CoOp 通过在语言提示之外加入另一组图像提示进行了增强。我们在表 4 中报告了这种增强的有效性。如所示，Split-Cifar100 上的性能提高了 1.2%，仅增加了 0.02M 个额外参数。</p>
<p><strong>表 4：增强 CoOp 的消融研究</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>Split-Cifar100</th>
</tr>
</thead>
<tbody>
<tr>
<td>无增强</td>
<td>86.2</td>
</tr>
<tr>
<td>有增强</td>
<td>87.4</td>
</tr>
</tbody>
</table>
<p><strong>为什么实例化 CoOp 和 VPT？</strong> 除了 CoOp 和 VPT 之间对稳定性和可塑性的不同偏好外，我们还经验性地发现这两种方法在更一般的意义上是互补的。这在图 9 中反映出来，其中两者的融合显著提高了整体性能。我们认为这是一个有意义的发现，可以推广到连续学习之外的更广泛的任务。</p>
<p><strong>图 9：CoOp、VPT 和 PromptFusion 在 Split-Cifar100 数据集上的平均准确率</strong></p>
<h2 id="7-结论">7. 结论<a class="anchor-link" href="#7-结论" title="Permanent link">&para;</a></h2>
<p>在本文中，我们介绍了一种双架构设计 PromptFusion，用于解决连续学习中的稳定性 - 可塑性困境。PromptFusion 是建立在 CoOp 实例化的稳定器模块和 VPT 实例化的助推器模块之上的，将稳定性和可塑性解耦为两个独立的问题。具体来说，对于给定的输入图像，PromptFusion 首先将其传递给两个模块，输出通过基于数据集的可学习权重参数进行融合。融合的输出进一步通过权重掩码平衡，以适应记忆缓冲区带来的类别不平衡。广泛的实验表明，我们的方法在类增量和域增量学习中都取得了最先进的结果。希望稳定性和可塑性的解耦理念能激发未来的工作。</p>
                </div>

                <!-- Comments Section (Giscus) -->
                <section class="comments-section">
                    <h3><i class="fas fa-comments"></i> 评论</h3>
                    <script src="https://giscus.app/client.js"
                        data-repo="Geeks-Z/Geeks-Z.github.io"
                        data-repo-id=""
                        data-category="Announcements"
                        data-category-id=""
                        data-mapping="pathname"
                        data-strict="0"
                        data-reactions-enabled="1"
                        data-emit-metadata="0"
                        data-input-position="bottom"
                        data-theme="preferred_color_scheme"
                        data-lang="zh-CN"
                        crossorigin="anonymous"
                        async>
                    </script>
                </section>
            </article>

            <footer class="post-footer">
                <p>© 2025 Hongwei Zhao. Built with ❤️</p>
            </footer>
        </main>
    </div>

    <!-- Theme Toggle Button -->
    <button class="theme-toggle" id="themeToggle" aria-label="切换主题">
        <i class="fas fa-moon"></i>
    </button>

    <script>
        // Theme Toggle
        const themeToggle = document.getElementById('themeToggle');
        const html = document.documentElement;
        const icon = themeToggle.querySelector('i');
        const hljsDark = document.getElementById('hljs-theme-dark');
        const hljsLight = document.getElementById('hljs-theme-light');
        
        // Check saved theme or system preference
        const savedTheme = localStorage.getItem('theme');
        const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
        
        if (savedTheme === 'dark' || (!savedTheme && prefersDark)) {
            html.setAttribute('data-theme', 'dark');
            icon.className = 'fas fa-sun';
            hljsDark.disabled = false;
            hljsLight.disabled = true;
        }
        
        themeToggle.addEventListener('click', () => {
            const isDark = html.getAttribute('data-theme') === 'dark';
            if (isDark) {
                html.removeAttribute('data-theme');
                icon.className = 'fas fa-moon';
                localStorage.setItem('theme', 'light');
                hljsDark.disabled = true;
                hljsLight.disabled = false;
            } else {
                html.setAttribute('data-theme', 'dark');
                icon.className = 'fas fa-sun';
                localStorage.setItem('theme', 'dark');
                hljsDark.disabled = false;
                hljsLight.disabled = true;
            }
            
            // Update Giscus theme
            const giscusFrame = document.querySelector('iframe.giscus-frame');
            if (giscusFrame) {
                giscusFrame.contentWindow.postMessage({
                    giscus: {
                        setConfig: {
                            theme: isDark ? 'light' : 'dark'
                        }
                    }
                }, 'https://giscus.app');
            }
        });
        
        // Highlight.js
        document.addEventListener('DOMContentLoaded', () => {
            hljs.highlightAll();
        });
        
        // KaTeX auto-render
        document.addEventListener('DOMContentLoaded', () => {
            if (typeof renderMathInElement !== 'undefined') {
                renderMathInElement(document.body, {
                    delimiters: [
                        {left: '$$', right: '$$', display: true},
                        {left: '$', right: '$', display: false},
                        {left: '\\[', right: '\\]', display: true},
                        {left: '\\(', right: '\\)', display: false}
                    ],
                    throwOnError: false
                });
            }
        });
        
        // TOC active state
        const tocLinks = document.querySelectorAll('.toc-container a');
        const headings = document.querySelectorAll('.post-content h2, .post-content h3, .post-content h4');
        
        function updateTocActive() {
            let current = '';
            headings.forEach(heading => {
                const rect = heading.getBoundingClientRect();
                if (rect.top <= 100) {
                    current = heading.getAttribute('id');
                }
            });
            
            tocLinks.forEach(link => {
                link.classList.remove('active');
                if (link.getAttribute('href') === '#' + current) {
                    link.classList.add('active');
                }
            });
        }
        
        window.addEventListener('scroll', updateTocActive);
        updateTocActive();
    </script>
</body>
</html>
