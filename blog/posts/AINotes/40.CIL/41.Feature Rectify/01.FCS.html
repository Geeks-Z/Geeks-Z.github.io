<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Untitled</title>
    <meta name="description" content="Untitled - Hongwei Zhao's Blog">
    <meta name="author" content="Hongwei Zhao">
    
    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Noto+Sans+SC:wght@300;400;500;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    
    <!-- Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <!-- Code Highlighting -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css" id="hljs-theme-dark">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css" id="hljs-theme-light" disabled>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    
    <!-- KaTeX for Math -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>
    
    <style>
        :root {
            /* Light Theme */
            --primary-color: #2980b9;
            --primary-hover: #1a5276;
            --link-color: #c0392b;
            --text-color: #333;
            --text-light: #666;
            --text-muted: #999;
            --bg-color: #fff;
            --bg-secondary: #f8f9fa;
            --bg-code: #f5f5f5;
            --border-color: #e5e7eb;
            --shadow: 0 1px 3px rgba(0,0,0,0.1);
            --shadow-lg: 0 4px 15px rgba(0,0,0,0.1);
        }

        [data-theme="dark"] {
            --primary-color: #5dade2;
            --primary-hover: #85c1e9;
            --link-color: #e74c3c;
            --text-color: #e5e7eb;
            --text-light: #9ca3af;
            --text-muted: #6b7280;
            --bg-color: #1a1a2e;
            --bg-secondary: #16213e;
            --bg-code: #0f0f23;
            --border-color: #374151;
            --shadow: 0 1px 3px rgba(0,0,0,0.3);
            --shadow-lg: 0 4px 15px rgba(0,0,0,0.4);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            scroll-behavior: smooth;
        }

        body {
            font-family: 'Inter', 'Noto Sans SC', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            font-size: 16px;
            line-height: 1.8;
            color: var(--text-color);
            background: var(--bg-color);
            transition: background-color 0.3s, color 0.3s;
        }

        a {
            color: var(--primary-color);
            text-decoration: none;
            transition: color 0.2s;
        }

        a:hover {
            color: var(--primary-hover);
            text-decoration: underline;
        }

        /* Layout */
        .page-wrapper {
            display: flex;
            max-width: 1400px;
            margin: 0 auto;
            padding: 2rem;
            gap: 3rem;
        }

        /* Sidebar TOC */
        .toc-sidebar {
            width: 260px;
            flex-shrink: 0;
            position: sticky;
            top: 2rem;
            height: fit-content;
            max-height: calc(100vh - 4rem);
            overflow-y: auto;
        }

        .toc-container {
            background: var(--bg-secondary);
            border-radius: 12px;
            padding: 1.5rem;
            border: 1px solid var(--border-color);
        }

        .toc-container h3 {
            font-size: 0.85rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-muted);
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .toc-container ul {
            list-style: none;
        }

        .toc-container li {
            margin-bottom: 0.5rem;
        }

        .toc-container a {
            font-size: 0.9rem;
            color: var(--text-light);
            display: block;
            padding: 0.25rem 0;
            border-left: 2px solid transparent;
            padding-left: 0.75rem;
            transition: all 0.2s;
        }

        .toc-container a:hover,
        .toc-container a.active {
            color: var(--primary-color);
            border-left-color: var(--primary-color);
            text-decoration: none;
        }

        .toc-container ul ul {
            margin-left: 1rem;
        }

        /* Main Content */
        .main-content {
            flex: 1;
            min-width: 0;
            max-width: 800px;
        }

        /* Header */
        .post-header {
            margin-bottom: 2rem;
            padding-bottom: 1.5rem;
            border-bottom: 1px solid var(--border-color);
        }

        .back-link {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.9rem;
            color: var(--text-light);
            margin-bottom: 1.5rem;
        }

        .back-link:hover {
            color: var(--primary-color);
            text-decoration: none;
        }

        .post-header h1 {
            font-size: 2.25rem;
            font-weight: 700;
            line-height: 1.3;
            margin-bottom: 1rem;
            color: var(--text-color);
        }

        .post-meta {
            display: flex;
            flex-wrap: wrap;
            gap: 1.5rem;
            font-size: 0.9rem;
            color: var(--text-light);
        }

        .post-meta span {
            display: flex;
            align-items: center;
            gap: 0.4rem;
        }

        .post-meta i {
            color: var(--text-muted);
        }

        .tags {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-top: 1rem;
        }

        .tag {
            display: inline-block;
            font-size: 0.8rem;
            background: var(--bg-secondary);
            color: var(--text-light);
            padding: 0.25rem 0.75rem;
            border-radius: 20px;
            border: 1px solid var(--border-color);
            transition: all 0.2s;
        }

        .tag:hover {
            background: var(--primary-color);
            color: white;
            border-color: var(--primary-color);
        }

        /* Article Content */
        .post-content {
            font-size: 1rem;
            line-height: 1.9;
        }

        .post-content h1,
        .post-content h2,
        .post-content h3,
        .post-content h4,
        .post-content h5,
        .post-content h6 {
            margin-top: 2rem;
            margin-bottom: 1rem;
            font-weight: 600;
            line-height: 1.4;
            color: var(--text-color);
        }

        .post-content h1 { font-size: 1.875rem; }
        .post-content h2 { 
            font-size: 1.5rem; 
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--border-color);
        }
        .post-content h3 { font-size: 1.25rem; }
        .post-content h4 { font-size: 1.125rem; }

        .post-content p {
            margin-bottom: 1.25rem;
        }

        .post-content ul,
        .post-content ol {
            margin: 1.25rem 0;
            padding-left: 1.5rem;
        }

        .post-content li {
            margin-bottom: 0.5rem;
        }

        .post-content blockquote {
            margin: 1.5rem 0;
            padding: 1rem 1.5rem;
            background: var(--bg-secondary);
            border-left: 4px solid var(--primary-color);
            border-radius: 0 8px 8px 0;
            color: var(--text-light);
            font-style: italic;
        }

        .post-content blockquote p:last-child {
            margin-bottom: 0;
        }

        /* Code */
        .post-content code {
            font-family: 'JetBrains Mono', 'Fira Code', Consolas, monospace;
            font-size: 0.9em;
            background: var(--bg-code);
            padding: 0.2em 0.4em;
            border-radius: 4px;
            color: var(--link-color);
        }

        .post-content pre {
            margin: 1.5rem 0;
            padding: 1.25rem;
            background: var(--bg-code);
            border-radius: 10px;
            overflow-x: auto;
            border: 1px solid var(--border-color);
        }

        .post-content pre code {
            background: none;
            padding: 0;
            color: inherit;
            font-size: 0.875rem;
            line-height: 1.6;
        }

        /* Images */
        .post-content img {
            max-width: 100%;
            height: auto;
            border-radius: 10px;
            margin: 1.5rem 0;
            box-shadow: var(--shadow-lg);
        }

        /* Tables */
        .post-content table {
            width: 100%;
            margin: 1.5rem 0;
            border-collapse: collapse;
            font-size: 0.95rem;
        }

        .post-content th,
        .post-content td {
            padding: 0.75rem 1rem;
            border: 1px solid var(--border-color);
            text-align: left;
        }

        .post-content th {
            background: var(--bg-secondary);
            font-weight: 600;
        }

        .post-content tr:nth-child(even) {
            background: var(--bg-secondary);
        }

        /* Math */
        .math-display {
            margin: 1.5rem 0;
            overflow-x: auto;
            padding: 1rem;
            background: var(--bg-secondary);
            border-radius: 8px;
        }

        /* Anchor links */
        .anchor-link {
            opacity: 0;
            margin-left: 0.5rem;
            color: var(--text-muted);
            font-weight: 400;
            transition: opacity 0.2s;
        }

        .post-content h2:hover .anchor-link,
        .post-content h3:hover .anchor-link,
        .post-content h4:hover .anchor-link {
            opacity: 1;
        }

        /* Theme Toggle */
        .theme-toggle {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: var(--primary-color);
            color: white;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.25rem;
            box-shadow: var(--shadow-lg);
            transition: transform 0.2s, background 0.2s;
            z-index: 1000;
        }

        .theme-toggle:hover {
            transform: scale(1.1);
            background: var(--primary-hover);
        }

        /* Comments Section */
        .comments-section {
            margin-top: 3rem;
            padding-top: 2rem;
            border-top: 1px solid var(--border-color);
        }

        .comments-section h3 {
            font-size: 1.25rem;
            margin-bottom: 1.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        /* Footer */
        .post-footer {
            margin-top: 3rem;
            padding-top: 1.5rem;
            border-top: 1px solid var(--border-color);
            text-align: center;
            font-size: 0.9rem;
            color: var(--text-muted);
        }

        /* Responsive */
        @media (max-width: 1024px) {
            .toc-sidebar {
                display: none;
            }
            
            .page-wrapper {
                padding: 1.5rem;
            }
        }

        @media (max-width: 768px) {
            .post-header h1 {
                font-size: 1.75rem;
            }
            
            .post-meta {
                flex-direction: column;
                gap: 0.5rem;
            }
            
            .theme-toggle {
                bottom: 1rem;
                right: 1rem;
                width: 44px;
                height: 44px;
            }
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-secondary);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--text-muted);
        }
    </style>
</head>
<body>
    <div class="page-wrapper">
        <!-- TOC Sidebar -->
        <aside class="toc-sidebar">
            <div class="toc-container">
                <h3><i class="fas fa-list"></i> 目录</h3>
                <div class="toc">
<ul>
<li><a href="#fcs-feature-calibration-and-separation-for-non-exemplar-class-incremental-learning">FCS: Feature Calibration and Separation for Non-Exemplar Class Incremental Learning</a></li>
<li><a href="#kimi全文翻译-arrow_down">Kimi全文翻译 :arrow_down:</a></li>
<li><a href="#0-摘要">0. 摘要</a></li>
<li><a href="#1-引言">1. 引言</a></li>
<li><a href="#2-相关工作">2. 相关工作</a><ul>
<li><a href="#21-类别增量学习">2.1. 类别增量学习</a></li>
<li><a href="#22-非范例类增量学习">2.2. 非范例类增量学习</a></li>
</ul>
</li>
<li><a href="#3-问题表述和分析">3. 问题表述和分析</a><ul>
<li><a href="#31-问题表述">3.1. 问题表述</a></li>
<li><a href="#32-遗忘分析">3.2. 遗忘分析</a></li>
</ul>
</li>
<li><a href="#4-提出的方法">4. 提出的方法</a><ul>
<li><a href="#41-特征校准网络fcn">4.1. 特征校准网络（FCN）</a></li>
<li><a href="#42-涉及原型的对比损失pic">4.2. 涉及原型的对比损失（PIC）</a></li>
<li><a href="#43-总体优化">4.3. 总体优化</a></li>
</ul>
</li>
<li><a href="#5-实验">5. 实验</a><ul>
<li><a href="#51-实验设置">5.1. 实验设置</a><ul>
<li><a href="#511-数据集">5.1.1 数据集</a></li>
<li><a href="#512-比较方法">5.1.2 比较方法</a></li>
<li><a href="#513-评估指标">5.1.3 评估指标</a></li>
<li><a href="#514-实现细节">5.1.4 实现细节</a></li>
</ul>
</li>
<li><a href="#52-与-sota-的比较">5.2. 与 SOTA 的比较</a></li>
<li><a href="#53-消融研究">5.3. 消融研究</a></li>
</ul>
</li>
<li><a href="#6-结论">6. 结论</a></li>
</ul>
</div>

            </div>
        </aside>

        <!-- Main Content -->
        <main class="main-content">
            <article>
                <header class="post-header">
                    <a href="../../../../index.html" class="back-link">
                        <i class="fas fa-arrow-left"></i> 返回博客列表
                    </a>
                    <h1>Untitled</h1>
                    <div class="post-meta">
                        <span><i class="fas fa-calendar-alt"></i> 2026-01-28</span>
                        <span><i class="fas fa-folder"></i> AINotes/40.CIL/41.Feature Rectify</span>
                        <span><i class="fas fa-user"></i> Hongwei Zhao</span>
                    </div>
                    <div class="tags">
                        
                    </div>
                </header>

                <div class="post-content">
                    <h2 id="fcs-feature-calibration-and-separation-for-non-exemplar-class-incremental-learning"><a href="https://ieeexplore.ieee.org/document/10657158/?arnumber=10657158">FCS: Feature Calibration and Separation for Non-Exemplar Class Incremental Learning</a><a class="anchor-link" href="#fcs-feature-calibration-and-separation-for-non-exemplar-class-incremental-learning" title="Permanent link">&para;</a></h2>
<blockquote>
<p>CVPR 2024 | <a href="https://github.com/zhoujiahuan1991/CVPR2024-FCS">Code</a></p>
</blockquote>
<h2 id="kimi全文翻译-arrow_down">Kimi全文翻译 :arrow_down:<a class="anchor-link" href="#kimi全文翻译-arrow_down" title="Permanent link">&para;</a></h2>
<h2 id="0-摘要">0. 摘要<a class="anchor-link" href="#0-摘要" title="Permanent link">&para;</a></h2>
<p>非范例类增量学习（NECIL）涉及在没有之前遇到的旧类别样本的情况下，对一系列数据进行分类模型的学习。这样的严格约束总是会导致对所学知识的灾难性遗忘。目前，现有方法要么采用知识蒸馏技术，要么保留类别原型来维持先前的知识。然而，仍然存在两个关键问题。一方面，随着模型的不断更新，旧类别保留的原型将不可避免地从新模型的特征空间中的合适位置漂移。另一方面，由于缺乏样本，新类别的特征将取代类似旧类别的位置，破坏分类边界。为了解决这些挑战，我们提出了一种针对 NECIL 的特征校准和分离（FCS）方法。我们的方法包括一个特征校准网络（FCN），通过最优传输学习将旧类别的原型适应到新模型，近似模型演化引起的原型漂移。此外，我们还提出了一种涉及原型的对比损失（PIC），增强不同类别之间的特征分离。具体来说，为了减轻不同学习阶段类别之间相互作用引起的边界扭曲，原型被涉及推动新类别的特征远离旧类别。在三种不同设置的数据集上的广泛实验已经证明了我们的 FCS 方法相对于最先进的类别增量学习方法的优越性。代码可在 https://github.com/zhoujiahuan1991/CVPR2024-FCS 上找到。</p>
<h2 id="1-引言">1. 引言<a class="anchor-link" href="#1-引言" title="Permanent link">&para;</a></h2>
<p>随着时间的推移，作为计算机视觉中的一个里程碑研究任务，图像分类一直受到大量关注。传统的基于深度学习的模型被设计为从静态数据中学习，假设所有类别的整个训练数据一次性可用。在处理动态和不断演变的数据流时，先前学习的类别的性能严重下降，导致一种称为灾难性遗忘的现象。为了解决这个问题，受人类在其一生中不断获取知识自然方式的启发，增量学习（IL）最近被研究。一个流行的 IL 解决方案旨在保留以前阶段的代表性数据，并在当前数据训练时回放过去知识。然而，它们不仅引起了关于数据隐私的关键问题，而且还导致了大量的存储和训练消耗。因此，本文考虑了一种更实用但更具挑战性的 IL 场景，即无法访问以前的样本，称为非范例类增量学习（NECIL）。在这种设置中，由于缺乏明确的先前知识，灾难性遗忘的问题变得更加严重。</p>
<p>现有的 NECIL 方法主要依赖于知识蒸馏将知识从旧模型转移到新模型，或记忆一组先前学习的类别原型以保留知识。尽管上述努力在一定程度上可以减轻灾难性遗忘，但性能受到两个关键挑战的限制。如图 1(3) 所示，随着新类别的增量学习，旧类别保留的原型将不可避免地在新模型的特征空间中漂移，不再能够准确代表这些旧类别的区分特征。尽管少数现有工作提出了估计不同 IL 阶段之间的特征变化，但它们仍然忽略了一个 IL 阶段内的变化。此外，没有旧类别的历史样本的指导，新类别的特征将占据并挤压类似于旧类别的空间。因此，旧类别和新类别之间的重叠破坏了分类边界，导致知识遗忘。如图 2 所示，当同时使用旧类别和新类别的分类头时，与单独使用它们相比，准确率明显下降。</p>
<p>为了解决上述挑战，我们提出了一种新的 NECIL 方法，关注 IL 阶段的特征校准和分离（FCS）。设计的 FCS 包括一个特征校准网络（FCN），将历史原型适应到新模型的特征空间中的适当位置，以及一个涉及原型的对比损失（PIC），分离旧类别和新类别的特征，以处理特征重叠引起的恶化。具体来说，受著名的最优传输理论的启发，我们提出的 FCN 在连接旧模型和新模型的特征空间中起着重要作用。通过将旧模型和新模型提取的新数据特征视为源和目标分布，通过最小化对齐源到目标分布特征的传输成本来学习传输计划。因此，FCN 利用这样的传输计划在校准新模型特征空间中的历史原型位置，并减轻漂移问题。此外，PIC 被设计用来解决特征重叠引起的分类边界扭曲。与现有方法不同，原型仅用于训练分类头，我们将通过我们的 FCN 校准的原型视为负参考，推动新类别远离旧类别。此外，提出的 PIC 损失也可以区分地分离新类别的特征，以进一步提高新模型的 IL 性能。总之，本文的主要贡献是三方面的：（1）提出了一个新的特征校准网络，适当地将历史原型适应到新模型的特征空间，减轻由特征漂移引起的灾难性遗忘问题。（2）引入了涉及原型的对比损失，进一步减轻不同 IL 阶段之间特征重叠引起的遗忘。（3）在各种基准上的广泛实验验证了我们方法在不同设置中的优越性。</p>
<h2 id="2-相关工作">2. 相关工作<a class="anchor-link" href="#2-相关工作" title="Permanent link">&para;</a></h2>
<h3 id="21-类别增量学习">2.1. 类别增量学习<a class="anchor-link" href="#21-类别增量学习" title="Permanent link">&para;</a></h3>
<p>现有的 CIL 方法主要可以分为三组：基于回放的、基于正则化的和基于网络架构的。基于回放的方法专注于保留以前阶段的代表性数据，并采用知识蒸馏提取并将以前阶段获取的知识转移到当前模型。基于正则化的方法旨在通过控制特征调整来稳定模型参数，从而减轻遗忘倾向。基于网络架构的模型动态调整网络结构或为不同阶段设计特定参数以适应不断演变的数据流。尽管上述方法取得了实质性进展，基于回放的方法和大多数基于正则化和网络架构的方法需要数据存储，可能引起数据隐私问题。</p>
<h3 id="22-非范例类增量学习">2.2. 非范例类增量学习<a class="anchor-link" href="#22-非范例类增量学习" title="Permanent link">&para;</a></h3>
<p>最近，非范例类增量学习（NECIL）特征化了一个特别具有挑战性的场景，即无法获取以前类别的样本，在这种情况下，先前数据的缺失进一步加剧了灾难性遗忘的问题。已经提出了各种 NECIL 方法来解决这个问题。引入了模型不同 IL 阶段输出之间的知识蒸馏损失以抵抗遗忘。旨在通过生成样本来回放旧知识来训练生成器，但他们的性能高度依赖于生成数据的高质量，并且顺序更新的生成器也面临灾难性遗忘的问题。从模型参数的角度来看，通过冻结部分模型参数来减少不同 IL 阶段知识更新的影响。尽管这些工作有效地减轻了遗忘，它们获取新知识的能力受到严重限制。最近的工作采用仅一小部分参数来提示模型，但高度依赖于大规模预训练模型。提出标签和原型增强以有效保留过去知识，但是保留的原型将不可避免地在新模型的特征空间中漂移，导致知识遗忘。尽管试图通过插值每个 IL 阶段后旧模型和新模型提取的新数据特征漂移来适应原型，但它简单地忽略了新模型的特征空间在一个 IL 阶段内不断变化的事实。因此，它们处理灾难性遗忘的能力仍然有限。此外，上述方法忽略了不同阶段类别特征之间的重叠，这也会导致根据我们的观察导致知识遗忘。</p>
<h2 id="3-问题表述和分析">3. 问题表述和分析<a class="anchor-link" href="#3-问题表述和分析" title="Permanent link">&para;</a></h2>
<h3 id="31-问题表述">3.1. 问题表述<a class="anchor-link" href="#31-问题表述" title="Permanent link">&para;</a></h3>
<p>在 NECIL 任务中，数据流由 <span class="math-inline">T</span> 个阶段组成，表示为 <span class="math-inline">D = {D_t}<em>{t=1}^T</span> 依次进入以增量训练模型。每个数据集 <span class="math-inline">D_t = {X_t, Y_t}</span> 由输入数据集 <span class="math-inline">X_t = {x</em>{t,j}}<em>{j=1}^{n_t}</span> 和标签集 <span class="math-inline">Y_t = {y</em>{t,j} \in C_t}<em>{j=1}^{n_t}</span> 组成，其中 <span class="math-inline">n_t</span> 是阶段 <span class="math-inline">t</span> 中的数据数量，<span class="math-inline">x</em>{t,j}</span> 代表第 <span class="math-inline">j</span> 个图像，<span class="math-inline">C_t</span> 是标签集。需要注意的是，不同阶段的标签是不相交的，即 <span class="math-inline">C_i \cap C_j = \emptyset</span>（<span class="math-inline">i \neq j</span>）。在阶段 <span class="math-inline">t</span> 中，模型由特征提取器 <span class="math-inline">f_t: \mathbb{R}^{h \times w \times 3} \rightarrow \mathbb{R}^d</span> 和分类头 <span class="math-inline">g_t: \mathbb{R}^d \rightarrow \mathbb{R}^{l_t}</span> 组成，其中 <span class="math-inline">d</span> 是特征维度，<span class="math-inline">l_t = \sum_{j=1}^{t} |C_j|</span> 是已学习类别的数量。输入图像 <span class="math-inline">x</span> 的预测标签可以通过 <span class="math-inline">\arg\max g_t \circ f_t(x)</span> 获得。</p>
<h3 id="32-遗忘分析">3.2. 遗忘分析<a class="anchor-link" href="#32-遗忘分析" title="Permanent link">&para;</a></h3>
<p>在本节中，我们首先分析 NECIL 中遗忘的潜在原因，并阐明我们的动机。阶段 <span class="math-inline">t</span> 的模型可以表示为 <span class="math-inline">\theta_t = g_t \circ f_t = [g_n^t, g_o^t] \circ f_t</span>，其中 <span class="math-inline">g_n^t: \mathbb{R}^d \rightarrow \mathbb{R}^{|C_t|}</span> 和 <span class="math-inline">g_o^t: \mathbb{R}^d \rightarrow \mathbb{R}^{c_t-1}</span> 分别是新类别和旧类别的分类头。同时，阶段 <span class="math-inline">t-1</span> 学习的模型表示为 <span class="math-inline">\theta_{t-1} = g_{t-1} \circ f_{t-1}</span>。如图 1 所示，在阶段 <span class="math-inline">t</span> 期间，我们观察到灾难性遗忘可能由以下四个方面引起：</p>
<p>特征提取器的变化（<span class="math-inline">f_{t-1}, f_t</span>）如图 1(1) 所示：在阶段 <span class="math-inline">t</span> 获得的特征提取器 <span class="math-inline">f_t</span> 将不可避免地与前身 <span class="math-inline">f_{t-1}</span> 不同。此外，缺乏历史数据可能加剧这一现象，可能使 <span class="math-inline">f_t</span> 不适用于早期阶段遇到的数据。为了解决这个问题，现有方法通常采用各种知识蒸馏损失来保留以前模型的知识。例如，PASS 通过最小化旧模型和新模型提取的特征之间的欧几里得距离来改善这一点：<br />
<div class="math-display"><br />
    L_{kd} = |f_t(x) - f_{t-1}(x)|^2. \tag{1}<br />
</div><br />
分类头的变化（<span class="math-inline">g_{t-1}, g_o^t</span>）如图 1(2) 所示：与特征提取器的变化类似，旧类别的分类头 <span class="math-inline">g_{t-1}</span>，将不可避免地因缺少前序类别的数据而受到干扰。为了解决这个问题，最近的方法提出在训练期间维护一小部分先前类别的原型 <span class="math-inline">\Omega_{t-1}</span>。具体来说，原型被增强并用于训练分类头以维持旧知识。<br />
<div class="math-display"><br />
    L_{pro} = L_{ce}(g_t(\text{Aug}(\Omega_{t-1})), Y'<em>{t-1}), \tag{2}<br />
</div><br />
其中 Aug 表示原型增强，<span class="math-inline">\Omega</em>{t-1}</span> 表示之前 <span class="math-inline">t-1</span> 任务的原型，<span class="math-inline">Y'<em>{t-1}</span> 表示原型的类标签，<span class="math-inline">L</em>{ce}</span> 是交叉熵损失。</p>
<p>虽然先前的研究主要集中在前两个方面，但我们确定了另外两个可能导致严重遗忘的因素：</p>
<p>次优交互 <span class="math-inline">f_t</span> 和 <span class="math-inline">g_o^t</span> 如图 1(3) 所示：尽管提出了各种知识蒸馏损失来减轻特征提取器的变化，新模型 <span class="math-inline">f_t</span> 的特征空间将不可避免地与旧的 <span class="math-inline">f_{t-1}</span> 发散。因此，新模型维护的旧类别原型将从旧模型漂移。这种不匹配可能会破坏原型准确表示旧类别的能力，从而损害分类头 <span class="math-inline">g_o^t</span> 的能力。为了解决这个问题，我们引入了一个特征校准网络（FCN），它传输原型到新模型的特征空间，从而缓解了由于模型转换引起的特征漂移。</p>
<p><span class="math-inline">g_o^t</span> 和 <span class="math-inline">g_n^t</span> 之间的交集如图 1(4) 所示：由于在阶段 <span class="math-inline">t</span> 只能访问 <span class="math-inline">D_t</span>，<span class="math-inline">D_t</span> 中的当前数据特征可能取代从 <span class="math-inline">D_1</span> 到 <span class="math-inline">D_{t-1}</span> 的类似历史数据。这种不同训练阶段之间的特征重叠引入了分类边界突破的潜力，随后导致性能下降。我们在图 2 中提供了这个问题的具体演示。我们可以观察到，当同时使用旧类别和新类别的分类头时，与单独使用它们相比，准确率明显下降。这种显著的下降显示了不同阶段类别之间分类边界交集的显著影响。为了有效解决这个挑战，我们引入了涉及原型的对比损失（PIC），它分离旧类别的原型和新类别的特征，以减少分类边界的相互影响。</p>
<h2 id="4-提出的方法">4. 提出的方法<a class="anchor-link" href="#4-提出的方法" title="Permanent link">&para;</a></h2>
<div align=center><img src="https://markdownimg-hw.oss-cn-beijing.aliyuncs.com/20250119144204.png" style="zoom: 80%;" /></div>

<h3 id="41-特征校准网络fcn">4.1. 特征校准网络（FCN）<a class="anchor-link" href="#41-特征校准网络fcn" title="Permanent link">&para;</a></h3>
<p>如上所述，我们展示了直接在新模型的特征空间中使用旧模型提取的原型会导致次优性能。将旧模型和新模型的特征空间表示为 <span class="math-inline">F_{t-1}</span> 和 <span class="math-inline">F_t</span>，概率分布表示为 <span class="math-inline">P \in \mathcal{P}(F_{t-1})</span> 和 <span class="math-inline">Q \in \mathcal{P}(F_t)</span>。我们的目标是获得一个传输计划 <span class="math-inline">\mathcal{T}</span>，将分布 <span class="math-inline">P</span> 映射到 <span class="math-inline">Q</span> 并具有最低误差，这也被称为最优传输问题。Monge 的最优传输表述可以形成为：<br />
<div class="math-display"><br />
    \text{Cost}(F_{t-1}, F_t) = \inf_{\mathcal{T} \mathbb{P} = \mathbb{Q}} \int_{F_t} c(x, T(x)) d\mathbb{P}(x), \tag{3}<br />
</div><br />
其中 <span class="math-inline">T: F_{t-1} \rightarrow F_t</span> 是将源空间特征传输到目标空间的传输计划，<span class="math-inline">c(x, T(x))</span> 是将 <span class="math-inline">x</span> 传输到 <span class="math-inline">T(x)</span> 的成本。在 IL 阶段 <span class="math-inline">t</span> 的训练步骤中，模型被喂入一批数据 <span class="math-inline">{X_t, Y_t} = {x_j, y_j}<em>{j=1}^{n_b}</span>，从 <span class="math-inline">D_t</span> 中采样，批量大小为 <span class="math-inline">n_b</span>。我们可以得到旧模型和新模型提取的 <span class="math-inline">x_j</span> 的特征，分别为 <span class="math-inline">f</em>{t-1}(x_j)</span> 和 <span class="math-inline">f_t(x_j)</span>。然后，方程（3）可以在离散形式中近似：<br />
<div class="math-display"><br />
    \text{Cost}(F_{t-1}, F_t) = \inf_{{T} \mathbb{P} = \mathbb{Q}} \frac{1}{n_b} \sum_{j=1}^{n_b} c \left( f_{t-1}(x_j), T \left( f_{t-1}(x_j) \right) \right). \tag{4}<br />
</div><br />
对于成本函数 <span class="math-inline">c</span>，<span class="math-inline">f_{t-1}</span> 提取的某个 <span class="math-inline">x_j</span> 的特征应该映射到相关特征 <span class="math-inline">f_t(x_j)</span>，因此我们设置成本函数如下：<br />
<div class="math-display"><br />
    c \left( f_{t-1}(x_j), T \left( f_{t-1}(x_j) \right) \right) = |T \left( f_{t-1}(x_j) \right) - f_t(x_j)|^2. \tag{5}<br />
</div><br />
与先前方法解决两个固定样本集之间的最优传输问题不同，我们的方法使用神经网络实现传输计划。这个网络通过最小化训练过程中的成本 <span class="math-inline">\text{Cost}(F_{t-1}, F_t)</span> 来优化。<br />
<div class="math-display">L_T = \text{Cost}(F_{t-1}, F_t). \tag{6}</div></p>
<p>然后，学习到的传输计划 <span class="math-inline">T</span> 作为特征校准网络，将原型传输到新模型的特征空间（图 3）。在增量训练阶段 <span class="math-inline">t</span> 期间，我们有旧类别的原型 <span class="math-inline">\Omega_{t-1}</span>，这些原型在训练分类头之前被传输到新模型的特征空间。因此，与方程（2）中的原型分类损失相比，我们的损失函数是：<br />
<div class="math-display"><br />
    L_{pro-T} = L_{ce} \left( g_t \left( T \left( \text{Aug}(\Omega_{t-1}) \right) \right), Y'<em>{t-1} \right). \tag{7}<br />
</div><br />
在 IL 阶段 <span class="math-inline">t</span> 的训练之后，可以维护阶段 <span class="math-inline">t</span> 中新类别的原型 <span class="math-inline">\omega_t</span> 作为每个类别中特征的平均值。然后，前 <span class="math-inline">t</span> 阶段的原型是 <span class="math-inline">\Omega_t = T(\Omega</em>{t-1}) \cup \omega_t</span>，由校准的原型 <span class="math-inline">T(\Omega_{t-1})</span> 和新类别的原型 <span class="math-inline">\omega_t</span> 组成。</p>
<h3 id="42-涉及原型的对比损失pic">4.2. 涉及原型的对比损失（PIC）<a class="anchor-link" href="#42-涉及原型的对比损失pic" title="Permanent link">&para;</a></h3>
<p>知识遗忘的另一个方面是不同 IL 阶段相似类别的重叠，这将破坏已建立的分类边界，导致性能下降。为了解决这个挑战，我们引入了 PIC，它从两个方面减轻特征重叠：分离新类别以留出更多空间进行未来更新，并将新类别从旧类别推开。首先，受对比学习有效聚集相似特征的启发，我们采用监督对比损失来压缩每个类别的特征，从而允许更大的灵活性以适应未来类别。为了简化符号，本节省略了训练阶段 <span class="math-inline">t</span>。给定一批数据索引 <span class="math-inline">I</span>，我们增强每个数据 <span class="math-inline">x</span> 并得到查询视图 <span class="math-inline">x_q</span> 和关键视图 <span class="math-inline">x_k</span>，然后监督对比损失可以表示为：<br />
<div class="math-display"><br />
    L_{co} = -\sum_{i \in I} \frac{1}{|S(i)|} \sum_{p \in S(i)} \log \frac{\exp(z{^q_i} \cdot z{^k_p}/\tau)}{\sum_{a \in I} \exp(z{^q_i} \cdot z{^k_a}/\tau)}, \tag{8}<br />
</div><br />
其中 <span class="math-inline">S(i)</span> 是与图像 <span class="math-inline">x_i</span> 具有相同类别标签的索引集，<span class="math-inline">z{^q_i} = f(x{^q_i})</span> 和 <span class="math-inline">z{^k_i} = f(x{^k_i})</span> 分别表示由特征提取器 <span class="math-inline">f</span> 提取的查询视图和关键视图 <span class="math-inline">x_i</span> 的特征，<span class="math-inline">\tau</span> 是一个标量温度参数。其次，在初始训练阶段之后，我们有部分代表以前类别特征的维护原型。为了充分利用原型中的知识，原型被视为与训练样本不同类别的特征，然后监督对比损失是：<br />
<div class="math-display"><br />
    L_{co} = -\sum_{i \in I} \frac{1}{|S(i)|} \sum_{p \in S(i)} \log \frac{\exp(z{^q_i} \cdot z{^k_p}/\tau)}{\sum_{a \in I \cup I_\Omega} \exp(z{^q_i} \cdot z{^k_a}/\tau)}, \tag{9}<br />
</div><br />
其中 <span class="math-inline">I_\Omega</span> 是原型的索引集。通过利用涉及原型的对比损失，同一类别的实例被拉近在一起。同时，实例不仅被推开与不同类别，而且还与以前类别的原型分开。这种方法允许模型为未来类别留出更多空间，并分离不同类别的特征，减轻了分类边界交集引起的遗忘。</p>
<h3 id="43-总体优化">4.3. 总体优化<a class="anchor-link" href="#43-总体优化" title="Permanent link">&para;</a></h3>
<p>对于我们方法的优化，首先使用经典的交叉熵损失 <span class="math-inline">L_{ce}</span> 进行主干训练。如上所述，我们的分析揭示了遗忘的四个不同方面，导致采用不同的损失来分别解决它们。我们探索了广泛认可的知识蒸馏损失 <span class="math-inline">L_{kd}</span>（方程（1））和原型分类损失 <span class="math-inline">L_{pro}</span>（方程（2））作为现有方法。然后，提出的校准网络学习损失 <span class="math-inline">L_T</span>（方程（6））用于学习可以将旧类别原型传输到新模型特征空间的 FCN。在此转换的基础上，我们用校准的原型替换 <span class="math-inline">L_{pro}</span> 中的原型，得到我们的原型分类损失 <span class="math-inline">L_{pro-T}</span>（方程（7））。最后，采用涉及原型的对比损失 <span class="math-inline">L_{co}</span>（方程（9））来减轻特征重叠问题。总体优化损失可以表示为：<br />
<div class="math-display"><br />
    L = L_{ce} + \alpha L_{kd} + \beta L_{pro-T} + \gamma L_T + \lambda L_{co}, \tag{10}<br />
</div><br />
其中 <span class="math-inline">\alpha</span>、<span class="math-inline">\beta</span>、<span class="math-inline">\gamma</span> 和 <span class="math-inline">\lambda</span> 是平衡不同组成部分的权重参数。</p>
<h2 id="5-实验">5. 实验<a class="anchor-link" href="#5-实验" title="Permanent link">&para;</a></h2>
<h3 id="51-实验设置">5.1. 实验设置<a class="anchor-link" href="#51-实验设置" title="Permanent link">&para;</a></h3>
<h4 id="511-数据集">5.1.1 数据集<a class="anchor-link" href="#511-数据集" title="Permanent link">&para;</a></h4>
<p>我们在三个公共数据集上评估我们提出的 FCS 模型：CIFAR-100、TinyImageNet 和 ImageNet-Subset。CIFAR-100 包含 100 个类别，每个类别有 500 张训练图像和 100 张测试图像。TinyImageNet 包含 200 个类别，每个类别有 500 张训练图像和 50 张测试图像。ImageNet-Subset 是 ImageNet 的一个子集，包含 100 个类别，每个类别有 1300 张训练图像和 50 张测试图像。我们遵循传统的 NECIL 设置来构建增量设置。具体来说，对于 CIFAR-100，模型在 50、50 和 40 个类别上训练，然后分别在 5、10 和 20 个 IL 阶段进行训练。对于 TinyImageNet，模型在 100 个类别上训练，然后分别在 5、10 和 20 个 IL 阶段进行训练。对于 ImageNet-Subset，模型在 50 个类别上训练，然后在 10 个 IL 阶段进行训练。</p>
<h4 id="512-比较方法">5.1.2 比较方法<a class="anchor-link" href="#512-比较方法" title="Permanent link">&para;</a></h4>
<p>我们的 FCS 方法与各种最先进的 NECIL 方法进行比较，包括 LwF、PASS、IL2A、SSRE、R-DFCIL、EDG 和 FeTrIL。此外，我们还与两种基于范例的 CIL 方法进行比较，iCaRL 和 EEIL，记忆大小设置为每个类别 20 个样本。此外，还包括两个特殊的实验设置，Joint-Train 和 Fine-Tune。Joint-Train 意味着所有数据一次性用于训练，作为上限结果。Fine-Tune 意味着直接微调模型，不使用任何抗遗忘算法。</p>
<h4 id="513-评估指标">5.1.3 评估指标<a class="anchor-link" href="#513-评估指标" title="Permanent link">&para;</a></h4>
<p>按照先前的工作，我们使用准确率和平均遗忘进行评估。准确率是所有已学习类别的平均准确率。平均遗忘计算了增量学习过程中不同任务的平均性能下降，可以估计先前任务的遗忘。</p>
<h4 id="514-实现细节">5.1.4 实现细节<a class="anchor-link" href="#514-实现细节" title="Permanent link">&para;</a></h4>
<p>我们使用广泛采用的 ResNet-18 作为我们的主干，并从头开始训练它。参数由 Adam 优化器进行优化，初始学习率为 1e3，权重衰减为 2e-4。模型训练 100 个周期，每 45 个周期后学习率衰减 0.1。我们将批量大小设置为 64，并遵循数据增强。特征校准网络实现为一个线性层，初始化为单位矩阵和零偏置。我们将不同损失的权重参数设置为 <span class="math-inline">\alpha = 10</span>、<span class="math-inline">\beta = 10</span>、<span class="math-inline">\gamma = 1</span> 和 <span class="math-inline">\lambda = 0.1</span>，对于 5、10 个增量阶段的设置，<span class="math-inline">\lambda = 0.03</span> 对于 20 个增量学习阶段和 ImageNet-Subset 数据集。所有实验都在单个 NVIDIA 4090 GPU 上使用 PyTorch 实现。</p>
<h3 id="52-与-sota-的比较">5.2. 与 SOTA 的比较<a class="anchor-link" href="#52-与-sota-的比较" title="Permanent link">&para;</a></h3>
<p>主要结果。表 1 显示了最终准确率的结果。在各种情况下，我们的方法显著优于以前的非范例方法和经典的基于范例的方法。我们在 CIFAR-100 上取得了 4.01%、2.75%、4.69% 的性能提升，在 TinyImageNet 上取得了 3.12%、2.54%、1.24% 的性能提升，在 ImageNet-Subset 上取得了 0.54% 的性能提升。值得注意的是，使用知识蒸馏原型的方法（例如，PASS、IL2A）随着阶段数量从 5 增加到 20，准确率大幅下降，CIFAR-100 上下降了 9.47%、9.69%，TinyImageNet 上下降了 7.72%、9.51%。相比之下，我们的结果表现出相对较小的性能下降，分别为 4.96% 和 3.47%。这种韧性归因于我们的校准原型对演变模型的适应性，以及我们的涉及原型的对比损失在减轻特征重叠方面的有效性。值得注意的是，在 ImageNet-Subset 上，我们的方法仅比冻结主干的方法（FeTrIL）高出 0.54%。这是因为 FeTrIL 冻结了主干，从而有效地保留了特征提取器的知识，防止了在应用于大型数据集时的遗忘。然而，FeTrIL 的知识获取能力受到严重限制，导致在 CIFAR-100 和 TinyImageNet 上的结果较差。此外，我们还在表 2 中提供了 CIFAR-100 上的平均遗忘结果。可以观察到，我们方法的平均遗忘最低，展示了我们方法的优越抗遗忘能力。</p>
<p>准确率曲线。为了详细展示我们的结果，我们在图 4 中展示了 CIFAR-100 数据集上我们方法的准确率。值得注意的是，我们的方法在初始阶段具有类似的准确率，在后续阶段取得了最佳结果。这一观察强调了我们的方法在知识遗忘和获取之间取得了更好的平衡。</p>
<p>混淆矩阵。在图 5 中，我们展示了 CIFAR-100 上不同方法的混淆矩阵。我们的方法在正确预测早期阶段的类别（矩阵的左上角）方面超越了现有方法。这是因为通过 FCN 校准的原型能更好地表示新模型特征空间中的旧类别特征，从而保留更多的知识。此外，PIC 有助于减轻旧类别和新类别之间的干扰，也有助于这一改进。</p>
<h3 id="53-消融研究">5.3. 消融研究<a class="anchor-link" href="#53-消融研究" title="Permanent link">&para;</a></h3>
<p>结果分析。为了阐明 FCS 的有效性，我们在 CIFAR-100 数据集上进行了广泛的实验。我们的方法包括两个组成部分：特征校准网络和涉及原型的对比损失。表 3 中的结果证实了以下观察：（1）我们方法的基线与 SOTA 方法取得了相当的结果，展示了通过 [41, 42] 提出技术增强模型训练的潜力。这种策略的融合增强了更泛化特征的学习，从而提高了整体性能。（2）FCN 的加入以（1.26%，2.40%，3.83%）的优势改善了基线的结果。这种增益可以归因于 FCN，它学习了旧模型和新模型特征空间之间的传输函数。校准的原型能更好地代表新模型特征空间中的历史数据特征，从而保留更多的知识以抵抗遗忘。值得注意的是，随着阶段从 5 增加到 20，FCN 带来的改进增加。这一现象归因于学习过程中模型变化的累积，我们的方法可以有效地减轻这个问题，取得了更好的结果。（3）显著地，使用 FCN 和 PIC 一起取得了最佳结果。这种组合方法比单独使用 FCN 实现了（0.36%，0.66%，0.05%）的改进。这种增益可以归因于 PIC 分离不同阶段的相似类别特征并减少对分类边界的损害的能力。同时，FCN 也通过为模型提供更合适和可适应的原型做出了贡献。</p>
<p>FCN 的消融研究。在表 4 中，我们展示了使用不同架构的特征校准网络（FCN）的结果。我们用三种不同的网络实现 FCN。具体来说，[512, 512] 表示一个输入维度为 512，输出维度为 512 的线性层。[512, D,512] 表示两个线性层，输入维度为 512，D 和输出维度分别为 D，512。结果表明，单线性层取得了最佳性能。这可以归因于线性层有效地捕获模型间特征漂移，同时相对容易学习。使用单线性层还确保了线性可分属性的保留，这有助于线性分类的学习。因此，我们选择这个单层作为我们 FCN 的架构。</p>
<p>FCN 的有效性。为了进一步阐明 FCN 的有效性，我们在图 6 中可视化了在 20 阶段设置下 CIFAR-100 和 TinyImageNet 数据集上每个阶段维护的原型与适当原型（由新模型提取）之间的平均欧几里得距离。我们可以观察到，我们方法的距离低于基线方法。这一现象表明 FCN 可以有效地将原型从旧模型的特征空间传输到新模型，并减轻特征空间漂移带来的知识遗忘。</p>
<p>PIC 的有效性。为了展示 PIC 的有效性，在图 7 中，我们展示了不同阶段旧类别（左）和新类别（中）的分类准确率的可视化。值得注意的是，采用 PIC 提高了旧类别和新类别在一系列阶段的准确率。这种改进可以归因于 PIC 分离不同类别的特征，从而减少它们的交集。为了进一步分析这种能力，我们展示了不同阶段类别之间分类边界交集导致的平均性能下降（右）。平均性能下降是作为仅使用旧类别和新类别的分类头与它们联合部署相比的性能下降来计算的（越低越好）。结果表明 PIC 可以减轻这种退化，证明了它在最小化分类边界汇合方面的有效性。</p>
<h2 id="6-结论">6. 结论<a class="anchor-link" href="#6-结论" title="Permanent link">&para;</a></h2>
<p>在本文中，我们介绍了一种特征校准和分离（FCS）方法来解决具有挑战性的非范例类增量学习（NECIL）任务。我们提出的 FCS 由一个新颖的特征校准网络（FCN）和一个特定的涉及原型的对比损失（PIC）组成。具体来说，受最优传输理论的启发，FCN 学习旧模型和新模型特征空间之间的传输函数，以校准保留的原型的漂移。此外，PIC 损失被设计为通过对比学习充分利用原型的知识，将不同 IL 阶段的类别分离开来，进一步增强了所提方法的泛化能力和区分能力。在各种数据集上的广泛实验展示了我们的 FCS 方法的优越性。致谢。这项工作得到了中国国家自然科学基金（62376011, 61925201, 62132001）的支持。</p>
                </div>

                <!-- Comments Section (Giscus) -->
                <section class="comments-section">
                    <h3><i class="fas fa-comments"></i> 评论</h3>
                    <script src="https://giscus.app/client.js"
                        data-repo="Geeks-Z/Geeks-Z.github.io"
                        data-repo-id=""
                        data-category="Announcements"
                        data-category-id=""
                        data-mapping="pathname"
                        data-strict="0"
                        data-reactions-enabled="1"
                        data-emit-metadata="0"
                        data-input-position="bottom"
                        data-theme="preferred_color_scheme"
                        data-lang="zh-CN"
                        crossorigin="anonymous"
                        async>
                    </script>
                </section>
            </article>

            <footer class="post-footer">
                <p>© 2025 Hongwei Zhao. Built with ❤️</p>
            </footer>
        </main>
    </div>

    <!-- Theme Toggle Button -->
    <button class="theme-toggle" id="themeToggle" aria-label="切换主题">
        <i class="fas fa-moon"></i>
    </button>

    <script>
        // Theme Toggle
        const themeToggle = document.getElementById('themeToggle');
        const html = document.documentElement;
        const icon = themeToggle.querySelector('i');
        const hljsDark = document.getElementById('hljs-theme-dark');
        const hljsLight = document.getElementById('hljs-theme-light');
        
        // Check saved theme or system preference
        const savedTheme = localStorage.getItem('theme');
        const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
        
        if (savedTheme === 'dark' || (!savedTheme && prefersDark)) {
            html.setAttribute('data-theme', 'dark');
            icon.className = 'fas fa-sun';
            hljsDark.disabled = false;
            hljsLight.disabled = true;
        }
        
        themeToggle.addEventListener('click', () => {
            const isDark = html.getAttribute('data-theme') === 'dark';
            if (isDark) {
                html.removeAttribute('data-theme');
                icon.className = 'fas fa-moon';
                localStorage.setItem('theme', 'light');
                hljsDark.disabled = true;
                hljsLight.disabled = false;
            } else {
                html.setAttribute('data-theme', 'dark');
                icon.className = 'fas fa-sun';
                localStorage.setItem('theme', 'dark');
                hljsDark.disabled = false;
                hljsLight.disabled = true;
            }
            
            // Update Giscus theme
            const giscusFrame = document.querySelector('iframe.giscus-frame');
            if (giscusFrame) {
                giscusFrame.contentWindow.postMessage({
                    giscus: {
                        setConfig: {
                            theme: isDark ? 'light' : 'dark'
                        }
                    }
                }, 'https://giscus.app');
            }
        });
        
        // Highlight.js
        document.addEventListener('DOMContentLoaded', () => {
            hljs.highlightAll();
        });
        
        // KaTeX auto-render
        document.addEventListener('DOMContentLoaded', () => {
            if (typeof renderMathInElement !== 'undefined') {
                renderMathInElement(document.body, {
                    delimiters: [
                        {left: '$$', right: '$$', display: true},
                        {left: '$', right: '$', display: false},
                        {left: '\\[', right: '\\]', display: true},
                        {left: '\\(', right: '\\)', display: false}
                    ],
                    throwOnError: false
                });
            }
        });
        
        // TOC active state
        const tocLinks = document.querySelectorAll('.toc-container a');
        const headings = document.querySelectorAll('.post-content h2, .post-content h3, .post-content h4');
        
        function updateTocActive() {
            let current = '';
            headings.forEach(heading => {
                const rect = heading.getBoundingClientRect();
                if (rect.top <= 100) {
                    current = heading.getAttribute('id');
                }
            });
            
            tocLinks.forEach(link => {
                link.classList.remove('active');
                if (link.getAttribute('href') === '#' + current) {
                    link.classList.add('active');
                }
            });
        }
        
        window.addEventListener('scroll', updateTocActive);
        updateTocActive();
    </script>
</body>
</html>
