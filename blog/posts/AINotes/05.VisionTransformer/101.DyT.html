<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Untitled</title>
    <meta name="description" content="Untitled - Hongwei Zhao's Blog">
    <meta name="author" content="Hongwei Zhao">
    
    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Noto+Sans+SC:wght@300;400;500;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    
    <!-- Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <!-- Code Highlighting -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css" id="hljs-theme-dark">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css" id="hljs-theme-light" disabled>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    
    <!-- KaTeX for Math -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>
    
    <style>
        :root {
            /* Light Theme - 明亮清新配色 */
            --primary-color: #4A90D9;
            --primary-hover: #3678C2;
            --link-color: #E86B5F;
            --text-color: #2D2D2D;
            --text-light: #5A5A5A;
            --text-muted: #8A8A8A;
            --bg-color: #FFFFFF;
            --bg-secondary: #F5F7FA;
            --bg-code: #F8F9FC;
            --border-color: #E8ECF0;
            --shadow: 0 2px 8px rgba(0,0,0,0.06);
            --shadow-lg: 0 8px 24px rgba(0,0,0,0.08);
        }

        [data-theme="dark"] {
            --primary-color: #5dade2;
            --primary-hover: #85c1e9;
            --link-color: #e74c3c;
            --text-color: #e5e7eb;
            --text-light: #9ca3af;
            --text-muted: #6b7280;
            --bg-color: #1a1a2e;
            --bg-secondary: #16213e;
            --bg-code: #0f0f23;
            --border-color: #374151;
            --shadow: 0 1px 3px rgba(0,0,0,0.3);
            --shadow-lg: 0 4px 15px rgba(0,0,0,0.4);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            scroll-behavior: smooth;
        }

        body {
            font-family: 'Inter', 'Noto Sans SC', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            font-size: 16px;
            line-height: 1.8;
            color: var(--text-color);
            background: var(--bg-color);
            transition: background-color 0.3s, color 0.3s;
        }

        a {
            color: var(--primary-color);
            text-decoration: none;
            transition: color 0.2s;
        }

        a:hover {
            color: var(--primary-hover);
            text-decoration: underline;
        }

        /* Layout */
        .page-wrapper {
            display: flex;
            max-width: 1400px;
            margin: 0 auto;
            padding: 2rem;
            gap: 3rem;
        }

        /* Sidebar TOC */
        .toc-sidebar {
            width: 260px;
            flex-shrink: 0;
            position: sticky;
            top: 2rem;
            height: fit-content;
            max-height: calc(100vh - 4rem);
            overflow-y: auto;
        }

        .toc-container {
            background: var(--bg-secondary);
            border-radius: 12px;
            padding: 1.5rem;
            border: 1px solid var(--border-color);
        }

        .toc-container h3 {
            font-size: 0.85rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-muted);
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .toc-container ul {
            list-style: none;
        }

        .toc-container li {
            margin-bottom: 0.5rem;
        }

        .toc-container a {
            font-size: 0.9rem;
            color: var(--text-light);
            display: block;
            padding: 0.25rem 0;
            border-left: 2px solid transparent;
            padding-left: 0.75rem;
            transition: all 0.2s;
        }

        .toc-container a:hover,
        .toc-container a.active {
            color: var(--primary-color);
            border-left-color: var(--primary-color);
            text-decoration: none;
        }

        .toc-container ul ul {
            margin-left: 1rem;
        }

        /* Main Content */
        .main-content {
            flex: 1;
            min-width: 0;
            max-width: 800px;
        }

        /* Header */
        .post-header {
            margin-bottom: 2rem;
            padding-bottom: 1.5rem;
            border-bottom: 1px solid var(--border-color);
        }

        .back-link {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.9rem;
            color: var(--text-light);
            margin-bottom: 1.5rem;
        }

        .back-link:hover {
            color: var(--primary-color);
            text-decoration: none;
        }

        .post-header h1 {
            font-size: 2.25rem;
            font-weight: 700;
            line-height: 1.3;
            margin-bottom: 1rem;
            color: var(--text-color);
        }

        .post-meta {
            display: flex;
            flex-wrap: wrap;
            gap: 1.5rem;
            font-size: 0.9rem;
            color: var(--text-light);
        }

        .post-meta span {
            display: flex;
            align-items: center;
            gap: 0.4rem;
        }

        .post-meta i {
            color: var(--text-muted);
        }

        .tags {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-top: 1rem;
        }

        .tag {
            display: inline-block;
            font-size: 0.8rem;
            background: var(--bg-secondary);
            color: var(--text-light);
            padding: 0.25rem 0.75rem;
            border-radius: 20px;
            border: 1px solid var(--border-color);
            transition: all 0.2s;
        }

        .tag:hover {
            background: var(--primary-color);
            color: white;
            border-color: var(--primary-color);
        }

        /* Article Content */
        .post-content {
            font-size: 1rem;
            line-height: 1.9;
        }

        .post-content h1,
        .post-content h2,
        .post-content h3,
        .post-content h4,
        .post-content h5,
        .post-content h6 {
            margin-top: 2rem;
            margin-bottom: 1rem;
            font-weight: 600;
            line-height: 1.4;
            color: var(--text-color);
        }

        .post-content h1 { font-size: 1.875rem; }
        .post-content h2 { 
            font-size: 1.5rem; 
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--border-color);
        }
        .post-content h3 { font-size: 1.25rem; }
        .post-content h4 { font-size: 1.125rem; }

        .post-content p {
            margin-bottom: 1.25rem;
        }

        .post-content ul,
        .post-content ol {
            margin: 1.25rem 0;
            padding-left: 1.5rem;
        }

        .post-content li {
            margin-bottom: 0.5rem;
        }

        .post-content blockquote {
            margin: 1.5rem 0;
            padding: 1rem 1.5rem;
            background: var(--bg-secondary);
            border-left: 4px solid var(--primary-color);
            border-radius: 0 8px 8px 0;
            color: var(--text-light);
            font-style: italic;
        }

        .post-content blockquote p:last-child {
            margin-bottom: 0;
        }

        /* Code */
        .post-content code {
            font-family: 'JetBrains Mono', 'Fira Code', Consolas, monospace;
            font-size: 0.9em;
            background: var(--bg-code);
            padding: 0.2em 0.4em;
            border-radius: 4px;
            color: var(--link-color);
        }

        .post-content pre {
            margin: 1.5rem 0;
            padding: 1.25rem;
            background: var(--bg-code);
            border-radius: 10px;
            overflow-x: auto;
            border: 1px solid var(--border-color);
        }

        .post-content pre code {
            background: none;
            padding: 0;
            color: inherit;
            font-size: 0.875rem;
            line-height: 1.6;
        }

        /* Images */
        .post-content img {
            max-width: 100%;
            height: auto;
            border-radius: 10px;
            margin: 1.5rem 0;
            box-shadow: var(--shadow-lg);
        }

        /* Tables */
        .post-content table {
            width: 100%;
            margin: 1.5rem 0;
            border-collapse: collapse;
            font-size: 0.95rem;
        }

        .post-content th,
        .post-content td {
            padding: 0.75rem 1rem;
            border: 1px solid var(--border-color);
            text-align: left;
        }

        .post-content th {
            background: var(--bg-secondary);
            font-weight: 600;
        }

        .post-content tr:nth-child(even) {
            background: var(--bg-secondary);
        }

        /* Math */
        .math-display {
            margin: 1.5rem 0;
            overflow-x: auto;
            padding: 1rem;
            background: var(--bg-secondary);
            border-radius: 8px;
        }

        /* Anchor links */
        .anchor-link {
            opacity: 0;
            margin-left: 0.5rem;
            color: var(--text-muted);
            font-weight: 400;
            transition: opacity 0.2s;
        }

        .post-content h2:hover .anchor-link,
        .post-content h3:hover .anchor-link,
        .post-content h4:hover .anchor-link {
            opacity: 1;
        }

        /* Theme Toggle */
        .theme-toggle {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: var(--primary-color);
            color: white;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.25rem;
            box-shadow: var(--shadow-lg);
            transition: transform 0.2s, background 0.2s;
            z-index: 1000;
        }

        .theme-toggle:hover {
            transform: scale(1.1);
            background: var(--primary-hover);
        }

        /* Comments Section */
        .comments-section {
            margin-top: 3rem;
            padding-top: 2rem;
            border-top: 1px solid var(--border-color);
        }

        .comments-section h3 {
            font-size: 1.25rem;
            margin-bottom: 1.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        /* Footer */
        .post-footer {
            margin-top: 3rem;
            padding-top: 1.5rem;
            border-top: 1px solid var(--border-color);
            text-align: center;
            font-size: 0.9rem;
            color: var(--text-muted);
        }

        /* Responsive */
        @media (max-width: 1024px) {
            .toc-sidebar {
                display: none;
            }
            
            .page-wrapper {
                padding: 1.5rem;
            }
        }

        @media (max-width: 768px) {
            .post-header h1 {
                font-size: 1.75rem;
            }
            
            .post-meta {
                flex-direction: column;
                gap: 0.5rem;
            }
            
            .theme-toggle {
                bottom: 1rem;
                right: 1rem;
                width: 44px;
                height: 44px;
            }
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-secondary);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--text-muted);
        }
    </style>
</head>
<body>
    <div class="page-wrapper">
        <!-- TOC Sidebar -->
        <aside class="toc-sidebar">
            <div class="toc-container">
                <h3><i class="fas fa-list"></i> 目录</h3>
                <div class="toc">
<ul>
<li><a href="#dynamic-tuning-towards-parameter-and-inference-efficiency-for-vit-adaptation">Dynamic Tuning Towards Parameter and Inference Efficiency for ViT Adaptation</a></li>
<li><a href="#0-摘要">0. 摘要</a></li>
<li><a href="#1-引言">1. 引言</a></li>
<li><a href="#2-相关工作">2. 相关工作</a><ul>
<li><a href="#21-参数高效微调">2.1 参数高效微调</a></li>
<li><a href="#22-动态神经网络">2.2 动态神经网络</a></li>
</ul>
</li>
<li><a href="#3-使用动态调整的-vits-适应">3. 使用动态调整的 ViTs 适应</a><ul>
<li><a href="#31-预备知识">3.1 预备知识</a></li>
<li><a href="#32-动态调整">3.2 动态调整</a><ul>
<li><a href="#令牌调度器">令牌调度器</a></li>
<li><a href="#微调阶段">微调阶段</a></li>
<li><a href="#推理阶段">推理阶段</a></li>
</ul>
</li>
<li><a href="#33-模型变体">3.3 模型变体</a></li>
<li><a href="#34-moe--适配器">3.4 MoE- 适配器</a></li>
<li><a href="#35-损失函数">3.5 损失函数</a></li>
</ul>
</li>
<li><a href="#4-实验">4. 实验</a><ul>
<li><a href="#41-实验设置">4.1 实验设置</a></li>
<li><a href="#42-分析">4.2 分析</a><ul>
<li><a href="#模型变体">模型变体</a></li>
<li><a href="#moe-适配器的有效性">MoE-适配器的有效性</a></li>
<li><a href="#每层激活令牌的可视化">每层激活令牌的可视化</a></li>
<li><a href="#激活令牌的可视化">激活令牌的可视化</a></li>
</ul>
</li>
<li><a href="#43-vtab-1k-结果">4.3 VTAB-1K 结果</a><ul>
<li><a href="#与-peft-方法的比较">与 PEFT 方法的比较</a></li>
<li><a href="#动态调整实现实际加速">动态调整实现实际加速</a></li>
</ul>
</li>
<li><a href="#44-进一步探索">4.4 进一步探索</a><ul>
<li><a href="#在训练数据充足的图像数据集上的有效性">在训练数据充足的图像数据集上的有效性</a></li>
<li><a href="#从图像到视频的令牌数量扩展">从图像到视频的令牌数量扩展</a></li>
</ul>
</li>
<li><a href="#45-vtab-1k-结果">4.5 VTAB-1K 结果</a><ul>
<li><a href="#与高效transformer方法的比较和兼容性">与高效transformer方法的比较和兼容性</a></li>
<li><a href="#在图像数据集上的有效性">在图像数据集上的有效性</a></li>
<li><a href="#从图像到视频的令牌数量扩展_1">从图像到视频的令牌数量扩展</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#5-讨论和结论">5. 讨论和结论</a></li>
<li><a href="#a-附录">A. 附录</a><ul>
<li><a href="#a1-常见问题">A.1 常见问题</a></li>
<li><a href="#a2-与先前工作的区别">A.2 与先前工作的区别</a></li>
<li><a href="#a3-更多分析">A.3 更多分析</a><ul>
<li><a href="#a31-调度级别和调度策略的调查">A.3.1 调度级别和调度策略的调查</a></li>
<li><a href="#a32-模型变体的-flops--准确率曲线">A.3.2 模型变体的 FLOPs- 准确率曲线</a></li>
<li><a href="#a33-不同的瓶颈维度">A.3.3 不同的瓶颈维度</a></li>
<li><a href="#a34-温度的调查">A.3.4 温度的调查</a></li>
</ul>
</li>
<li><a href="#a4-语义分割中的泛化能力">A.4 语义分割中的泛化能力</a></li>
<li><a href="#a5-目标检测和实例分割中的泛化能力">A.5 目标检测和实例分割中的泛化能力</a></li>
<li><a href="#a6-完整模型和蒸馏的有效性">A.6 完整模型和蒸馏的有效性</a></li>
<li><a href="#a7-gumbel-sigmoid-的详细信息">A.7 Gumbel-Sigmoid 的详细信息</a></li>
<li><a href="#a8-实现细节">A.8 实现细节</a><ul>
<li><a href="#a81-vtab-1k-的实验设置">A.8.1 VTAB-1K 的实验设置</a></li>
<li><a href="#a82-完整图像数据集的实验设置">A.8.2 完整图像数据集的实验设置</a></li>
<li><a href="#a83-视频数据集的实验设置">A.8.3 视频数据集的实验设置</a></li>
<li><a href="#a84-语义分割数据集的实验设置">A.8.4 语义分割数据集的实验设置</a></li>
</ul>
</li>
<li><a href="#a9-transformer架构的泛化能力">A.9 transformer架构的泛化能力</a></li>
<li><a href="#a10-模型尺寸的扩展">A.10 模型尺寸的扩展</a></li>
<li><a href="#a11-激活令牌的额外可视化">A.11 激活令牌的额外可视化</a></li>
</ul>
</li>
</ul>
</div>

            </div>
        </aside>

        <!-- Main Content -->
        <main class="main-content">
            <article>
                <header class="post-header">
                    <a href="../../../index.html" class="back-link">
                        <i class="fas fa-arrow-left"></i> 返回博客列表
                    </a>
                    <h1>Untitled</h1>
                    <div class="post-meta">
                        <span><i class="fas fa-calendar-alt"></i> 2026-02-04</span>
                        <span><i class="fas fa-folder"></i> AINotes/05.VisionTransformer</span>
                        <span><i class="fas fa-user"></i> Hongwei Zhao</span>
                    </div>
                    <div class="tags">
                        
                    </div>
                </header>

                <div class="post-content">
                    <h2 id="dynamic-tuning-towards-parameter-and-inference-efficiency-for-vit-adaptation"><a href="http://arxiv.org/abs/2403.11808">Dynamic Tuning Towards Parameter and Inference Efficiency for ViT Adaptation</a><a class="anchor-link" href="#dynamic-tuning-towards-parameter-and-inference-efficiency-for-vit-adaptation" title="Permanent link">&para;</a></h2>
<h2 id="0-摘要">0. 摘要<a class="anchor-link" href="#0-摘要" title="Permanent link">&para;</a></h2>
<p>现有参数高效的微调（PEFT）方法在ViTs的适应性改进上取得了显著的成功，但在适应过程中提高推理效率的探索仍然不足。这限制了预训练 ViT 模型的更广泛应用，尤其是在模型计算密集的情况下。本文提出了一种新的方法 Dynamic Tuning（DyT），旨在提高 ViT 适应性的参数和推理效率。具体来说，除了使用轻量级适配器模块，我们还提出了一个令牌调度器来区分信息丰富的令牌和较不重要的令牌，允许后者动态跳过原始块，减少推理期间的冗余计算。此外，我们还探索了多种设计变体，以找到 DyT 的最佳实践。最后，受混合专家（MoE）机制的启发，我们引入了一个增强型适配器，以进一步提升适应性能。我们在多种任务上验证了 DyT，包括图像/视频识别和语义分割。例如，在 VTAB-1K 基准测试中，DyT 在仅引发现有 PEFT 方法 71% 的 FLOPs 的情况下实现了优越的性能。</p>
<h2 id="1-引言">1. 引言<a class="anchor-link" href="#1-引言" title="Permanent link">&para;</a></h2>
<p>随着ViTs[20, 52, 26] 的显著成功，对预训练的 ViT 进行微调以适应其他数据领域 [89] 或任务应用 [88, 35, 59, 78] 已成为一种常见做法。然而，随着模型大小的增加 [87, 16, 51]，与目标任务相关的适应成本变得令人望而却步，因为微调和推理的负担。参数高效微调（PEFT）方法（例如 AdaptFormer [12]、LoRA [33] 和 VPT [35]）被提出来通过减少可调模型参数来解决调整问题。它们通常只更新少量参数，同时保持原始模型固定，这有效地减少了可学习参数，同时保持了微调精度。</p>
<p>尽管在参数效率方面进行了广泛的研究，但对目标任务的推理效率的探索较少。我们通过图 1(a) 中的数值展示了三种代表性 PEFT 方法的推理效率，揭示了它们在推理期间没有减少计算，与全微调相比。这一限制对适应预训练 ViT 到下游任务提出了挑战，特别是当模型计算密集型时。为此，我们的目标是统一参数和推理视角，以实现高效的 ViT 适应。</p>
<div align=center><img src="https://markdownimg-hw.oss-cn-beijing.aliyuncs.com/20241227211255.png" style="zoom: 80%;" /></div>

<h2 id="2-相关工作">2. 相关工作<a class="anchor-link" href="#2-相关工作" title="Permanent link">&para;</a></h2>
<h3 id="21-参数高效微调">2.1 参数高效微调<a class="anchor-link" href="#21-参数高效微调" title="Permanent link">&para;</a></h3>
<p>参数高效微调（PEFT）旨在通过仅调整一小部分参数来适应预训练模型到下游任务。现有的 PEFT 方法可以广泛分为三类：基于适配器的方法、基于重参数化的方法和基于提示的方法。基于适配器的方法 [12, 32, 61, 37, 14] 在原始模型中插入一些小模块，并且仅在微调期间更新这些插入的模块。重参数化方法 [86, 33, 46, 21, 18] 通常与重参数化技术合作，直接修改预训练模型中的特定参数。基于提示的方法 [35, 2, 94, 93, 39, 9, 8] 涉及在输入序列中附加少量可学习的令牌，从而适应冻结层中的中间特征。有关更全面的综述，请参考 [83, 45]。</p>
<p>然而，PEFT 方法主要关注在微调期间提高参数效率，同时忽视了推理成本的降低。在本文中，我们提出同时提高参数效率和解决推理主机问题，以实现高效的 ViT 适应。</p>
<h3 id="22-动态神经网络">2.2 动态神经网络<a class="anchor-link" href="#22-动态神经网络" title="Permanent link">&para;</a></h3>
<p>动态神经网络 [28, 62, 91] 可以根据输入数据动态调整其架构，这使它们能够根据输入数据控制计算冗余。现有方法已经探索了在卷积神经网络中的动态层深度 [70, 4, 80, 30, 27, 85]、动态通道宽度 [31, 42, 29, 81] 和动态路由 [44]。在ViT时代，许多工作 [76, 75, 68, 66, 47, 73, 56, 58, 57, 63] 试图通过减少令牌冗余来提高推理效率。例如，Liang 等人 [47] 在每个transformer层中识别并合并不关注的令牌为一个令牌。Rao 等人 [66] 在层之间逐步丢弃信息量较少的令牌。Wang 等人 [75] 调整代表图像的令牌数量。更详细的文献综述可以在 [28, 74] 中找到。Zhou 等人 [95] 提出使用 ReLU 函数评估令牌重要性，以有效处理点云分析。尽管这些方法在视觉任务中取得了显著的成功，但它们需要从头开始训练模型或在与预训练相同的数据集上进行全参数微调，使它们不适合高效的 ViT 适应。</p>
<p>与这些方法相比，提出的方法可以适应预训练知识到不同的下游数据集和任务，同时通过引入微不足道的额外参数，在推理期间减少计算成本。</p>
<h2 id="3-使用动态调整的-vits-适应">3. 使用动态调整的 ViTs 适应<a class="anchor-link" href="#3-使用动态调整的-vits-适应" title="Permanent link">&para;</a></h2>
<h3 id="31-预备知识">3.1 预备知识<a class="anchor-link" href="#31-预备知识" title="Permanent link">&para;</a></h3>
<p>ViT由一系列层组成。多头自注意力块表示为 <span class="math-inline">\text{Attn}</span>，多层感知器块称为 <span class="math-inline">\text{MLP}</span>，是每层的主要成分。每层的输入可以表示为 <span class="math-inline">X = [x_{\text{cls}}, x_1, x_2, \ldots, x_N] \in \mathbb{R}^{(N+1) \times C}</span>，包含 <span class="math-inline">N</span> 个图像令牌和一个分类令牌 <span class="math-inline">x_{\text{cls}}</span>。</p>
<p>适配器架构已在先前的 PEFT 方法 [12, 37, 32] 中广泛探索。适配器通常被设计为一个瓶颈模块，由一个投影层 <span class="math-inline">W_{\text{down}} \in \mathbb{R}^{C \times d}</span> 组成，用于压缩通道维度，另一个投影层 <span class="math-inline">W_{\text{up}} \in \mathbb{R}^{d \times C}</span> 用于维度恢复。这里，<span class="math-inline">d</span> 表示瓶颈维度，<span class="math-inline">d \ll C</span> 确保适配器的效率。给定输入特征 <span class="math-inline">X</span>，适配器操作可以表示为：<br />
<div class="math-display"><br />
    X_{\text{adapt}} = \text{Adapter}(X) = \sigma(XW_{\text{down}})W_{\text{up}},<br />
</div><br />
其中 <span class="math-inline">\sigma</span> 表示一个非线性函数，例如 ReLU。在本研究中，我们遵循这种通用架构在动态调整中构建适配器。我们将适配器与 <span class="math-inline">\text{Attn}</span> 块、<span class="math-inline">\text{MLP}</span> 块或整个transformer层并行放置，将在第 3.3 节中详细说明。</p>
<h3 id="32-动态调整">3.2 动态调整<a class="anchor-link" href="#32-动态调整" title="Permanent link">&para;</a></h3>
<p>在ViTs中，计算负担主要位于transformer层中。具体来说，<span class="math-inline">\text{Attn}</span> 和 <span class="math-inline">\text{MLP}</span> 中的操作分别占 ViT-B/16[20] 中总 FLOPs 的约 35.8% 和 63.5%。先前的工作 [66, 47] 揭示了 ViTs 中存在令牌冗余问题，并发现可以丢弃一些令牌而不牺牲性能。受此启发，我们提出了一种高效的 ViT 适应方法，名为动态调整（DyT），它不仅在微调期间保持参数效率，而且还减少了推理期间的冗余计算。核心思想是在transformer块内动态选择处理令牌。给定块的输入令牌 <span class="math-inline">X</span>，DyT 可以表示为：<br />
<div class="math-display"><br />
    X' = \text{Block}(\text{TD}(X)) + \text{Adapter}(X),<br />
</div><br />
其中 <span class="math-inline">\text{Block}</span> 可以表示一个多头自注意力块 <span class="math-inline">\text{Attn}</span>、一个多层感知器 <span class="math-inline">\text{MLP}</span>，或整个transformer层。提出的令牌调度器（TD）学习选择性激活或停用令牌。只有被激活的令牌被输入到 <span class="math-inline">\text{Block}</span> 中，而所有令牌都被适配器处理。</p>
<h4 id="令牌调度器">令牌调度器<a class="anchor-link" href="#令牌调度器" title="Permanent link">&para;</a></h4>
<p>DyT 的关键点在于选择部分令牌通过 <span class="math-inline">\text{Attn}</span> 和/或 <span class="math-inline">\text{MLP}</span>。一个直接的方法是随机选择令牌，以预定义的概率，并使模型适应这些选定的令牌进行下游任务。然而，这种简单策略冒着丢弃信息丰富的令牌而保留较不重要的令牌的风险，可能会阻碍适应性能。为了解决这个问题，我们提出了一个令牌调度器（TD），它在适应期间学习选择令牌。具体来说，给定输入令牌 <span class="math-inline">X \in \mathbb{R}^{(N+1) \times C}</span>，TD 学习选择性激活一系列令牌 <span class="math-inline">X_s \in \mathbb{R}^{K \times C}</span>，其中 <span class="math-inline">K</span> 表示被激活令牌的数量。为了实现这一点，它应该获得一个掩码 <span class="math-inline">M \in \mathbb{R}^{N+1}</span>，指示是否应该激活或停用令牌。</p>
<p>为了获得 <span class="math-inline">M</span>，我们采用一个投影层 <span class="math-inline">W_g \in \mathbb{R}^{C \times 1}</span>，然后通过一个 sigmoid 函数来预测激活概率 <span class="math-inline">S \in \mathbb{R}^{N+1}</span>。然后，我们将 0.5 作为阈值来确定每个令牌的激活。这可以表示为：<br />
<div class="math-display"><br />
    S = \text{Sigmoid}(XW_g), \quad M_n = \begin{cases}<br />
    1 &amp; \text{if } S_n \geq 0.5 \<br />
    0 &amp; \text{if } S_n &lt; 0.5<br />
    \end{cases}<br />
</div><br />
<span class="math-inline">M_n = 1</span> 表示第 <span class="math-inline">n</span> 个令牌被激活，并将随后经历 <span class="math-inline">\text{Block}</span> 的处理。相反，如果 <span class="math-inline">M_n = 0</span>，令牌将被停用并跳过 <span class="math-inline">\text{Block}</span>。在实践中，我们总是将分类令牌 <span class="math-inline">x_{\text{cls}}</span> 的掩码值设置为 1，允许它遍历整个网络。值得注意的是，TD 中引入的额外参数数量可以忽略不计，线性层 <span class="math-inline">W_g</span> 中仅有 <span class="math-inline">C</span> 个参数。</p>
<h4 id="微调阶段">微调阶段<a class="anchor-link" href="#微调阶段" title="Permanent link">&para;</a></h4>
<p>然而，直接使用阈值使 <span class="math-inline">M</span> 成为一个离散决策，导致微调期间的非可微问题。为了解决这个问题，我们将 Gumbel 噪声 [31] 引入 sigmoid 中，以替换原始的 sigmoid 函数。这可以表示为：<br />
<div class="math-display"><br />
    S = \text{Gumbel-Sigmoid}(XW_g) = \text{Sigmoid}(XW_g + G_1 - G_2 / \tau),<br />
</div><br />
其中 <span class="math-inline">G_1, G_2 \sim \text{Gumbel}(0, 1)</span>。<span class="math-inline">\tau</span> 代表温度，默认设置为 5.0。附录 A.7 提供了 Gumbel-Sigmoid 的更多细节。随后，我们可以使用方程 3 中的相同操作获得 <span class="math-inline">M</span>。Gumbel 噪声使训练期间 <span class="math-inline">M</span> 的采样变得随机，我们采用 <span class="math-inline">S</span> 作为 <span class="math-inline">M</span> 的可微分近似。这两者都有助于 TD 以端到端的方式进行训练。训练期间的前向和后向传播计算可以表示为：<br />
<div class="math-display"><br />
    X_s = \begin{cases}<br />
    \text{Block}(X) \cdot M &amp; \text{(前向传播)} \<br />
    \text{Block}(X) \cdot S &amp; \text{(后向传播)}<br />
    \end{cases},<br />
</div><br />
方程 2 可以重写为：<br />
<div class="math-display"><br />
    X' = X + X_s + \text{Adapter}(X).<br />
</div><br />
从方程 5 中，只有被激活令牌的块输出，<span class="math-inline">\text{Block}(X)</span>，被保留，而其他被 <span class="math-inline">M</span> 屏蔽。如图 2(a) 所示，在微调阶段，<span class="math-inline">X</span> 中的所有令牌仍然需要遍历 <span class="math-inline">\text{Block}</span>。</p>
<h4 id="推理阶段">推理阶段<a class="anchor-link" href="#推理阶段" title="Permanent link">&para;</a></h4>
<p>在推理期间，我们可以直接采用方程 3 生成调度掩码 <span class="math-inline">M</span>，并在 TD 中获得被激活的令牌 <span class="math-inline">X_s \in \mathbb{R}^{K \times C}</span>。然后，我们只能将它们输入到 <span class="math-inline">\text{Block}</span> 中。仅处理 <span class="math-inline">K</span> 个令牌有效地减少了计算成本，因为 <span class="math-inline">K &lt; N</span>。在实践中，我们添加填充以保持张量形状的输出从 <span class="math-inline">\text{Block}</span>。这导致方程 2。见图 2(b) 以获得推理阶段的详细说明。</p>
<div align=center><img src="https://markdownimg-hw.oss-cn-beijing.aliyuncs.com/20241227212024.png" style="zoom: 80%;" /></div>

<h3 id="33-模型变体">3.3 模型变体<a class="anchor-link" href="#33-模型变体" title="Permanent link">&para;</a></h3>
<p>方程 2 中的 <span class="math-inline">\text{Block}</span> 可以实例化为原始 ViT 中的任何块，例如多头自注意力块 <span class="math-inline">\text{Attn}</span>、多层感知器块 <span class="math-inline">\text{MLP}</span>，甚至是 ViT 中的完整transformer层。由于在适应微调期间跳过这些块中的令牌的影响尚不清楚，并且在以前的工作中没有被探索，我们提出了四种模型变体并进行实验以确定最佳实践。</p>
<ul>
<li>
<p><strong>注意力调度</strong>：考虑到 <span class="math-inline">\text{Attn}</span> 块相对于令牌数量的二次计算复杂度，跳过应用 <span class="math-inline">\text{Attn}</span> 之前的令牌可以显著减少计算。在这种设计中，多头自注意力仅在被激活的令牌之间执行，而其他令牌被绕过，这可能会损害令牌之间的交互。</p>
</li>
<li>
<p><strong>MLP 调度</strong>：基于第 3.2 节的分析，我们观察到 MLP 在 ViT-B/16 中占用了大约 63.5% 的 FLOPs，并提出仅在 MLP 之前跳过令牌。这使得令牌在 <span class="math-inline">\text{Attn}</span> 中的交互不受影响。</p>
</li>
<li>
<p><strong>注意力 -MLP 调度</strong>：另一种策略是在自注意力和 MLP 块之前跳过令牌。这种设计允许在 <span class="math-inline">\text{Attn}</span> 和 MLP 中都有更高的激活率，同时保持与“注意力调度”和“MLP 调度”相当的计算效率。然而，它在适配器中增加了双倍的额外参数。</p>
</li>
<li>
<p><strong>层调度</strong>：受“注意力 -MLP 调度”的启发，我们可以在transformer层之前调度令牌。具体来说，令牌被一个 TD 识别为被激活或停用在随后的整个层中。在相同的激活率下，其计算与“注意力 -MLP 调度”相似，同时需要较少的参数来构建适配器。</p>
</li>
</ul>
<p>我们在图 3 中展示了架构变体。这些变体的实验结果和分析在第 4.2 节中展示。</p>
<div align=center><img src="https://markdownimg-hw.oss-cn-beijing.aliyuncs.com/20241227212049.png" style="zoom: 80%;" /></div>

<h3 id="34-moe--适配器">3.4 MoE- 适配器<a class="anchor-link" href="#34-moe--适配器" title="Permanent link">&para;</a></h3>
<p>在 DyT 中，适配器负责处理所有令牌，需要有足够的能力，特别是当下游任务（例如语义分割）难以适应时。为了解决这个问题，我们提出了一个受混合专家（MoE）启发的 MoE- 适配器，它有效地增强了适配器的能力，同时引入的计算成本可以忽略不计。</p>
<p>MoE- 适配器包括一个路由层 <span class="math-inline">W_r \in \mathbb{R}^{C \times N}</span> 和 <span class="math-inline">N</span> 个适配器专家，表示为 <span class="math-inline">{W_{i,\text{down}} \in \mathbb{R}^{C \times d}, W_{i,\text{up}} \in \mathbb{R}^{d \times C}}_{i=1}^N</span>。路由层基于输入特征生成一系列标量作为专家的权重。不同图像的特征可能会产生不同的专家权重。具体来说，我们首先对所有令牌进行平均池化，以生成它们的全局表示。随后，这个表示被输入到路由层以生成权重标量 <span class="math-inline">{\alpha_1, \alpha_2, \ldots, \alpha_N}</span>。最后，令牌由每个专家独立处理，并与相应的权重结合。我们在图 4 中展示了这一点。</p>
<div align=center><img src="https://markdownimg-hw.oss-cn-beijing.aliyuncs.com/20241227201046.png" style="zoom: 80%;" /></div>

<p>然而，这会增加适配器的计算成本，与专家数量 <span class="math-inline">N</span> 成正比。为了解决这个问题，我们采用了它的数学等价性来处理 <span class="math-inline">X</span>，在实践中可以表示为：<br />
<div class="math-display"><br />
    X_{\text{adapt}} = \sigma(XW_{\text{moe,down}})W_{\text{moe,up}},<br />
</div><br />
其中 <span class="math-inline">W_{\text{moe,down}} = \sum_{i=1}^N \alpha_i W_{i,\text{down}}</span> 和 <span class="math-inline">W_{\text{moe,up}} = \sum_{i=1}^N \alpha_i W_{i,\text{up}}</span>。设计使 MoE- 适配器具有与 <span class="math-inline">N</span> 个单独适配器相同的容量，同时保持与单个适配器相当的计算效率（路由层的计算成本可以忽略不计）。</p>
<h3 id="35-损失函数">3.5 损失函数<a class="anchor-link" href="#35-损失函数" title="Permanent link">&para;</a></h3>
<p>对于图像 <span class="math-inline">I</span>，我们计算交叉熵损失 <span class="math-inline">L_{\text{cls}} = -y \log(\hat{y})</span>，以监督分类的学习。为了控制整个模型中的平均激活率 <span class="math-inline">r</span>，我们添加了一个损失项来限制动态调整中被激活令牌的数量，可以表示为：<span class="math-inline">L_{\text{rate}} = \left( \frac{1}{L \times N} \sum_{l=1}^L \sum_{n=1}^N M_{l,n} - r \right)^2</span>，其中 <span class="math-inline">L</span> 表示 ViT 中的层数，<span class="math-inline">M_{l,n}</span> 表示第 <span class="math-inline">l</span> 层中第 <span class="math-inline">n</span> 个令牌的掩码。此外，我们采用一个损失 <span class="math-inline">L'<em>{\text{cls}} = -y \log(y')</span> 来监督完整模型的适应，其中 <span class="math-inline">y'</span> 是未使用令牌调度器的输出概率。因此，这个完整的模型也可以作为教师来通过蒸馏损失 <span class="math-inline">L</em>{\text{distill}} = \text{KL}(y', y)</span> 增强动态调整期间的学习，其中 <span class="math-inline">\text{KL}</span> 表示 Kullback-Leibler 散度损失。因此，整体损失函数定义为 <span class="math-inline">L = L_{\text{cls}} + L'<em>{\text{cls}} + L</em>{\text{distill}} + \alpha L_{\text{rate}}</span>，其中 <span class="math-inline">\alpha</span> 作为激活率损失的权重，默认设置为 2.0。注意，DyT 也可以在没有蒸馏损失的情况下实现竞争性能（见附录 A.6）。</p>
<h2 id="4-实验">4. 实验<a class="anchor-link" href="#4-实验" title="Permanent link">&para;</a></h2>
<h3 id="41-实验设置">4.1 实验设置<a class="anchor-link" href="#41-实验设置" title="Permanent link">&para;</a></h3>
<p>为了评估适应性能，我们在 VTAB-1K[88] 基准测试上进行实验。这个基准测试中的训练数据极其有限，每个任务仅有 1,000 个训练样本。与主要关注 VTAB-1K 的现有 PEFT 工作 [12, 37, 38] 不同，我们还在三个完整的图像分类数据集上进行实验，包括 CIFAR-100[40]、SVHN[24] 和 Food-101[6]。此外，我们采用两个视频数据集，Kinetic-400 (K400)[10] 和 Something-Something V2 (SSv2)[25]，以评估当令牌数量增加时的性能。所有图像或帧都被调整为 224×224。对于密集预测任务，我们在两个广泛认可的语义分割数据集 ADE20K[92] 和 COCO-stuff[7] 上评估我们的方法。语义分割的结果在附录 A.4 中展示。我们在每个任务上运行三次，并报告平均结果。误差条很小（&lt;0.1），为简化起见省略。</p>
<h3 id="42-分析">4.2 分析<a class="anchor-link" href="#42-分析" title="Permanent link">&para;</a></h3>
<h4 id="模型变体">模型变体<a class="anchor-link" href="#模型变体" title="Permanent link">&para;</a></h4>
<p>在表 1 中，我们比较了四种模型变体在图像和视频数据集上的性能。我们将“注意力调度”和“MLP 调度”变体中的激活率 <span class="math-inline">r</span> 设置为 0.5，并将“注意力 -MLP 调度”和“层调度”变体中的 <span class="math-inline">r</span> 设置为 0.7，并分别训练每个变体。这导致四种变体的平均 FLOPs 相似。我们观察到默认设置“MLP 调度”在五个数据集上均实现了优越的性能，同时保持最低的计算成本。尽管“注意力 -MLP 调度”和“层调度”在 K400 上也表现出良好的性能，前者增加了双倍的额外参数，而后者在其他数据集上缺乏泛化能力。“MLP 调度”与其他变体的比较证明了仅在 MLP 块中跳过令牌是更好的设计。有关模型变体的更多调查可以在附录 A.3 中找到。</p>
<div align=center><img src="https://markdownimg-hw.oss-cn-beijing.aliyuncs.com/20241227212140.png" style="zoom: 80%;" /></div>

<h4 id="moe-适配器的有效性">MoE-适配器的有效性<a class="anchor-link" href="#moe-适配器的有效性" title="Permanent link">&para;</a></h4>
<p>我们进行了实验来探索 MoE- 适配器的有效性，结果如表 2 所示。MoE- 适配器设计确保 FLOPs 理论上将保持与普通适配器相同，路由功能的计算成本可以忽略不计。然而，在实际场景中，计算成本也受到 TD 中学习的令牌调度策略的影响，导致不同模型在表 2 中的 FLOPs 略有变化。</p>
<div align=center><img src="https://markdownimg-hw.oss-cn-beijing.aliyuncs.com/20241227212155.png" style="zoom: 80%;" /></div>

<p>我们观察到，当我们增加 MoE- 适配器中的专家数量时，图像数据集上的性能会下降。这一现象可以归因于图像数据集的简单性，模型不需要太多的参数来适应。相比之下，对于视频数据集，如 K400 和 SSv2，当有 4 个专家时实现了最佳准确性。其背后的原因是预训练数据集与视频数据集之间的领域差距较大，模型需要足够的适配器容量来学习适应。这证明了当目标数据集难以适应时，我们可以引入 MoE- 适配器。</p>
<h4 id="每层激活令牌的可视化">每层激活令牌的可视化<a class="anchor-link" href="#每层激活令牌的可视化" title="Permanent link">&para;</a></h4>
<p>在图 5 中，我们可视化了 ViT-B/16[20] 中不同层的令牌激活率。我们观察到模型倾向于在较低层激活更多的令牌，而在较高层停用令牌。这一现象可以归因于模型倾向于从预训练模型的较低层中获取更多通用知识，并在较高层中学习更多特定于任务的知识。此外，激活结果在不同数据集之间也有所不同。例如，SSv2 在第 5 层和第 6 层的令牌激活率比其他数据集高，而 SVHN 在第 6、7 和 8 层经历了大量的令牌停用。这种差异源于模型需要从预训练权重中获取不同的知识以应对数据集特定的挑战。</p>
<div align=center><img src="https://markdownimg-hw.oss-cn-beijing.aliyuncs.com/20241227212213.png" style="zoom: 80%;" /></div>

<p>值得注意的是，在五个数据集的最后层中几乎所有令牌都被停用了，特别是 CIFAR-100、SVHN 和 K400，其中激活率恰好为 0%。这表明在这些数据集上，我们可以直接丢弃第 11 层的原始 MLP 块而不会影响性能，这进一步减少了约 4.7M 个参数，占 ViT-B 总参数的 5.4%。</p>
<h4 id="激活令牌的可视化">激活令牌的可视化<a class="anchor-link" href="#激活令牌的可视化" title="Permanent link">&para;</a></h4>
<p>在图 6 中，我们从 K400 数据集中可视化了两个代表性样本。我们可以观察到模型倾向于停用那些信息量较少的令牌，例如 (a) 中的 sky 令牌和 (b) 中的 grass 令牌。在更高的层，如第 7 层和第 10 层，只有来自主要对象的令牌被激活。这进一步证明了 ViT 中存在令牌冗余问题，并为我们的方法提供了合理性验证。附录 A.11 中提供了额外的可视化。</p>
<div align=center><img src="https://markdownimg-hw.oss-cn-beijing.aliyuncs.com/20241227212232.png" style="zoom: 80%;" /></div>

<h3 id="43-vtab-1k-结果">4.3 VTAB-1K 结果<a class="anchor-link" href="#43-vtab-1k-结果" title="Permanent link">&para;</a></h3>
<h4 id="与-peft-方法的比较">与 PEFT 方法的比较<a class="anchor-link" href="#与-peft-方法的比较" title="Permanent link">&para;</a></h4>
<p>为了评估在训练数据有限时的适应性能，我们适应了 VTAB-1K[88] 基准测试，这是一个广泛使用的适应任务性能评估工具。按照现有工作，我们将瓶颈维度 <span class="math-inline">d</span> 减少到 8，导致仅有 0.16M 个额外参数。我们改变了 DyT 中的激活率 <span class="math-inline">r</span> 的范围 [0.5, 0.7, 0.9] 并进行了微调，获得了三个具有不同推理成本的模型。</p>
<p>结果如表 3 所示。尽管先前的方法，如 ConvPass[37] 和 ResTuning[36]，取得了令人满意的性能，但它们并没有提高推理期间的效率，甚至与全微调相比引入了额外的 FLOPs。相比之下，我们的方法仅以 12.54 GFLOPs 的成本，约为原始 ViT-B 的 71%，就超越了以前的方法，例如 LoRA[33] 和 VPT[35]，取得了较大的优势。值得注意的是，激活率 <span class="math-inline">r = 0.9</span> 的 DyT 模型并没有超过激活率 <span class="math-inline">r = 0.7</span> 的 DyT 模型。这一观察表明，适应后的transformer中存在计算冗余，这进一步验证了动态调整的重要性。这些实验结果验证了 DyT 在保持适应性能的同时，有效地提高了参数效率和推理效率。</p>
<h4 id="动态调整实现实际加速">动态调整实现实际加速<a class="anchor-link" href="#动态调整实现实际加速" title="Permanent link">&para;</a></h4>
<p>作为与硬件无关的指标，FLOPs 并不是评估不同平台上推理效率的最佳选择。以前的 PEFT 方法通常忽略了实际的推理速度。这里，我们采用了两种 GPU（Tesla V100 和 Tesla T4）和一种 CPU Xeon(R) Platinum 8163 来全面评估我们的方法和三种代表性 PEFT 方法的效率，包括 LoRA[33]、AdaptFormer[12] 和 VPT[35]。推理期间的批量大小分别设置为 512 和 32，分别用于 GPU 和 CPU。结果如表 4 所示，揭示了我们的方法在不同平台上与现有 PEFT 方法相比，在提高性能的同时有效地加速了推理速度。</p>
<hr />
<h3 id="44-进一步探索">4.4 进一步探索<a class="anchor-link" href="#44-进一步探索" title="Permanent link">&para;</a></h3>
<h4 id="在训练数据充足的图像数据集上的有效性">在训练数据充足的图像数据集上的有效性<a class="anchor-link" href="#在训练数据充足的图像数据集上的有效性" title="Permanent link">&para;</a></h4>
<p>尽管 VTAB-1K 基准测试的结果已经证明了我们方法的优越性，我们扩展了对完整图像数据集的调查，以评估在训练数据充足时的适应性能。我们在包括 CIFAR-100[40]、SVHN[24]、Food-101[6]、Air[55]、Pet[60] 和 Car[22] 在内的 6 个数据集上进行实验。我们进一步探索了一种直接方法“Dynamic-Full”，它具有与 DyT 相同的令牌调度器，并在全参数微调中使用。我们观察到在一些数据集上，例如 CIFAR-100 和 Food-101，其性能变得不稳定并显著下降。这种现象可能是由于动态调度在全参数微调适应期间对预训练参数的潜在不利影响，从而验证了 DyT 的重要性。在数据充足的场景中，尽管我们的方法在性能上略低于全微调和 AdaptFormer，但它显著减少了 FLOPs。</p>
<h4 id="从图像到视频的令牌数量扩展">从图像到视频的令牌数量扩展<a class="anchor-link" href="#从图像到视频的令牌数量扩展" title="Permanent link">&para;</a></h4>
<p>我们在视频数据集上进行实验，以展示当令牌数量增加时的性能。输入帧的数量设置为 8。对于视频任务，类似于 [84, 13]，我们采用了交叉注意力层和查询令牌来聚合不同帧的特征。视频分类是基于查询令牌进行的。附录 A.8 提供了更多的实现细节。我们在表 6 中展示了结果。尽管 DyT 在性能上略低于 AdaptFormer 和 LoRA，但它明显减少了 FLOPs。包含四个专家的 DyT†以仅 12.29 GFLOPs 的成本实现了最佳平均准确率，进一步验证了我们设计的优势。</p>
<h3 id="45-vtab-1k-结果">4.5 VTAB-1K 结果<a class="anchor-link" href="#45-vtab-1k-结果" title="Permanent link">&para;</a></h3>
<h4 id="与高效transformer方法的比较和兼容性">与高效transformer方法的比较和兼容性<a class="anchor-link" href="#与高效transformer方法的比较和兼容性" title="Permanent link">&para;</a></h4>
<p>我们首先调查了两个代表性方法 DynamicViT[66] 和 EViT[47] 的领域适应性能。这些方法被设计为高效的ViT。我们采用了他们原始论文中概述的最佳配置，并在 VTAB-1K[88] 基准测试上进行实验。结果，如表 5 所示，揭示了这两种方法实现了高吞吐量，例如&gt;1000（img/s），但性能并不令人满意。将 DynamicViT 和 EViT 与 AdaptFormer[12] 结合使用，可以提高性能，验证了探索参数和推理效率对于ViT的重要性。尽管取得了这些增益，DyT 明显超越了它们，突出了我们方法的优越性。</p>
<p>然后，我们探索了我们方法与令牌修剪方法的兼容性。具体来说，我们将 DyT 与 ToMe[5] 结合，这是一种无需训练的技术，通过令牌合并逐步修剪令牌。从表 5 中的结果来看，ToMe 可以进一步增强 DyT 的吞吐量，同时保持准确性。这证明了我们的方法可以与现有的令牌修剪方法 [5, 11, 47] 结合使用的潜力。此外，我们将 ToMe 应用于全微调和 AdaptFormer[12]，如表 3 所示，观察到次优的准确性和吞吐量。这些发现突出了直接在微调或参数高效微调后应用 ToMe 的效果不如提出的方法。</p>
<h4 id="在图像数据集上的有效性">在图像数据集上的有效性<a class="anchor-link" href="#在图像数据集上的有效性" title="Permanent link">&para;</a></h4>
<p>尽管 VTAB-1K 基准测试的结果已经证明了我们方法的优越性，我们扩展了对完整图像数据集的调查，以评估在训练数据充足时的适应性能。我们在包括 CIFAR-100[40]、SVHN[24]、Food-101[6]、Air[55]、Pet[60] 和 Car[22] 在内的 6 个数据集上进行实验。我们进一步探索了一种直接方法“Dynamic-Full”，它具有与 DyT 相同的令牌调度器，并在全参数微调中使用。我们观察到在一些数据集上，例如 CIFAR-100 和 Food-101，其性能变得不稳定并显著下降。这种现象可能是由于动态调度在全参数微调适应期间对预训练参数的潜在不利影响，从而验证了 DyT 的重要性。在数据充足的场景中，尽管我们的方法在性能上略低于全微调和 AdaptFormer，但它显著减少了 FLOPs。</p>
<h4 id="从图像到视频的令牌数量扩展_1">从图像到视频的令牌数量扩展<a class="anchor-link" href="#从图像到视频的令牌数量扩展_1" title="Permanent link">&para;</a></h4>
<p>我们在视频数据集上进行实验，以展示当令牌数量增加时的性能。输入帧的数量设置为 8。对于视频任务，类似于 [84, 13]，我们采用了交叉注意力层和查询令牌来聚合不同帧的特征。视频分类是基于查询令牌进行的。我们在表 6 中展示了结果。尽管 DyT 在性能上略低于 AdaptFormer 和 LoRA，但它明显减少了 FLOPs。包含四个专家的 DyT†以仅 12.29 GFLOPs 的成本实现了最佳平均准确率，进一步验证了我们设计的优势。</p>
<h2 id="5-讨论和结论">5. 讨论和结论<a class="anchor-link" href="#5-讨论和结论" title="Permanent link">&para;</a></h2>
<p>针对 ViT 适应的先前方法主要关注提高适应期间的效率，从而减少额外参数。然而，随着 ViT 模型的大小和计算成本的增加，适应后的推理成本正成为一个沉重的负担。在本文中，我们将这两个问题统一为 ViT 适应的效率问题，并提出了动态调整（DyT）来同时解决它们。我们在多种任务和数据集上验证了它的性能和泛化能力。</p>
<hr />
<h2 id="a-附录">A. 附录<a class="anchor-link" href="#a-附录" title="Permanent link">&para;</a></h2>
<p>我们组织我们的附录如下。</p>
<ul>
<li>在第 A.1 节中，我们列出了一些常见问题及其相应的答案。</li>
<li>在第 A.2 节中，我们详细说明了我们的方法与其他先前工作的区别。</li>
<li>在第 A.3 节中，我们对提出的方法进行了更多的分析。</li>
<li>在第 A.4 节中，我们报告了在语义分割数据集上的结果。</li>
<li>在第 A.5 节中，我们报告了在目标检测和实例分割上的性能。</li>
<li>在第 A.6 节中，我们验证了完整模型和蒸馏在适应期间的有效性。</li>
<li>在第 A.7 节中，我们提供了有关 Gumbel-Sigmoid 机制的详细信息和正式证明。</li>
<li>在第 A.8 节中，我们为每个实验提供了实现细节。</li>
<li>在第 A.9 节中，我们展示了我们方法与 Swin Transformer[52] 的泛化能力。</li>
<li>在第 A.10 节中，我们研究了将模型大小扩展到 ViT-L[20] 时的影响。</li>
<li>在第 A.11 节中，我们提供了我们方法中激活令牌的额外可视化。</li>
</ul>
<h3 id="a1-常见问题">A.1 常见问题<a class="anchor-link" href="#a1-常见问题" title="Permanent link">&para;</a></h3>
<p>为什么提出的方法优于传统适配器？我们列出了以下解释：</p>
<ul>
<li>DyT 中的动态架构增强了泛化能力。它引入了一种类似于 Dropout[69] 的输入数据干扰机制，这在训练数据有限时（例如 VTAB-1K）尤为重要。</li>
<li>DyT 中的蒸馏损失。我们采用完整模型作为动态模型的老师，显著提高了性能。这种自蒸馏机制仅在动态架构中可用。</li>
<li>先前的工作 [29] 和 DynamicViT 也表明，动态架构在更少的 FLOPs 下优于静态模型。</li>
</ul>
<p>为什么表 6 显示使用 MoE- 适配器会导致更少的 FLOPs？我们列出了以下解释：</p>
<ul>
<li>DyT 的 FLOPs 取决于微调期间学习的令牌调度器，可能会在目标 FLOPs（由 Lrate 控制）周围略有波动。</li>
<li>适配器和 MoE 适配器的额外计算成本几乎相等。<br />
因此，具有 MoE- 适配器的 DyT 模型可能在学习的令牌调度器中激活较少的令牌，导致 FLOPs 略有减少。</li>
</ul>
<p>为什么表 2 中 N = 12 的 FLOPs 悖论性地低于 N = 8？理论上，任何数量专家的 MoE- 适配器应与标准适配器具有相似的 FLOPs。同时，DyT 在推理期间的实际激活率取决于微调后学习的令牌调度器，导致不同模型之间的 FLOPs 略有波动。这些解释了为什么 DyT N = 12 的 FLOPs 可能略低于 DyT N = 8。</p>
<h3 id="a2-与先前工作的区别">A.2 与先前工作的区别<a class="anchor-link" href="#a2-与先前工作的区别" title="Permanent link">&para;</a></h3>
<p>我们比较了 DyT 与更多先前工作的区别，并展示了我们的方法与这些方法之间的区别。</p>
<ul>
<li>
<p>与 DynamicViT 和 EViT 的区别：DynamicViT[66] 和 EViT[47] 都是令牌修剪方法，而 DyT 是令牌跳过方法。DynamicViT 在 ViT-B 的某些层（例如第 3 层、第 6 层、第 9 层）学习保留 P% 的令牌。EViT 仅保留 ViT-B 的某些层（例如第 4 层、第 7 层和第 10 层）的顶部 K 个注意力令牌，并将不关注的令牌融合。这些方法主要侧重于加速同一数据集上预训练后使用的模型，而 DyT 旨在提高跨域适应期间的效率。</p>
</li>
<li>
<p>与 DiffRate 的区别：DiffRate[11] 是一种同时执行令牌修剪和合并的令牌压缩方法。</p>
</li>
<li>
<p>在 DiffRate[11] 中，令牌修剪和合并本质上是数据独立的。训练后，transformer层在所有输入数据中修剪或合并相同数量的令牌。相比之下，DyT 是一种数据依赖方法。DyT 中的路由器学习基于输入数据在每个 MLP 块之前跳过不同数量的令牌。</p>
</li>
<li>
<p>DiffRate 中的修剪和合并操作不保留完整的特征图，这对于密集预测任务来说是一个挑战。因此，DiffRate 需要修改以解决这些任务。相反，仅执行令牌跳过的 DyT 保持了完整的特征图，允许它有效地处理密集预测任务而无需任何修改。</p>
</li>
<li>
<p>与 ToMe 的区别：ToMe[5] 是一种无需训练的技术，通过在每层基于相似性合并令牌来提高推理效率。DyT 采用令牌跳过而不是合并，并且可以与 ToMe 无缝集成以进一步提高效率。</p>
</li>
<li>
<p>与 CoDA 的区别：CoDA[41] 也是一种 PEFT 方法，可以提高推理效率。</p>
</li>
<li>
<p>令牌选择策略在令牌调度器中有所不同。CoDA 在每层选择顶部 K 个令牌通过，而 DyT 采用可学习的调度器为每个输入选择适当数量的令牌。</p>
</li>
<li>
<p>目标模型不同。尽管 CoDA[41] 也旨在改善适应期间的参数和推理，但 CoDA 主要关注语言模型（例如 T5[65]），而 DyT 专门设计用于ViT。</p>
</li>
<li>
<p>进行令牌跳过的块不同。在 CoDA 中，令牌直接跳过整个层。在 DyT 中，我们提出了四种模型变体，探索了它们的有效性，并发现跳过 MLP 块最适合ViT。</p>
</li>
<li>
<p>与 AdaMix 的区别：AdaMix[72] 也利用了混合适配器，但在训练后通过权重平均融合所有专家，结果形成了类似于 AdaptFormer[12] 的标准适配器。相比之下，提出的 MoE- 适配器采用基于学习路由器，根据输入特征为专家生成标量权重，允许不同图像的特征产生不同的专家权重。</p>
</li>
</ul>
<h3 id="a3-更多分析">A.3 更多分析<a class="anchor-link" href="#a3-更多分析" title="Permanent link">&para;</a></h3>
<h4 id="a31-调度级别和调度策略的调查">A.3.1 调度级别和调度策略的调查<a class="anchor-link" href="#a31-调度级别和调度策略的调查" title="Permanent link">&para;</a></h4>
<p>提出的 DyT 在令牌级别上执行动态调度，使用令牌调度器（TD）。除了令牌级别调度外，我们还调查了样本级别调度，其中选定样本内的所有令牌被激活，而其他样本的所有令牌被停用。为了验证 TD 的重要性，我们将其与随机调度进行比较，随机调度在微调和推理期间随机激活令牌或样本。实验结果如表 7 所示。</p>
<p>我们的观察发现，使用 TD 的令牌级别调度在所有数据集上一致地实现了优越的性能，除了在 SVHN 数据集上与样本级别调度相比略有下降。值得注意的是，TD 在令牌级别和样本级别调度上都比随机调度策略实现了更好的性能，特别是在视频数据集 K400 和 SSv2 上，从而验证了 TD 中学到的调度策略。此外，令牌级别调度在大多数数据集上显著优于样本级别调度，这证明了更细粒度激活的重要性。<br />
<div class="math-display"><br />
    \begin{array}{c|c|c|c|c|c}<br />
    \text{调度级别} &amp; \text{调度策略} &amp; \text{图像准确率} &amp; \text{视频准确率} \<br />
    \hline<br />
    \text{令牌} &amp; \text{样本} &amp; \text{TD} &amp; \text{随机} \<br />
    \hline<br />
    \text{CIFAR-100} &amp; \text{SVHN} &amp; \text{Food-101} &amp; \text{K400} &amp; \text{SSv2} \<br />
    \end{array}<br />
</div></p>
<h4 id="a32-模型变体的-flops--准确率曲线">A.3.2 模型变体的 FLOPs- 准确率曲线<a class="anchor-link" href="#a32-模型变体的-flops--准确率曲线" title="Permanent link">&para;</a></h4>
<p>在图 7 中，我们进一步可视化了四种模型变体的 FLOPs- 准确率曲线。我们通过改变微调阶段的激活率 <span class="math-inline">r</span> 来控制 FLOPs。对于“注意力调度”和“MLP 调度”，我们在范围 [0.1, 0.3, 0.5, 0.7, 0.9] 内探索激活率。为了保持与“注意力调度”和“MLP 调度”相似的 FLOPs，我们调整“注意力 -MLP 调度”和“层调度”模型的激活率在范围 [0.5, 0.6, 0.7, 0.8, 0.9] 内。在所有数据集上，“MLP 调度”一致地优于其他变体。“注意力调度”的性能在激活率低于 0.9 时显著下降，这也表明跳过 ViT 中自注意力块的令牌不是合适的方法，因为自注意力的令牌混合功能很重要。值得注意的是，“MLP 调度”可以在 CIFAR-100 和 Food-101 上以明显更少的 FLOPs 超越全微调，进一步验证了我们方法的有效性。<br />
<div class="math-display"><br />
    \begin{array}{c|c|c|c|c}<br />
    \text{FLOPs (G)} &amp; 9 &amp; 10 &amp; 11 &amp; 12 &amp; 13 &amp; 14 &amp; 15 &amp; 16 &amp; 17 \<br />
    \hline<br />
    \text{准确率 (%)} &amp; 84 &amp; 86 &amp; 88 &amp; 90 &amp; 92 &amp; 94 &amp; 96 &amp; 98 &amp; 100 \<br />
    \end{array}<br />
</div></p>
<h4 id="a33-不同的瓶颈维度">A.3.3 不同的瓶颈维度<a class="anchor-link" href="#a33-不同的瓶颈维度" title="Permanent link">&para;</a></h4>
<p>我们研究了 DyT 中适配器的瓶颈维度的影响，结果总结在表 8 中，揭示了不同数据集偏好不同的配置。当数据集易于适应时，例如 CIFAR-100，瓶颈维度 <span class="math-inline">d = 4</span> 就足以实现令人满意的性能。相反，视频数据集需要更大的适配器尺寸，例如 <span class="math-inline">d = 256</span>，以获得更好的性能。我们将默认瓶颈维度设置为 64，它在性能和成本（例如额外参数和 FLOPs）之间取得了平衡。值得注意的是，FLOPs 与瓶颈维度之间的关系并不严格单调，因为令牌调度器的存在。例如，当 <span class="math-inline">d = 16</span> 时，FLOPs 低于 <span class="math-inline">d = 1</span>，因为训练可能在适配器参数数量增加时收敛于激活较少的令牌。<br />
<div class="math-display"><br />
    \begin{array}{c|c|c|c|c|c}<br />
    \text{维度} &amp; \text{参数} &amp; \text{FLOPs} &amp; \text{图像准确率} &amp; \text{视频准确率} \<br />
    \hline<br />
    \text{CIFAR-100} &amp; \text{SVHN} &amp; \text{Food-101} &amp; \text{K400} &amp; \text{SSv2} \<br />
    \end{array}<br />
</div></p>
<h4 id="a34-温度的调查">A.3.4 温度的调查<a class="anchor-link" href="#a34-温度的调查" title="Permanent link">&para;</a></h4>
<p>我们探索了提出的动态调整中的温度 <span class="math-inline">\tau</span>。结果如表 9 所示。当温度较小，例如 0.1 时，Gumbel Sigmoid 倾向于产生接近 0 或 1 的二进制输出。相反，较大的温度导致更均匀的输出，接近 0.5。结果表明，性能对温度不太敏感，我们的模型可以在表中所有温度下实现合理的性能。我们还观察到，<span class="math-inline">\tau = 1</span> 的模型在 CIFAR-100、SVHN 和 SSv2 上实现了最佳性能，而在 Food-101 上降低温度计划实现了最佳结果，表明调整温度可以帮助模型实现更好的性能。由于确定最佳温度不是本文的主要焦点，我们直接将温度设置为 5 作为默认值。<br />
<div class="math-display"><br />
    \begin{array}{c|c|c|c|c|c}<br />
    \text{温度} &amp; \text{CIFAR-100} &amp; \text{SVHN} &amp; \text{Food-101} &amp; \text{K400} &amp; \text{SSv2} \<br />
    \hline<br />
    0.1 &amp; 90.91 &amp; 96.24 &amp; 89.72 &amp; 73.16 &amp; 44.84 \<br />
    1 &amp; 91.61 &amp; 97.20 &amp; 90.08 &amp; 74.38 &amp; 45.69 \<br />
    5 &amp; 91.37 &amp; 97.08 &amp; 90.32 &amp; 75.28 &amp; 45.43 \<br />
    \text{计划} &amp; 91.58 &amp; 97.13 &amp; 90.39 &amp; 74.57 &amp; 45.51 \<br />
    \end{array}<br />
</div></p>
<h3 id="a4-语义分割中的泛化能力">A.4 语义分割中的泛化能力<a class="anchor-link" href="#a4-语义分割中的泛化能力" title="Permanent link">&para;</a></h3>
<p>我们还在两个公认的语义分割数据集 ADE20K[92] 和 COCO-stuff[7] 上进行实验，以展示 DyT 在密集预测任务上的能力。结果如表 10 所示。按照先前的工作 [3, 19]，我们采用了 UperNet[77] 作为分割头，所有图像都被调整为 512×512。我们观察到，与图像和视频分类任务相比，语义分割的计算成本要高得多，主要是由于高分辨率的特征图。DyT 和 DyT†仍然可以显著减少计算成本，并在 COCO-Stuff 数据集上实现了比其他 PEFT 方法更好的性能，仅略低于全微调。<br />
<div class="math-display"><br />
    \begin{array}{c|c|c|c}<br />
    \text{方法} &amp; \text{参数} &amp; \text{FLOPs} &amp; \text{mIOU} \<br />
    \hline<br />
    \text{ADE20K} &amp; \text{COCO-stuff} &amp; \text{平均值} \<br />
    \end{array}<br />
</div></p>
<h3 id="a5-目标检测和实例分割中的泛化能力">A.5 目标检测和实例分割中的泛化能力<a class="anchor-link" href="#a5-目标检测和实例分割中的泛化能力" title="Permanent link">&para;</a></h3>
<p>我们在 COCO[48] 上进行实验，探索我们方法在目标检测和实例分割中的泛化能力。我们采用 ViTDet[43] 作为检测器，并在 COCO 数据集上对其进行了 12 个周期的微调。适配器中的瓶颈维度 <span class="math-inline">d</span> 设置为 128。如表 11 所示，DyT 在参数数量上优于 AdapterFormer[12]，并且 FLOPs 更少。我们的 MoE 适配器进一步提高了 DyT 的性能，而没有额外的计算成本，验证了我们设计的有效性。</p>
<p>然而，全微调实现了最佳性能，显著超过了其他方法。这可能是由于边界框回归和ViT的预训练之间的差距，需要在背景中更新更多的参数。这一挑战激励我们设计更强大的 PEFT 方法，并将其与 DyT 集成，以减少与全微调的性能差距。<br />
<div class="math-display"><br />
    \begin{array}{c|c|c|c|c}<br />
    \text{方法} &amp; \text{参数} &amp; \text{FLOPs} &amp; \text{BBox mAP} &amp; \text{Seg mAP} \<br />
    \hline<br />
    \text{COCO 数据集} \<br />
    \end{array}<br />
</div></p>
<h3 id="a6-完整模型和蒸馏的有效性">A.6 完整模型和蒸馏的有效性<a class="anchor-link" href="#a6-完整模型和蒸馏的有效性" title="Permanent link">&para;</a></h3>
<p>在主要论文中，我们采用了完整模型作为我们的老师，该模型不使用令牌调度器跳过令牌。我们提出的动态调整允许模型在适应期间充当自己的老师，这是其他 PEFT 方法无法实现的能力。我们认为这是我们方法的一个重要优势。动态和完整模型的联合训练减轻了适应期间的过拟合，特别是在训练数据有限的情况下，例如 VTAB-1K。此外，完整模型作为老师，增强了动态模型的学习。这些因素共同促成了 DyT 的优越性能。实验结果在表 12 中表明，完整模型损失和蒸馏损失对提高 DyT 的性能都是有用的。我们也注意到，在训练中引入完整模型会导致 1.8 倍的更长训练时间。鉴于我们的主要贡献集中在提高参数和推理效率上，由完整模型引入的额外训练时间是可以接受的。</p>
<p>在表 13 中，我们进一步详细报告了所有数据集上的结果。我们可以发现，没有 <span class="math-inline">L'<em>{\text{cls}} + L</em>{\text{distill}}</span> 的 DyT 仍然可以超越大多数先前的 PEFT 方法，进一步验证了我们方法的优越性。<br />
<div class="math-display"><br />
    \begin{array}{c|c|c|c|c|c|c|c|c|c|c}<br />
    \text{方法} &amp; \text{VTAB-1K} &amp; \text{训练时间} &amp; \text{准确率} &amp; \text{CIFAR-100} &amp; \text{Caltech101} &amp; \text{DTD} &amp; \text{Flowers102} &amp; \text{Pets} &amp; \text{SVHN} \<br />
    \hline<br />
    \text{DyT} &amp; 77.14 &amp; 1.8 \times &amp; &amp; &amp; &amp; &amp; &amp; &amp; \<br />
    \text{DyT w/o Ldistill} &amp; 76.70 &amp; 1.8 \times &amp; &amp; &amp; &amp; &amp; &amp; &amp; \<br />
    \text{DyT w/o L'_{cls} + Ldistill} &amp; 75.73 &amp; 1.0 \times &amp; &amp; &amp; &amp; &amp; &amp; &amp; \<br />
    \end{array}<br />
</div></p>
<h3 id="a7-gumbel-sigmoid-的详细信息">A.7 Gumbel-Sigmoid 的详细信息<a class="anchor-link" href="#a7-gumbel-sigmoid-的详细信息" title="Permanent link">&para;</a></h3>
<p>Gumbel-Softmax 被提出用于从分布中进行可微分采样。给定一个未归一化的对数概率 <span class="math-inline">{E_i}^N_{i=1}</span>，Gumbel-Softmax 可以表示为：<br />
<div class="math-display"><br />
    p_i = \frac{\exp((E_i + G_i) / \tau)}{\sum_{n=1}^N \exp((E_n + G_n) / \tau)},<br />
</div><br />
其中 <span class="math-inline">G_i</span> 表示从 Gumbel 分布中采样的 Gumbel 噪声（<span class="math-inline">G_i \sim \text{Gumbel}(0, 1)</span>）。我们可以考虑一个特殊情况，其中 <span class="math-inline">N = 2</span> 且 <span class="math-inline">E_2 = 0</span>，则 <span class="math-inline">p_1</span> 可以定义为：<br />
<div class="math-display"><br />
    p_1 = \frac{\exp(E_1 + G_1) / \tau)}{\exp(E_1 + G_1) / \tau) + \exp(G_2 / \tau)},<br />
</div></p>
<p><div class="math-display"><br />
    p_1 = \frac{1}{1 + \exp(-(E_1 + G_1 - G_2) / \tau)},<br />
</div></p>
<p><div class="math-display"><br />
    p_1 = \text{Sigmoid}(E_1 + G_1 - G_2 / \tau),<br />
</div></p>
<p><div class="math-display"><br />
    p_1 = \text{Gumbel-Sigmoid}(E_1).<br />
</div><br />
先前的工作，例如 [23, 50]，也利用了 Gumbel-Sigmoid 公式来促进神经网络的端到端训练。</p>
<h3 id="a8-实现细节">A.8 实现细节<a class="anchor-link" href="#a8-实现细节" title="Permanent link">&para;</a></h3>
<h4 id="a81-vtab-1k-的实验设置">A.8.1 VTAB-1K 的实验设置<a class="anchor-link" href="#a81-vtab-1k-的实验设置" title="Permanent link">&para;</a></h4>
<p>按照先前的工作 [37, 38, 36]，我们在 VTAB-1K[88] 的每个数据集上微调模型 100 个周期。这些实验中我们没有使用任何数据增强策略。我们采用了 AdamW[54] 优化器。学习率设置为 1e-3，并根据余弦调度 [53] 逐渐衰减至 0。</p>
<h4 id="a82-完整图像数据集的实验设置">A.8.2 完整图像数据集的实验设置<a class="anchor-link" href="#a82-完整图像数据集的实验设置" title="Permanent link">&para;</a></h4>
<p>我们采用表 14 中的设置来微调提出的动态调整 ViT。其他参数效率方法，如 AdaptFormer[12]、LoRA[33] 和 VPT[35] 的实验也遵循表 14 中的设置。当我们训练全微调模型时，我们采用 1/10 的基础学习率以确保训练稳定，否则模型无法获得合理的结果。<br />
<div class="math-display"><br />
    \begin{array}{c|c|c|c|c|c|c}<br />
    \text{配置} &amp; \text{优化器} &amp; \text{基础学习率} &amp; \text{权重衰减} &amp; \text{批量大小} &amp; \text{训练裁剪大小} &amp; \text{学习率计划} \<br />
    \hline<br />
    \text{AdamW} &amp; 1e-3 &amp; 0.01 &amp; 1024 &amp; 224 &amp; \text{余弦衰减} \<br />
    \end{array}<br />
</div></p>
<h4 id="a83-视频数据集的实验设置">A.8.3 视频数据集的实验设置<a class="anchor-link" href="#a83-视频数据集的实验设置" title="Permanent link">&para;</a></h4>
<p>我们采用了两个视频数据集，Kinetic-400 (K400)[10] 和 Something-Something V2 (SSv2)[25]，以评估当令牌数量增加时的性能。实验设置如表 15 所示。大多数设置都是从 [59] 中借鉴来的。输入帧数设置为 8。我们采用了多视图测试，这是视频动作识别中的常见做法。然而，原始的 ViT 缺乏时序建模能力。为了解决这个限制，我们从 [84, 13] 中获得灵感。通过在 ViT 后引入交叉注意力层和查询令牌，我们有效地聚合了不同帧之间的时间信息。最终的视频动作分类是基于这个查询令牌进行的。参数效率微调方法的实验也遵循这些设置。我们在全微调实验中采用了 1/10 的基础学习率。<br />
<div class="math-display"><br />
    \begin{array}{c|c|c|c|c|c|c|c}<br />
    \text{配置} &amp; \text{K400} &amp; \text{SSV2} &amp; \text{优化器} &amp; \text{基础学习率} &amp; \text{权重衰减} &amp; \text{批量大小} &amp; \text{训练周期} \<br />
    \hline<br />
    \text{AdamW} &amp; 1e-3 &amp; 1e-3 &amp; 0.01 &amp; 128 &amp; 12 &amp; 50 \<br />
    \end{array}<br />
</div></p>
<h4 id="a84-语义分割数据集的实验设置">A.8.4 语义分割数据集的实验设置<a class="anchor-link" href="#a84-语义分割数据集的实验设置" title="Permanent link">&para;</a></h4>
<p>我们在 ADE20K[92] 和 COCO-stuff[7] 上进行实验，以展示 DyT 在密集预测任务上的能力。ADE20K 包含 20,210 张来自 150 个细粒度类别的图像。COCO-Stuff 由约 164k 张图像组成，有 172 个语义类别。实验设置如表 16 所示。所有参数效率微调方法的实验也遵循这些设置。对于全微调实验，我们设置了 1/10 的学习率，以实现稳定的训练和更好的性能。<br />
<div class="math-display"><br />
    \begin{array}{c|c|c|c|c|c}<br />
    \text{配置} &amp; \text{ADE20K} &amp; \text{COCO-stuff} &amp; \text{优化器} &amp; \text{学习率} &amp; \text{权重衰减} \<br />
    \hline<br />
    \text{AdamW} &amp; 1e-3 &amp; 1e-3 &amp; 0.05 &amp; 16 &amp; 512 \<br />
    \end{array}<br />
</div></p>
<h3 id="a9-transformer架构的泛化能力">A.9 transformer架构的泛化能力<a class="anchor-link" href="#a9-transformer架构的泛化能力" title="Permanent link">&para;</a></h3>
<p>为了验证所提出的动态调整的泛化能力，我们在 Swin-B[52] 上进行实验。动态调整可以直接应用于 Swin transformer的 MLP 块，无需任何修改。动态调整中适配器的瓶颈维度 <span class="math-inline">d</span> 也设置为 64。结果如表 17 所示。我们可以观察到，动态调整可以减少可调参数和 FLOPs，同时在三个数据集上实现相当甚至更好的性能。这验证了动态调整的泛化能力。<br />
<div class="math-display"><br />
    \begin{array}{c|c|c|c|c}<br />
    \text{方法} &amp; \text{参数} &amp; \text{FLOPs} &amp; \text{图像准确率} &amp; \<br />
    \hline<br />
    \text{CIFAR-100} &amp; \text{SVHN} &amp; \text{Food-101} &amp; \<br />
    \end{array}<br />
</div></p>
<h3 id="a10-模型尺寸的扩展">A.10 模型尺寸的扩展<a class="anchor-link" href="#a10-模型尺寸的扩展" title="Permanent link">&para;</a></h3>
<p>我们验证了当模型尺寸扩展时动态调整的有效性。我们在 ViT-L[20] 上进行实验，并与全微调进行比较。动态调整中适配器的瓶颈维度 <span class="math-inline">d</span> 也设置为 64。结果如表 18 所示。我们可以观察到，当激活率设置为 0.3 时，DyT 在 CIFAR-100 和 Food-101 上明显超越了“全微调”，同时显著降低了计算成本。</p>
<p>我们进一步在 VTAB-1K 基准测试 [88] 上比较了所提出的动态调整与全微调。结果如表 19 所示。仅用 0.44M 可训练参数和 43.52 GFLOPs，动态调整在大多数数据集上超越了全微调，并实现了更好的平均性能。<br />
<div class="math-display"><br />
    \begin{array}{c|c|c|c|c|c|c|c|c|c|c|c}<br />
    \text{方法} &amp; \text{参数} &amp; \text{FLOPs} &amp; \text{CIFAR-100} &amp; \text{Caltech101} &amp; \text{DTD} &amp; \text{Flowers102} &amp; \text{Pets} &amp; \text{SVHN} &amp; \text{Sun397} &amp; \text{Camelyon} &amp; \text{EuroSAT} &amp; \text{Resisc45} &amp; \text{Retinopathy} &amp; \text{Clevr-Count} &amp; \text{Clevr-Dist} &amp; \text{DMLab} &amp; \text{KITTI-Dist} &amp; \text{dSpr-Loc} &amp; \text{dSpr-Ori} &amp; \text{sNORB-Azim} &amp; \text{sNORB-Elev} &amp; \text{Group Mean} \<br />
    \hline<br />
    \text{Full tuning} &amp; 303.3 &amp; 61.60 &amp; 69.5 &amp; 96.2 &amp; 73.8 &amp; 98.8 &amp; 90.7 &amp; 91.6 &amp; 44.8 &amp; 85.8 &amp; 96.2 &amp; 87.8 &amp; 75.3 &amp; 83.0 &amp; 62.0 &amp; 50.8 &amp; 80.0 &amp; 85.8 &amp; 54.6 &amp; 29.7 &amp; 35.4 &amp; 75.7 \<br />
    \text{DyT r = 0.5} &amp; 0.44 &amp; 43.52 &amp; 79.1 &amp; 95.6 &amp; 74.5 &amp; 99.5 &amp; 92.6 &amp; 90.8 &amp; 59.3 &amp; 86.9 &amp; 96.6 &amp; 87.2 &amp; 76.5 &amp; 84.5 &amp; 62.9 &amp; 53.3 &amp; 83.5 &amp; 88.4 &amp; 57.3 &amp; 38.7 &amp; 44.6 &amp; 78.5 \<br />
    \end{array}<br />
</div></p>
<h3 id="a11-激活令牌的额外可视化">A.11 激活令牌的额外可视化<a class="anchor-link" href="#a11-激活令牌的额外可视化" title="Permanent link">&para;</a></h3>
<p>我们在图 8 和图 9 中分别提供了来自 K400[10] 和 SSv2[25] 样本的激活令牌的额外可视化。结果表明，较高层（例如第 10 层）中的大多数激活令牌来自主要对象。这证明了所提出的令牌调度器在微调期间学会了激活信息丰富的令牌。</p>
                </div>

                <!-- Comments Section (Giscus) -->
                <section class="comments-section">
                    <h3><i class="fas fa-comments"></i> 评论</h3>
                    <script src="https://giscus.app/client.js"
                        data-repo="Geeks-Z/Geeks-Z.github.io"
                        data-repo-id=""
                        data-category="Announcements"
                        data-category-id=""
                        data-mapping="pathname"
                        data-strict="0"
                        data-reactions-enabled="1"
                        data-emit-metadata="0"
                        data-input-position="bottom"
                        data-theme="preferred_color_scheme"
                        data-lang="zh-CN"
                        crossorigin="anonymous"
                        async>
                    </script>
                </section>
            </article>

            <footer class="post-footer">
                <p>© 2025 Hongwei Zhao. Built with ❤️</p>
            </footer>
        </main>
    </div>

    <!-- Theme Toggle Button -->
    <button class="theme-toggle" id="themeToggle" aria-label="切换主题">
        <i class="fas fa-moon"></i>
    </button>

    <script>
        // Theme Toggle
        const themeToggle = document.getElementById('themeToggle');
        const html = document.documentElement;
        const icon = themeToggle.querySelector('i');
        const hljsDark = document.getElementById('hljs-theme-dark');
        const hljsLight = document.getElementById('hljs-theme-light');
        
        // Check saved theme or system preference
        const savedTheme = localStorage.getItem('theme');
        const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
        
        if (savedTheme === 'dark' || (!savedTheme && prefersDark)) {
            html.setAttribute('data-theme', 'dark');
            icon.className = 'fas fa-sun';
            hljsDark.disabled = false;
            hljsLight.disabled = true;
        }
        
        themeToggle.addEventListener('click', () => {
            const isDark = html.getAttribute('data-theme') === 'dark';
            if (isDark) {
                html.removeAttribute('data-theme');
                icon.className = 'fas fa-moon';
                localStorage.setItem('theme', 'light');
                hljsDark.disabled = true;
                hljsLight.disabled = false;
            } else {
                html.setAttribute('data-theme', 'dark');
                icon.className = 'fas fa-sun';
                localStorage.setItem('theme', 'dark');
                hljsDark.disabled = false;
                hljsLight.disabled = true;
            }
            
            // Update Giscus theme
            const giscusFrame = document.querySelector('iframe.giscus-frame');
            if (giscusFrame) {
                giscusFrame.contentWindow.postMessage({
                    giscus: {
                        setConfig: {
                            theme: isDark ? 'light' : 'dark'
                        }
                    }
                }, 'https://giscus.app');
            }
        });
        
        // Highlight.js
        document.addEventListener('DOMContentLoaded', () => {
            hljs.highlightAll();
        });
        
        // KaTeX auto-render
        document.addEventListener('DOMContentLoaded', () => {
            if (typeof renderMathInElement !== 'undefined') {
                renderMathInElement(document.body, {
                    delimiters: [
                        {left: '$$', right: '$$', display: true},
                        {left: '$', right: '$', display: false},
                        {left: '\\[', right: '\\]', display: true},
                        {left: '\\(', right: '\\)', display: false}
                    ],
                    throwOnError: false
                });
            }
        });
        
        // TOC active state
        const tocLinks = document.querySelectorAll('.toc-container a');
        const headings = document.querySelectorAll('.post-content h2, .post-content h3, .post-content h4');
        
        function updateTocActive() {
            let current = '';
            headings.forEach(heading => {
                const rect = heading.getBoundingClientRect();
                if (rect.top <= 100) {
                    current = heading.getAttribute('id');
                }
            });
            
            tocLinks.forEach(link => {
                link.classList.remove('active');
                if (link.getAttribute('href') === '#' + current) {
                    link.classList.add('active');
                }
            });
        }
        
        window.addEventListener('scroll', updateTocActive);
        updateTocActive();
    </script>
</body>
</html>
